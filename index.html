<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://junzkn.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Never And Ever">
<meta property="og:url" content="http://junzkn.github.io/index.html">
<meta property="og:site_name" content="Never And Ever">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://junzkn.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Never And Ever</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Never And Ever</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">thanks for coming</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-时间线">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>时间线</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/problem/" class="post-title-link" itemprop="url">problem</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-17 15:12:39" itemprop="dateCreated datePublished" datetime="2020-01-17T15:12:39+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-03 14:46:48" itemprop="dateModified" datetime="2019-04-03T14:46:48+08:00">2019-04-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="关于gradle构建慢"><a href="#关于gradle构建慢" class="headerlink" title="关于gradle构建慢"></a>关于gradle构建慢</h3><p>最近在run应用时候特别慢，每一次几乎都是3-4分钟。看了一下是build时候<code>transformclasseswithdexfordebug</code>这个步骤拖慢的。最后在<a href="https://stackoverflow.com/questions/34158995/gradle-build-slow-on-transformclasseswithdexfordebug" target="_blank" rel="noopener">这里</a>找到了解决方法，在build.gradle文件中设置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    multiDexEnabled <span class="literal">true</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dexOptions &#123;</span><br><span class="line">    preDexLibraries <span class="literal">true</span></span><br><span class="line">    javaMaxHeapSize <span class="string">"4g"</span> <span class="comment">// Use gig increments depending on needs</span></span><br><span class="line">    incremental <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="找不到android库"><a href="#找不到android库" class="headerlink" title="找不到android库"></a>找不到android库</h3><p>新拉的项目build时候出现如下错误：</p>
<p><img src="/problem/1.PNG" alt="捕获"></p>
<p>错误是指找不到android supprot库。在项目buid.gradle配置中的仓库把<code>google()</code>放到前面</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()  <span class="comment">//把google的仓库放到第一个</span></span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            dirs <span class="string">'libs'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="找不到对应NDK"><a href="#找不到对应NDK" class="headerlink" title="找不到对应NDK"></a>找不到对应NDK</h3><p>在重构旧项目时，拉下项目后build出现了找不到对应NDK版本如下：</p>
<p><code>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</code>。这个错误时因为AS3.0以上开发环境导致的，解决方法有两个：</p>
<ol>
<li>从<a href="https://developer.android.com/ndk/downloads/?hl=zh-cn" target="_blank" rel="noopener">官网</a>上下载16版本的NDK，在toolchains文件夹找到缺失的NDK，弄到本地就行。</li>
<li>改变gradle plugin版本，这个还需要同时改变gradle版本，因为需要对应。不建议改到最新的gradle plugin版本，可能会出现资源整合错误，这个错误需要一个一个文件改成该版本格式。</li>
</ol>
<h3 id="AndroidStudio常用操作"><a href="#AndroidStudio常用操作" class="headerlink" title="AndroidStudio常用操作"></a>AndroidStudio常用操作</h3><p><code>ctrl+F</code>文件内全文件搜索字段</p>
<p><code>ctrl+shift+F</code>路径内全路径搜索字段</p>
<p><code>ctrl+N</code>全局找类名</p>
<p><code>ctrl+shift+N</code>全局找文件</p>
<p><code>shift+shift</code> search everywhere</p>
<p>点击文件再<code>ctrl+D</code>对比文件</p>
<h3 id="设置Activity半透明覆盖于之前Activity上"><a href="#设置Activity半透明覆盖于之前Activity上" class="headerlink" title="设置Activity半透明覆盖于之前Activity上"></a>设置Activity半透明覆盖于之前Activity上</h3><h3 id="关于Glide缓存导致图片资源出错"><a href="#关于Glide缓存导致图片资源出错" class="headerlink" title="关于Glide缓存导致图片资源出错"></a>关于Glide缓存导致图片资源出错</h3><h3 id="圆角图片"><a href="#圆角图片" class="headerlink" title="圆角图片"></a>圆角图片</h3><h2 id="drawable中的selector-shape等"><a href="#drawable中的selector-shape等" class="headerlink" title="drawable中的selector,shape等"></a>drawable中的selector,shape等</h2><h3 id="沉浸式状态栏"><a href="#沉浸式状态栏" class="headerlink" title="沉浸式状态栏"></a>沉浸式状态栏</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-Animation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-Animation/" class="post-title-link" itemprop="url">Android动画</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-08T00:00:00+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>Android中的动画分为两大类：View Animation视图动画和Property Animation属性动画。其中视图动画包括Tween Animation补间动画和Frame Animation帧动画。</p>
<h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><ul>
<li>作用对象：视图控件View。</li>
<li>大致原理：将预先准备好的每一帧播放出来，达到动画效果。</li>
<li>特点：<ul>
<li>优点：使用简单方便。</li>
<li>缺点：可能因为图片的数量或大小会引起OOM。</li>
</ul>
</li>
<li>应用场景：难以代码实现的动画，UI作图我们使用便可。</li>
</ul>
<h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><ul>
<li>作用对象：视图控件View。</li>
<li>大致原理：通过确定开始和结束的样式，中间的状态变化过程由系统补全。插值器可以改变变化速率但改变不了变化状态。</li>
<li>优缺点：<ul>
<li>优点：使用简单方便，有封装好的动画效果。</li>
<li>缺点：没法改变属性，缺乏整体效果控制。</li>
</ul>
</li>
<li>应用场景：<ul>
<li>标准动画：平移、旋转、缩放、透明度。</li>
<li>Activity和Fragment的转场切换效果。</li>
<li>ViewGroup中子元素的出场效果。</li>
</ul>
</li>
</ul>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><ul>
<li>作用对象：任意对象，不局限于View。</li>
<li>大致原理：在一定时间内，通过不断改变数值，给对象的属性设置来达到效果。变化速率可以使用插值器控制，变化效果我们可以手动控制或者使用估值器。</li>
<li>优缺点：<ul>
<li>优点：相比原有的动画扩充了许多，而且不止可以作用于View。</li>
<li>缺点：实现简单的可以使用封装过类，要实现复杂的动画操作起来比较麻烦。</li>
</ul>
</li>
<li>应用场景：需要改变View属性的动画、复杂动画、路径动画等。</li>
</ul>
<h2 id="帧动画-Frame-Animation"><a href="#帧动画-Frame-Animation" class="headerlink" title="帧动画(Frame Animation)"></a>帧动画(Frame Animation)</h2><p>帧动画，就是逐帧播放图片，每一帧都是从资源文件中获取帧，而不是通过系统绘制。因为是获取每一帧图片去播放，所以使用的时候就要注意避免大尺寸鱼片，以免造成OOM。</p>
<h3 id="xml实现帧动画"><a href="#xml实现帧动画" class="headerlink" title="xml实现帧动画"></a>xml实现帧动画</h3><p>先在res/anim下写xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:oneshot</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img0"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img1"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img2"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img3"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img4"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img5"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    //这里就展示几个item就好了 都是一样的显示时间就不重复贴了</span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们可以在xml文件中对ImageView的android:src/android:background属性直接设置使用或者在代码中设置也是一样的效果的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/iv"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:background</span>=<span class="string">"@drawable/frame_anim"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中开始动画：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过设置android:background时，得到AnimationDrawable 用如下方法</span></span><br><span class="line"><span class="keyword">final</span> AnimationDrawable animationDrawable = (AnimationDrawable) iv.getBackground();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过设置android:src时，得到AnimationDrawable 用如下方法</span></span><br><span class="line"><span class="comment">//AnimationDrawable animationDrawable = (AnimationDrawable) iv.getDrawable();</span></span><br><span class="line"></span><br><span class="line">animationDrawable.start() ;</span><br></pre></td></tr></table></figure>



<h3 id="代码实现帧动画"><a href="#代码实现帧动画" class="headerlink" title="代码实现帧动画"></a>代码实现帧动画</h3><p>先说一下AnimatedVectorDrawable这个类，这个类是用来创建逐帧动画的，有对应的方法来控制帧动画的各种操作。AnimatedVectorDrawable 与它类似，不过是矢量图的，通常与属性动画一起使用。</p>
<p>AnimatedVectorDrawable的常用方法：</p>
<ul>
<li>void start()：开始播放逐帧动画。</li>
<li>void stop()：停止播放逐帧动画。</li>
<li>int getDuration(int index)：得到指定index的帧的持续时间。</li>
<li>Drawable getFrame(int index)：得到指定index的帧所对应的Drawable对象。</li>
<li>int getNumberOfFrames()：得到当前AnimationDrawable的所有帧数量。</li>
<li>boolean isRunning()：判断当前AnimationDrawable是否正在播放。</li>
<li>void setOneShot(boolean oneShot)：设置AnimationDrawable是否执行一次，返true表示执行一次，返回false表示循环播放。</li>
<li>boolean isOneShot()：判断当前AnimationDrawable是否执行一次，返true表示执行一次，返回false表示循环播放。</li>
<li>void addFrame(Drawable frame,int duration)：为AnimationDrawable添加1帧，并设置持续时间。</li>
</ul>
<p>我们在代码中实现帧动画就是使用addFrame来进行动画的初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationDrawable animationDrawable = <span class="keyword">new</span> AnimationDrawable();</span><br><span class="line">animationDrawable.setOneShot(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">83</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = getResources().getIdentifier(<span class="string">"img"</span> + i, <span class="string">"drawable"</span>, getPackageName());</span><br><span class="line">    Drawable drawable = getResources().getDrawable(id);</span><br><span class="line">    animationDrawable.addFrame(drawable, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">iv.setBackground(animationDrawable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意：在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次</span></span><br><span class="line">animationDrawable.stop();</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure>

<p>这里我们使用到了<code>getIdentifier</code>方法来进行对应资源获取，它的第一个参数就是文件名，第二个参数是资源所在的文件类型，第三个参数就是包名。</p>
<h2 id="补间动画-Tween-Animation"><a href="#补间动画-Tween-Animation" class="headerlink" title="补间动画(Tween Animation)"></a>补间动画(Tween Animation)</h2><p>视图动画有5种类型：alpha(透明度)、scale(缩放)、translate(平移)、rotate(旋转)、set(动画组合)。</p>
<ul>
<li>alpha：渐变透明效果。</li>
<li>scale：渐变尺寸伸缩效果。</li>
<li>translate：位置移动效果。</li>
<li>rotate：旋转效果。</li>
<li>set：多种动画集合。</li>
</ul>
<p>视图动画的实现方可以使用xml文件，也可以直接在代码中实现。</p>
<h3 id="xml文件实现补间动画"><a href="#xml文件实现补间动画" class="headerlink" title="xml文件实现补间动画"></a>xml文件实现补间动画</h3><p>下面是一个scale动画的xml实现，先在res/anim下写xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version ="1.0" encoding ="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromXScale</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toXScale</span>=<span class="string">"1.4"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromYScale</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toYScale</span>=<span class="string">"2.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:duration</span>=<span class="string">"700"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再在代码中使用该xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(context,R.anim.scaleanimation) ; <span class="comment">//加载xml动画</span></span><br><span class="line">mView.startAnimation(animation); <span class="comment">//开始播放</span></span><br></pre></td></tr></table></figure>

<p>下面是set动画集合的xml实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version ="1.0" encoding ="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:duration</span>=<span class="string">"700"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromAlpha</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:toAlpha</span>=<span class="string">"1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fromDegrees</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:toDegrees</span>=<span class="string">"720"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotX</span>=<span class="string">"50"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotY</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="各类型动画的属性"><a href="#各类型动画的属性" class="headerlink" title="各类型动画的属性"></a>各类型动画的属性</h3><p>在上面的xml中我们可以看到，scale有自己的属性fromXScale，也有继承自Animation的属性duration。下面分别介绍各类型的各种属性。</p>
<h4 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale(缩放)"></a>scale(缩放)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromXScale</td>
<td align="center">动画起始时，控件在X轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">fromYScale</td>
<td align="center">动画起始时，控件在Y轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">toXScale</td>
<td align="center">动画结束时，控件在X轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">toYScale</td>
<td align="center">动画结束时，控件在Y轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">pivotX</td>
<td align="center">缩放起始点X轴坐标，可以是数值、百分数、百分数p三种样式</td>
</tr>
<tr>
<td align="center">pivotY</td>
<td align="center">缩放起始点Y轴坐标，可以是数值、百分数、百分数p三种样式</td>
</tr>
</tbody></table>
<p>fromXScale和toXScale中：1.0代表自身无变化，0.5代表缩小1倍，2.0代表放大1倍。</p>
<p>pivotX中：如果是数值，表示在当前视图的左上角，即原点处加上50px，作为缩放起始点X轴坐标；如果是50%，则表示在当前控件的左上角加上自己宽度的50%作为缩放起始点X轴坐标；如果是50%p ，则表示在当前控件的左上角加上父控件宽度的50%作为缩放起始点X轴坐标。pivotX影响的只是动画的起始位置，结束位置始终是不会变的。</p>
<h4 id="alpha-透明度"><a href="#alpha-透明度" class="headerlink" title="alpha(透明度)"></a>alpha(透明度)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromAlpha</td>
<td align="center">动画开始时的透明度，取值范围为0.0~1 .0, 表示全透明,1.0 表示完全不透明。</td>
</tr>
<tr>
<td align="center">toAlpha</td>
<td align="center">动画结束时的透明度，取值范围为0.0~1 .0, 表示全透明,1.0 表示完全不透明。</td>
</tr>
</tbody></table>
<h4 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate(旋转)"></a>rotate(旋转)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromDegrees</td>
<td align="center">动画开始旋转时的角度位置，正值代表顺时针方向的度数，负值 代表逆时针方向的度数</td>
</tr>
<tr>
<td align="center">toDegrees</td>
<td align="center">动画结束时旋转到的角度位置，正值代表顺时针方向的度数，负值 代表逆时针方向的度数</td>
</tr>
<tr>
<td align="center">pivotX</td>
<td align="center">旋转中心点X轴坐标，默认旋转中心点是控件坐标原点。可以是数值、百分数、百分数p</td>
</tr>
<tr>
<td align="center">pivotY</td>
<td align="center">旋转中心点Y轴坐标，默认旋转中心点是控件坐标原点。可以是数值、百分数、百分数p</td>
</tr>
</tbody></table>
<h4 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate(平移)"></a>translate(平移)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromXDelta</td>
<td align="center">起始点X轴坐标，可以是数值、百分数、百分数p</td>
</tr>
<tr>
<td align="center">fromYDelta</td>
<td align="center">起始点Y轴坐标，可以是数值、百分数、百分数p</td>
</tr>
<tr>
<td align="center">toXDelta</td>
<td align="center">终点X轴坐标</td>
</tr>
<tr>
<td align="center">to YDelta</td>
<td align="center">终点Y轴坐标</td>
</tr>
</tbody></table>
<h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p>Animation的下面这几个属性是全部类型的动画都有的，因为其他都是继承自Animation</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">duration</td>
<td align="center">用于设置完成一次动画的持续时间，以毫秒为单位</td>
</tr>
<tr>
<td align="center">fillAfter</td>
<td align="center">如果设置为true，控件动画结束时，将保持动画结束时的状态</td>
</tr>
<tr>
<td align="center">fillBefore</td>
<td align="center">如果设置为 true ，则控件动画结束时，将还原到初始化状态</td>
</tr>
<tr>
<td align="center">fillEnable</td>
<td align="center">与fillBefore一样</td>
</tr>
<tr>
<td align="center">repeatCount</td>
<td align="center">用于指定动画的重复次数，当取值为infinite时，表示无限循环</td>
</tr>
<tr>
<td align="center">repeatMode</td>
<td align="center">用于设定重复的类型，有reverse和restart两种值。reverse表示倒序回放，restart表示重放。必须与repeatCount一起使用。</td>
</tr>
<tr>
<td align="center">interpolator</td>
<td align="center">用于设定插器，插值器用于指定动画效果</td>
</tr>
</tbody></table>
<p>注意：在 set 标签中设直 repeateCount 属性是无效的，必须对每个动画单独设直才有作用。</p>
<p>插值器是用来计算时间变化的，计算出来的值表示当前时间对应动画进度百分比。</p>
<h3 id="代码实现视图动画"><a href="#代码实现视图动画" class="headerlink" title="代码实现视图动画"></a>代码实现视图动画</h3><p>视图动画每个类型会有对应的类。scale、rotate、alpha和translate的属性都会在对应类的构造函数中传参，set的属性需要使用对应的setXXX()方法。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">scale</td>
<td align="center">ScaleAnimation</td>
</tr>
<tr>
<td align="center">alpha</td>
<td align="center">AlphaAnimation</td>
</tr>
<tr>
<td align="center">rotate</td>
<td align="center">RotateAnimation</td>
</tr>
<tr>
<td align="center">translate</td>
<td align="center">TranslateAnimation</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">AnimationSet</td>
</tr>
</tbody></table>
<p>下面示例set的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation alpha = <span class="keyword">new</span> AlphaAnimation(<span class="number">1.0f</span>,<span class="number">0.1f</span>) ;  <span class="comment">//alpha动画</span></span><br><span class="line">Animation scale = <span class="keyword">new</span> ScaleAnimation(<span class="number">0.0f</span>,<span class="number">1.4f</span>,<span class="number">0.0f</span>,<span class="number">1.4f</span>); <span class="comment">//scale动画</span></span><br><span class="line"></span><br><span class="line">AnimationSet set = <span class="keyword">new</span> AnimationSet(<span class="keyword">true</span>) ; <span class="comment">//表示集合里面的动画共用同一个插值器</span></span><br><span class="line">set.addAnimation(alpha); <span class="comment">//添加动画</span></span><br><span class="line">set.addAnimation(scale);</span><br><span class="line">set.setDuration(<span class="number">700</span>);</span><br><span class="line">set.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mView.startAnimation(set); <span class="comment">//播放动画集合</span></span><br></pre></td></tr></table></figure>

<p>属性动画可设置动画的监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation alpha = <span class="keyword">new</span> AlphaAnimation(<span class="number">1.0f</span>,<span class="number">0.1f</span>) ;  <span class="comment">//alpha动画</span></span><br><span class="line">alpha.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画开始时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画结束时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画重复播放时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="补间动画的特殊应用场景"><a href="#补间动画的特殊应用场景" class="headerlink" title="补间动画的特殊应用场景"></a>补间动画的特殊应用场景</h3><p>在Android中有些地方对补间动画进行了封装，可以使用特定API或者在xml配置特定参数实现动画效果。特殊的场景有许多，例如Activity的切换动画、Fragment的切换动画、ViewGroup中子元素的出场效果(ListView)。</p>
<h4 id="Activity的切换动画"><a href="#Activity的切换动画" class="headerlink" title="Activity的切换动画"></a>Activity的切换动画</h4><p>启动的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent (<span class="keyword">this</span>,Acvtivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivity(intent);</span><br><span class="line">overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</span><br><span class="line"><span class="comment">// enterAnim：从Activity a跳转到Activity b，进入b时的动画效果资源Id</span></span><br><span class="line"><span class="comment">// exitAnim：从Activity a跳转到Activity b，离开a时的动画效果资源Id</span></span><br><span class="line"><span class="comment">// 特别注意overridePendingTransition()必须要在startActivity(intent)后被调用才能生效</span></span><br></pre></td></tr></table></figure>

<p>退场动画：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.finish();</span><br><span class="line">    overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</span><br><span class="line">    <span class="comment">// enterAnim：从Activity a跳转到Activity b，进入b时的动画效果资源Id</span></span><br><span class="line">    <span class="comment">// exitAnim：从Activity a跳转到Activity b，离开a时的动画效果资源Id</span></span><br><span class="line">    <span class="comment">// 特别注意 overridePendingTransition()必须要在finish()后被调用才能生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于参数 enterAnim &amp; exitAnim 的资源ID，系统有自带的效果android.R.anim.xxx，也可以自己设置动画xml。自己设置的xml就是补间动画的xml，里面可以是alpha、scale、translate、rotate和set。</p>
<h4 id="Fragment的切换动画"><a href="#Fragment的切换动画" class="headerlink" title="Fragment的切换动画"></a>Fragment的切换动画</h4><p>使用系统自带的切换效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">fragmentTransaction.setTransition(<span class="keyword">int</span> transit);</span><br><span class="line"><span class="comment">// 通过setTransition(int transit)进行设置</span></span><br><span class="line"><span class="comment">// 标准动画设置好后，在Fragment添加和移除的时候都会有。</span></span><br></pre></td></tr></table></figure>

<p>自定义动画效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">fragmentTransaction.setCustomAnimations(R.anim.in_from_right,R.anim.out_to_left);</span><br><span class="line"><span class="comment">// in_from_right：从Fragment a跳转到Fragment b，进入b时的动画效果资源Id</span></span><br><span class="line"><span class="comment">// out_to_left：从Fragment a跳转到Fragment b，离开a时的动画效果资源Id</span></span><br></pre></td></tr></table></figure>

<h4 id="ListView的子元素出场动画"><a href="#ListView的子元素出场动画" class="headerlink" title="ListView的子元素出场动画"></a>ListView的子元素出场动画</h4><p>先在ListView的xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/lv"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layoutAnimation</span>=<span class="string">"@anim/anim_layout"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>layoutAnimation设置为我们自定义的anim_layout，然后新建anim_layout：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:delay</span>=<span class="string">"0.5"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animation</span>=<span class="string">"@anim/view_animation"</span></span></span><br><span class="line"><span class="tag">                 /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">delay:子元素开始动画的时间延迟</span></span><br><span class="line"><span class="comment">animationOrder:表示子元素动画的顺序</span></span><br><span class="line"><span class="comment">animation:自定义的补间动画</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="属性动画-Property-Animation"><a href="#属性动画-Property-Animation" class="headerlink" title="属性动画(Property Animation)"></a>属性动画(Property Animation)</h2><p>属性动画不同于视图动画，视图动画能够实现移动、旋转、拉伸和透明等效果，但是如果想要让颜色做动画渐变就实现不了了。属性动画是通过改变控件的某一个属性来做动画的，可以实现颜色等不同效果。并且是因为属性的改变，所以控件执行动画后的单击区域问题也就不像补间动画那样不能点击。</p>
<p>补间动画的命名都是XXXAnimation，而属性动画则是XXXAnimator。</p>
<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator，他是一个数值变化监听器，不会对控件做任何操作。我们通过给它设定从哪个值运动到哪个值，然后监听值的变化，给对应控件的对应属性设置，从而实现动画。</p>
<p>与Scroller原理类似，Scroller类也是不会对控件执行任何操作的，而是通过设定滚动值和时长来自己计算被动过程的。</p>
<p>ValueAnimator初步使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个int类型变化监听的ValueAnimator</span></span><br><span class="line">ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">400</span>) ;</span><br><span class="line">animator.setDuration(<span class="number">2000</span>) ;</span><br><span class="line">animator.setSatrtDelay(<span class="number">1000</span>); <span class="comment">//延时1</span></span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getAnimatedValue获取当前值</span></span><br><span class="line">        <span class="keyword">int</span> curValue = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">        <span class="comment">//改变属性</span></span><br><span class="line">        mView.layout(curValue,curValue,</span><br><span class="line">                     curValue+mView.getWidth(),curValue+mView.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动动画</span></span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>除了可以设置AnimatorUpdateListener这个监听器监听实时值变化外，还可以设置AnimatorListener来监听动画状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">animator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画取消</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画重复时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在上面使用的是<code>ValueAnimator.ofInt(int... values)</code>来创建ValueAnimator，与他相似的方法是<code>ValueAnimator.ofFloat(float... values)</code>。他们两个都能传入变长参数，第一个是初始值，最后一个是结束值，中间可以插入若干个中间值。</p>
<p>还有一个方法是<code>ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values)</code>，这个方法表前面的ofInt和ofFloat多了一个TypeEvaluator类型的参数，这个就是估值器。因为int类型和float类型系统会使用默认的估值器，而Object的话系统不知道该如何估值，需要我们自定义估计值。</p>
<p>这里说一下插值器和估值器。插值器和补间动画的插值器是一样的，用来计算时间变化的，计算出来的值表示当前时间对应动画进度百分比。而估值器，插值器算出1000毫秒的时候值为0.2，那么这个0.2再通过估值器转化，转化成对应的你要的属性，你可以根据这个百分比设置对应颜色之类的。上面代码中的<code>animation.getAnimatedValue()</code>获得的值是经过估值器计算后的值。</p>
<p>ValueAnimator的流程图如下：</p>
<p><img src="/Android-Animation/属性动画流程图.png" alt="属性动画流程图"></p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator，重写了ofInt和odFloat等几个方法，让我们使用起来更加方便。例如我们需要一个透明度的动画：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator = ObbjectAnimator.ofFloat(mView,<span class="string">"alpha"</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>在上面，</p>
<h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><h2 id="各动画源码分析"><a href="#各动画源码分析" class="headerlink" title="各动画源码分析"></a>各动画源码分析</h2><h3 id="帧动画-1"><a href="#帧动画-1" class="headerlink" title="帧动画"></a>帧动画</h3><h3 id="补间动画-1"><a href="#补间动画-1" class="headerlink" title="补间动画"></a>补间动画</h3><p>属性动画的基本使用在上面已经说明，接着来看这个动画是如何播放的。不论是xml实现还是代码实现，最后都要调用<code>startAnimation()</code>方法进行动画播放，先从这里入手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    animation.setStartTime(Animation.START_ON_FIRST_FRAME);  <span class="comment">//-----1-----</span></span><br><span class="line">    setAnimation(animation);  <span class="comment">//-----2-----</span></span><br><span class="line">    invalidateParentCaches(); <span class="comment">//----3----</span></span><br><span class="line">    invalidate(<span class="keyword">true</span>); <span class="comment">//----4----</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不多，只有四个方法。第一个是对一些变量进行赋值；第二个主要把动画和当前View绑定；</p>
<p>第三个方法<code>invalidateParentCaches</code>在View的滑动中的Scroll中有说到，是用来改变标志从而令ViewGroup发生重绘。</p>
<p>第四个就是常用到的<code>invalidate</code>方法，用于刷新view自身。</p>
<p><code>invalidateParentCaches</code>方法也比较熟悉，它对于绘制的主要致步骤如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    drawBackground(canvas);</span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    onDraw(canvas);            </span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatchDraw</code>中遍历子View绘制子View：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">                <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">                transientIndex++;</span><br><span class="line">                <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                    transientIndex = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">            <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</span><br><span class="line">                ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);   <span class="comment">//------1-----</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处便是对子view调用drawChild(canvas, child, drawingTime)，这里要区别一下，这个调用的是带有三个参数的draw()，不是一个参数的draw()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">        Transformation transformToApply = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> concatMatrix = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> scalingRequired = mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mScalingRequired;</span><br><span class="line">    <span class="keyword">final</span> Animation a = getAnimation();<span class="comment">//获取动画</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);<span class="comment">//-----1----</span></span><br><span class="line">        concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">        <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取的Transformation对象，包含动画矩阵</span></span><br><span class="line">        <span class="comment">//-----2----</span></span><br><span class="line">        transformToApply = parent.getChildTransformation();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">        <span class="keyword">if</span> (!drawingWithRenderNode || transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//-------3.1------</span></span><br><span class="line">            <span class="comment">//保存该canvas</span></span><br><span class="line">            restoreTo = canvas.save();</span><br><span class="line">        &#125;</span><br><span class="line">    ..........</span><br><span class="line">        <span class="keyword">if</span> (transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ..........</span><br><span class="line">                <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">                        <span class="comment">//----4.0----</span></span><br><span class="line">                        renderNode.setAnimationMatrix(transformToApply.getMatrix());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//-------4.1-----</span></span><br><span class="line">                        canvas.translate(-transX, -transY);</span><br><span class="line">                        canvas.concat(transformToApply.getMatrix());<span class="comment">//为该canvas画布应用了该动画矩阵</span></span><br><span class="line">                        canvas.translate(transX, transY);</span><br><span class="line">                        <span class="comment">//------4.1----</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> transformAlpha = transformToApply.getAlpha();</span><br><span class="line">            <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                alpha *= transformAlpha;</span><br><span class="line">                parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span> (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) &#123;</span><br><span class="line">            <span class="comment">//------4.2-----</span></span><br><span class="line">        	canvas.translate(-transX, -transY);</span><br><span class="line">        	canvas.concat(getMatrix());</span><br><span class="line">        	canvas.translate(transX, transY);</span><br><span class="line">            <span class="comment">//------4.2-----</span></span><br><span class="line">    	&#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line">..........</span><br><span class="line">    <span class="keyword">if</span> (restoreTo &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//恢复到之前状态的canvas，所以并不会影响到其它子view的绘制，即使他们使用的都是viewgroup传递下来的画布</span></span><br><span class="line">         <span class="comment">//-------3.2------</span></span><br><span class="line">        canvas.restoreToCount(restoreTo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释2处，Transformation对象中包含一个矩阵和alph值，矩阵是用来做平移、旋转和缩放动画的。</p>
<p>从3.1和3.2可以看出，每绘制一个子view，都会先对画布状态进行保存save()，然后绘制完该子view之后。又会恢复restore()，所以如果在任何一个子view的onDraw(canvas)对canvas进行操作都不会影响到所在的viewgroup和同级的其他子view。</p>
<p>从4.1和4.2看出，我们的视图动画都没有都View进行改变，改变的只是canvas或renderNode。</p>
<p>动画的关键还是在注释1处的<code>applyLegacyAnimation</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyLegacyAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</span><br><span class="line">    Transformation invalidationTransform;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        <span class="comment">//------1------</span></span><br><span class="line">        a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</span><br><span class="line">        <span class="comment">//------2------</span></span><br><span class="line">        a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) a.setListenerHandler(mAttachInfo.mHandler);</span><br><span class="line">        onAnimationStart(); <span class="comment">//---熟悉的视图动画的回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Transformation t = parent.getChildTransformation();</span><br><span class="line">    <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);  <span class="comment">//------3-----</span></span><br><span class="line">    <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</span><br><span class="line">        &#125;</span><br><span class="line">        invalidationTransform = parent.mInvalidationTransformation;</span><br><span class="line">        a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        invalidationTransform = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.willChangeBounds()) &#123; <span class="comment">//--------4------</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==</span><br><span class="line">                ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">                parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == <span class="number">0</span>) &#123;</span><br><span class="line">                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                <span class="comment">//------7-----</span></span><br><span class="line">                parent.invalidate(mLeft, mTop, mRight, mBottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//------5-------</span></span><br><span class="line">            <span class="keyword">if</span> (parent.mInvalidateRegion == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.mInvalidateRegion = <span class="keyword">new</span> RectF();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> RectF region = parent.mInvalidateRegion;</span><br><span class="line">            a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</span><br><span class="line">                  invalidationTransform);</span><br><span class="line">            parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft + (<span class="keyword">int</span>) region.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop + (<span class="keyword">int</span>) region.top;</span><br><span class="line">            <span class="comment">//-----7------</span></span><br><span class="line">            parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</span><br><span class="line">                              top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处，初始化Animation（仅初始化一次）调用Animation.initialize(width, height, parentWidth, parentHeight)，通过View及ParentView的Size来解析Animation中的相关数据。</p>
<p>注释2处，调用Animation.initializeInvalidateRegion(left, top, right, bottom)来设定动画的初始区域，并在fillBefore为true时计算Animation动画进度为0.0f的数据。</p>
<p>注释3处，调用getTransformation根据当前绘制事件生成Animation中对应帧的动画数据。</p>
<p>处理完前三步后，接着是根据动画数据设定重绘制区域：</p>
<p>若为若仅为Alpha动画，注释4，此时动画区域为View的当前区域，且不会产生变化；若包含非Alpha动画，注释5，此时动画区域需要调用<code>Animation.getInvalidateRegion</code>进行计算，该函数会根据上述生成动画数据Thransformation中的Matrix进行计算，并与之前的动画区域执行unio操作，从而获取动画的完整区域。</p>
<p>最后，都通过注释7处，调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域。</p>
<p>我们还要看一下注释3的<code>getTransformation</code>里面是怎么样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartTime == -<span class="number">1</span>) &#123;</span><br><span class="line">        mStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startOffset = getStartOffset();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> duration = mDuration;</span><br><span class="line">    <span class="keyword">float</span> normalizedTime;</span><br><span class="line">    <span class="keyword">if</span> (duration != <span class="number">0</span>) &#123;</span><br><span class="line">        normalizedTime = ((<span class="keyword">float</span>) (currentTime - (mStartTime + startOffset))) /</span><br><span class="line">            (<span class="keyword">float</span>) duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        normalizedTime = currentTime &lt; mStartTime ? <span class="number">0.0f</span> : <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> expired = normalizedTime &gt;= <span class="number">1.0f</span> || isCanceled();</span><br><span class="line">    mMore = !expired;</span><br><span class="line">    <span class="keyword">if</span> (!mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">if</span> ((normalizedTime &gt;= <span class="number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="number">1.0f</span> || mFillAfter)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">            fireAnimationStart();</span><br><span class="line">            mStarted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (NoImagePreloadHolder.USE_CLOSEGUARD) &#123;</span><br><span class="line">                guard.open(<span class="string">"cancel or detach or getTransformation"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCycleFlip) &#123;</span><br><span class="line">            normalizedTime = <span class="number">1.0f</span> - normalizedTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">        <span class="comment">//------1------</span></span><br><span class="line">        applyTransformation(interpolatedTime, outTransformation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法我们可以看到，会通过duration和插值器来计算时间，最后通过注释1处的<code>applyTransformation</code>来绘制每一帧动画。<code>applyTransformation</code>是个空方法，都是子类实现，不懂动画有自己实现。当我们自定义动画就要去重写这个方法。</p>
<h3 id="属性动画-1"><a href="#属性动画-1" class="headerlink" title="属性动画"></a>属性动画</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-View/" class="post-title-link" itemprop="url">Android中View体系</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-06T00:00:00+08:00">2019-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="View与ViewGroup"><a href="#View与ViewGroup" class="headerlink" title="View与ViewGroup"></a>View与ViewGroup</h2><p>View是所有Android控件的基类，而ViewGroup是继承自View，是多个View 的组合。View中可以包含ViewGroup，ViewGroup中可以包含View，以此类推，形成一个View树。</p>
<p><img src="/Android-View/View树.png" alt="View树"></p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><h3 id="Android中的坐标系"><a href="#Android中的坐标系" class="headerlink" title="Android中的坐标系"></a>Android中的坐标系</h3><p>Android系统中，将左上角的顶点作为Android坐标系的原点，原点向右是X轴正方向，原点向下是Y轴正方向。在触摸事件中用getRawX()和getRawY()获取的就是这个坐标系的x和y坐标。</p>
<p><img src="/Android-View/屏幕坐标.png" alt="屏幕坐标"></p>
<h3 id="View中坐标体系"><a href="#View中坐标体系" class="headerlink" title="View中坐标体系"></a>View中坐标体系</h3><p>View坐标体系是对于View而言的坐标，类似于相对坐标。它与Android坐标并不冲突，一般用于对View的控制使用，例如滑动，重新绘制等。</p>
<p><img src="/Android-View/View坐标.png" alt="View坐标"></p>
<p>View自身的方法：</p>
<ul>
<li><code>getTop()</code>：获取View自身顶部到父布局顶部的距离。</li>
<li><code>getBottom()</code>：获取View自身低部到父布局低部的距离。</li>
<li><code>getRight()</code>：获取View自身右边到父布局右边的距离。</li>
<li><code>getLeft()</code>：获取View自身左边到父布局左边的距离。</li>
</ul>
<p>可以用来计算出View的宽度和高度。</p>
<p>MotionEvent提供的方法：</p>
<ul>
<li><code>getX()</code>：获取点击事件到控件左边距离，是相对坐标。</li>
<li><code>getY()</code>：获取点击事件到控件顶部距离，是相对坐标。</li>
<li><code>getRawX()</code>：获取点击事件到屏幕左边距离，是绝对坐标。</li>
<li><code>getRawY()</code>：获取点击事件到屏幕顶部距离，是绝对坐标。</li>
</ul>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>View滑动是开发中非常多使用到的，其基本思想是：当点击事件传递到View时，系统记录下触摸点的坐标，手指滑动时记录滑动后的坐标，然后计算出偏移量，通过偏移量来修改View的相关属性，达到滑动效果。</p>
<h3 id="调用layout-方法"><a href="#调用layout-方法" class="headerlink" title="调用layout()方法"></a>调用layout()方法</h3><p>View绘制的时候会调用<code>layout()</code>方法来设置显示的位置，设置是会根据自身的mTop、mLeft、mBottom、mRight四个属性去放置位置。<code>layout()</code>中的四个left、top、right、bottom四个参数就是用来改变mTop、mLeft、mBottom、mRight的。所以我们可以自己算出偏移量再去调用<code>layout()</code>方法便可实现滑动。</p>
<p>重写View的OnTouchEvent方法可以实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)event.getX() ;</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>)event.getY() ;</span><br><span class="line">    <span class="keyword">switch</span>(event.getAction())&#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">//初始位置</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">//计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX ;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY ; </span><br><span class="line">            <span class="comment">//调用layout()方法重新放置位置</span></span><br><span class="line">            layout(getLeft()+offsetX,getYop()+offsetY,getRight()+offsetX,getBottom()+offsetY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="调用offsetLeftAndRight-与offsetTopAndBottom-方法"><a href="#调用offsetLeftAndRight-与offsetTopAndBottom-方法" class="headerlink" title="调用offsetLeftAndRight()与offsetTopAndBottom()方法"></a>调用offsetLeftAndRight()与offsetTopAndBottom()方法</h3><p><code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code>两个方法和<code>layout()</code>方法差不多，也是通过修改View自身的mTop、mLeft、mBottom、mRight四个属性从而去改变View的位置。</p>
<p>我们可以在上面ACTION_MOVE中将<code>layout()</code>方法换成<code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">          <span class="comment">//计算偏移量</span></span><br><span class="line">          <span class="keyword">int</span> offsetX = x - lastX ;</span><br><span class="line">          <span class="keyword">int</span> offsetY = y - lastY ; </span><br><span class="line">          <span class="comment">//进行偏移</span></span><br><span class="line">          offsetLeftAndRight(offsetX) ; </span><br><span class="line">   offsetTopAndBottom(offsetY) ; </span><br><span class="line">          <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h3 id="使用LayoutParams改变布局参数"><a href="#使用LayoutParams改变布局参数" class="headerlink" title="使用LayoutParams改变布局参数"></a>使用LayoutParams改变布局参数</h3><p>LayoutParams保存了一个View的布局参数，在View的measure过程中，是根据父控件的MeasureSpec和View自身的LayoutParams来决定的。也就是说我们可以通过改变View的LayoutParams来改变View在父控件中的位置，达到View滑动效果。</p>
<p>需要注意，在获取LayoutParams的时候要根据父容器的类型还获得不同的LayoutParams。推荐使用ViewGroup.MarginLayoutParams来实现，将ACTION_MOVE改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为父布局是LinearLayout，所以使用LinearLayout.LayoutParams</span></span><br><span class="line"><span class="comment">//如果父布局是RelativeLayout则使用RelativeLayout.LayoutParams</span></span><br><span class="line">LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams)getLayoutParams() ;</span><br><span class="line">layoutParams.leftMargin() = getLeft() + offsetX ; </span><br><span class="line">layoutParams.topMargin() = getTop() + offsetY ; </span><br><span class="line">setLayoutParams(layoutParams) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了使用布局的用LayoutParams，还可以使用ViewGroup.MarginLayoutParams</span></span><br><span class="line">ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams)getLayoutParams() ;</span><br><span class="line">layoutParams.leftMargin() = getLeft() + offsetX ; </span><br><span class="line">layoutParams.topMargin() = getTop() + offsetY ; </span><br><span class="line">setLayoutParams(layoutParams) ;</span><br></pre></td></tr></table></figure>




<h3 id="scrollTo-、scollBy"><a href="#scrollTo-、scollBy" class="headerlink" title="scrollTo()、scollBy()"></a>scrollTo()、scollBy()</h3><p>scollTo/scollBy是Android专门提供的让View滑动的方法，是View里面的方法，这种方法是通过<code>invalidateParentCaches()</code>重新绘制父布局来达到滑动效果，重绘父布局的时候也会重新绘制其下子View的布局。scrollTo（x，y）表示移动到一个具体的坐标点，而scrollBy（dx，dy）则表示移动的增量为dx、dy。其实scollBy最终也是要调用scollTo的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();  <span class="comment">//这里重新绘制父布局</span></span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scrollTo里面通过改变mScrollY和mScrollX，这个mScrollX是指View的左边缘到View的内容的左边缘的距离，mScrollY是指View的上边缘到View的内容的上边缘的距离。用下图来表达更为清晰：</p>
<p><img src="/Android-View/距离状态.jpg" alt="距离状态"></p>
<p>要注意的两个点，第一个是这里mScrollY和mScrollX的正负值，与平时我们理解的是反过来的。第二个移动的不是View而是View的内容，也就是红色表示区域在移动。怎么理解View和View的内容呢？如果该View没有子View，那么移动的就是View的内容（比如说调用一个Button的相应方法，会发现Button本身并不会移动，移动 的是Button的文本内容）；如果该View中有子View，那么移动的就是子View（比如说一个FrameLayout中有一个Button，调用FrameLayout的相应方法，会发现Button移动而FrameLayout不移动）。</p>
<p>将ACTION_MOVE改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为是View的内容移动，所以要用父布局去scrollBy</span></span><br><span class="line">((View)getParent()).scrollBy(-offsetX,-offsetY);</span><br></pre></td></tr></table></figure>




<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>我们还可以使用Android官方提供的动画来实现View的滑动，动画的原理大致是，将需要进行的动画的每一帧存到一个数组中，根据这个数组重新绘制父布局来实现动画效果。和<code>scrollTo()</code>一样会调用<code>invalidateParentCaches()</code>重新绘父布局。</p>
<p>需要注意的是，补间动画只是重新绘制了View的位置，View的属性并没有改变。而属性动画会改变View自身的一些translation属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//补间动画例子</span></span><br><span class="line">mCustomView.setAnimation(AnimationUtils.loadAnimation(context,R.anim.translate));</span><br><span class="line"><span class="comment">//属性动画例子</span></span><br><span class="line">ObjectAnimator.ofFloat(mCustomView,<span class="string">"translationX"</span>,<span class="number">0</span>,<span class="number">300</span>).setDuration(<span class="number">1000</span>).start();</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>上面的5中方法，其中前三种是一个原理，通过改变view的属性参数去实现滑动，scrollTo/scrollBy则是View原有的滑动API，动画是专门针对View的位置大小改变的库。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">改变布局参数</td>
<td align="center">操作复杂，适合用于有交互的View的简单移动变化</td>
</tr>
<tr>
<td align="center">scrollTo/scrollBy</td>
<td align="center">操作简单，适合对View内容进行滑动</td>
</tr>
<tr>
<td align="center">动画</td>
<td align="center">操作简单，适用于没有交互的View进行复杂的移动变化</td>
</tr>
</tbody></table>
<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><h3 id="Activity构成"><a href="#Activity构成" class="headerlink" title="Activity构成"></a>Activity构成</h3><p>我们点击屏幕，系统会将点击事件包装，最先传递到Activity的，然后再由Activity根据布局传递。所以需要先分析Activity的布局源码。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们一般在Activity的<code>onCreate()</code>中调用<code>setContentView()</code>方法来设置布局：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用window的setContentView</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity内又会调用<code>window.setContentView()</code>，这个<code>getWindow()</code>返回的是一个PhoneWindow对象，它继承自Window。PhoneWindow的setContentView方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor(); <span class="comment">//--------1-------</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"> 	.........</span><br><span class="line">    mContentParent = generateLayout(mDecor);<span class="comment">//--------2-------</span></span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要看注释1处的<code>installDecor()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ........</span><br><span class="line">	<span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>); <span class="comment">//------1-----</span></span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释1处，<code>generateDecor()</code>返回一个DecorView，这个DecorView就是Activity中的根View了。DecorView是PhoneWindow的内部类，继承自FrameLayout。上一个代码块的注释2处，<code>generateLayout(mDecor)</code>的作用就是更根据不同情况加载不同布局，一般情况下会加载<code>R.layout.screen_title</code>这个布局，布局如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">"?android:attr/windowTitleSize"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">style</span>=<span class="string">"?android:attr/windowTitleBackgroundStyle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@android:id/title"</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">style</span>=<span class="string">"?android:attr/windowTitleStyle"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:background</span>=<span class="string">"@null"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:fadingEdge</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的ViewStub是用来显示Actionbar的。下面的两个FrameLayout：一个是title，用来显示标题；另一个是content，用来显示内容。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看到上面的源码，大家就知道了一个Activity包含一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根 View，而这个 DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平常做应用所写的布局正是展示在ContentView中的。</p>
<p><img src="/Android-View/Activity构成.png" alt="Activity构成"></p>
<h3 id="事件传递分发机制"><a href="#事件传递分发机制" class="headerlink" title="事件传递分发机制"></a>事件传递分发机制</h3><p>我们的点击事系统会包装成一个类：MotionEvent。Activity会将这个MotionEvent传递到View层级，然后就是View对这个事件的分发和消费。</p>
<p>在View和ViewGroup中，事件分发有三个重要方法：</p>
<ul>
<li><code>dispatchTouchEvent(MotionEvent ev)</code>  —— 负责进行对事件分发，是否传递事件，是否消费事件。ViewGroup继承自View，它对这个方法进行了重写。</li>
<li><code>onInterceptTouchEvent(MotionEvent ev)</code> —— 判断ViewGroup是否拦截事件，这个方法仅仅在ViewGroup中重写的<code>dispatchTouchEvent</code>中有。</li>
<li><code>onTouchEvent(MotionEvent ev)</code>  —— 事件响应在这方法内，这个方法是在<code>dispatchTouchEvent</code>中调用。</li>
</ul>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>先看ViewGroup重写过的<code>dispatchTouchEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        cancelAndClearTouchTargets(ev);</span><br><span class="line">        <span class="comment">//清除FLAG_DISALLOW_INTERCEPT设置，并且将mFirstTouchTarget设置为null</span></span><br><span class="line">        resetTouchState();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">    <span class="comment">//-------1-------</span></span><br><span class="line">    <span class="comment">//“actionMasked == MotionEvent.ACTION_DOWN”用来判断是否是一个新的事件，一个新的事件都是DOWN开始的</span></span><br><span class="line">    <span class="comment">//“mFirstTouchTarget != null”用来判断是否是拦截事件，为null的时候是拦截了</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//------2-----</span></span><br><span class="line">        <span class="comment">//这个disallowIntercept是判断是否阻止拦截</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">            intercepted = onInterceptTouchEvent(ev);<span class="comment">//------3------</span></span><br><span class="line">            ev.setAction(action); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//onInterceptTouchEvent方法没有重写的话默认返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//默认返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1有一个mFirstTouchTarget，这个标记是标识ViewGroup是否拦截事件，当ViewGroup执行了<code>onInterceptTouchEvent</code>方法后这个就会设置为null。如果之前已经拦截过事件，那么注释3处的<code>onInterceptTouchEvent</code>就不会执行，会直接往下执行。所以，当拦截后，同一个事件序列的后续的事件都会交给ViewGroup处理，不会再调用<code>onInterceptTouchEvent</code>方法。</p>
<p>注释2处，<code>onInterceptTouchEvent</code>之前还有一个判断，这个用来判断是否阻止拦截。FLAG_DISALLOW_INTERCEPT这个标志会在子View中使用<code>requestDisallowInterceptTouchEvent</code>来进行设置，是子View干预父View的事件分发过程(ACTION_DOWN事件除外)的方法，也处理滑动冲突的重要方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示阻止拦截，父ViewGroup不会调用onInterceptTouchEvent方法</span></span><br><span class="line">childView.getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>剩余的<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="comment">//遍历子View</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//-------1--------</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">            childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">            preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//-----2-----</span></span><br><span class="line">        <span class="comment">//用于判断子View是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//--------3-------</span></span><br><span class="line">        <span class="comment">//已经有子View处理，跳出循环</span></span><br><span class="line">        newTouchTarget = getTouchTarget(child);</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resetCancelNextUpFlag(child);</span><br><span class="line">        <span class="comment">//-------3.5------</span></span><br><span class="line">        <span class="comment">//子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign))&#123;</span><br><span class="line">            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                        mLastTouchDownIndex = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLastTouchDownIndex = childIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTouchDownX = ev.getX();</span><br><span class="line">            mLastTouchDownY = ev.getY();</span><br><span class="line">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;<span class="comment">//------4-----</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">	 <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//-----5------</span></span><br><span class="line">         <span class="comment">//mFirstTouchTarget之前有说过，如果为null则是ViewGroup拦截了</span></span><br><span class="line">         <span class="comment">//dispatchTransformedTouchEvent传cancel和null</span></span><br><span class="line">         handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         .....</span><br><span class="line">         <span class="comment">//------6.0------</span></span><br><span class="line">         <span class="comment">//这里遍历可以传递事件的目标子View，注释3处有子View处理就是在这处理</span></span><br><span class="line">         <span class="keyword">while</span> (target != <span class="keyword">null</span>)&#123;  </span><br><span class="line">         	 <span class="comment">//-----6-------</span></span><br><span class="line">             <span class="comment">//alreadyDispatchedToNewTouchTarget在注释4处处理了，如果子View消费事件，则直接返回true    </span></span><br><span class="line">             <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                 handled = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//------7------</span></span><br><span class="line">                 <span class="comment">//如果子View没有消费事件，就dispatchTransformedTouchEvent</span></span><br><span class="line">                 <span class="comment">//这里和注释3的效果是一样的</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)|| intercepted;</span><br><span class="line">                 <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, </span><br><span class="line">                     cancelChild,target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                     handled = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ViewGroup没有拦截事件，注释1处会用一个for循环来遍历子View，要注意的是自View的遍历循序的按图层的从上往下的去遍历。</p>
<p>注释2处是判断点击事件是否在当前子View的范围内，或者当前子View是否在播放动画中，不符合条件就continue。注释3处是找到一个符合条件的子View，将他记录好。如果有特殊情况，则进入<code>dispatchTransformedTouchEvent</code>方法，这时传的是false和child。</p>
<p>注释5处就是对应之前的mFirstTouchTarget，拦截了事件，也会调用<code>dispatchTransformedTouchEvent</code>方法，不过参数里面传的子View是null。</p>
<p>注释6，如果有过在3.5处子View消费事件，直接返回true。</p>
<p>注释7，没有拦截事件，也没有在3.5处处理过事件，传递事件。要注意，如果这时<code>onInterceptTouchEvent</code>返回的是true，则会传cancel事件即ACTION_CANCEL给子View，表示被ViewGroup拦截了，子View事件终止。传递ACTION_CANCEL的情况会出现在VIewGroup在ACTION_DOWN没有拦截，而ACTION_MOVE或者ACTION_UP拦截的时候。</p>
<p>下面是<code>dispatchTransformedTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，有子View就会调用子View的<code>dispatchTouchEvent</code>方法，没有子View则会super.dispatchTouchEvent。因为ViewGroup继承自View，也就是调用View的<code>dispatchTouchEvent</code>方法。</p>
<p>上面是ViewGroup重写过的<code>dispatchTouchEvent</code>分析，下面看回View的<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123; <span class="comment">//-----1----</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123; <span class="comment">//-----2-----</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释1处可以看出，如果给View设置onTouchListener后，Listener中的方法会优先于View中的<code>onTouchEvent</code>方法。2处便是三个重要方法中的<code>onTouchevent</code>了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//-------1-----</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE|| (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)|| (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">    ....</span><br><span class="line">     <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">     	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        	<span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            	....</span><br><span class="line">            	performClickInternal(); <span class="comment">//----2----</span></span><br><span class="line">            	....</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: </span><br><span class="line">            	....</span><br><span class="line">            	checkForLongClick(<span class="number">0</span>, x, y); <span class="comment">//----3----</span></span><br><span class="line">            	....</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1处，View的CLICKABLE和LONG_CLICKABLE有一个为true，那么onTouchEvent（）就会返回true消耗这个事件。CLICKABLE和LONG_CLICKABLE代表View可以被点击和长按点击，可以通过View的setClickable和setLongClickable方法来设置，也可以通过View的setOnClickListenter和setOnLongClickListener来设置，它们会自动将View设置为CLICKABLE和LONG_CLICKABLE。</p>
<p>2处是触发onClickListener，3处是触发onLongClickListener。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/Android-View/流程图.png" alt="流程图"></p>
<p>上图是ViewGroup和View的事件分发关键方法的流程图。蓝色区域是ViewGroup的流程，红色区域是View的部分。</p>
<p><img src="/Android-View/事件传递.png" alt="事件传递"></p>
<h3 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h3><p>两个控件都可以滑动或点击的时候，就会出现滑动冲突的情况，我们的解决方法有如下两种，外部拦截和内部拦截，一般推荐外部拦截，符合事件传递机制，实现起来也比较简单。</p>
<h4 id="方法一：外部拦截"><a href="#方法一：外部拦截" class="headerlink" title="方法一：外部拦截"></a>方法一：外部拦截</h4><p>外部拦截也就是事件会先经过父容器的拦截处理，如果需要则拦截消费，不需要就往下层传递，这种处理方式符合拦截机制。我们需要在外部的ViewGroup的进行拦截，在<code>onInterceptTouchEvent</code>方法进行判断。如果是条件符合则拦截，条件不符合则不拦截。</p>
<p>ViewGroup重写<code>onInterceptTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部ViewGroup重写onInterceptTouchEvent方法进行拦截</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;  <span class="comment">//必须返回false</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*符合拦截条件*/</span>)&#123;</span><br><span class="line">            	intercepted = <span class="keyword">true</span>; <span class="comment">//拦截滑动</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>; <span class="comment">//不拦截</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>; <span class="comment">//UP这里也需要返回false</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，首先down事件父容器必须返回false ，因为若是返回true，也就是拦截了down事件，那么后续的move和up事件就都会传递给父容器，子元素就没有机会处理事件了。其次是up事件也返回了false，一是因为up事件对父容器没什么意义，其次是因为若事件是子元素处理的，却没有收到up事件会让子元素的onClick等事件无法触发。</p>
<h4 id="方法二：内部拦截法"><a href="#方法二：内部拦截法" class="headerlink" title="方法二：内部拦截法"></a>方法二：内部拦截法</h4><p>内部拦截的是指父容器ViewGroup不拦截任何事件，将所有事件传递给子元素，如果子元素需要则消耗掉，如果不需要则通过<code>requestDisallowInterceptTouchEvent</code>方法交给父容器处理。外部拦截复杂一些。</p>
<p>View重写<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部View重写dispatchTouchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            <span class="comment">//DOWN事件不让父容器拦截</span></span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*符合拦截条件*/</span>)&#123;</span><br><span class="line">            	<span class="comment">//让父View拦截</span></span><br><span class="line">           		getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewGroup重写<code>onInterceptTouchevent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部ViewGroup重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">//父容器也不能拦截down事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父容器不拦截DOEN事件前面说过了，因为拦截后后续的MOVE和UP事件都会给父容器拦截掉。</p>
<h3 id="MotionEvent事件"><a href="#MotionEvent事件" class="headerlink" title="MotionEvent事件"></a>MotionEvent事件</h3><p>上面讲到的事件分发机制，分发的便是MotionEvent。这个MotionEvent我们分为单点触控和多点触控来看它的主要方法和事件类型。</p>
<h4 id="单点触控"><a href="#单点触控" class="headerlink" title="单点触控"></a>单点触控</h4><p>主要方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAction()</td>
<td align="center">获取事件类型</td>
</tr>
<tr>
<td align="center">getX()、getY()</td>
<td align="center">获取触点在当前View的坐标</td>
</tr>
<tr>
<td align="center">getRawX()、getRawY()</td>
<td align="center">获取触点在整个屏幕的坐标</td>
</tr>
</tbody></table>
<p>获取坐标的四个方法在坐标系中有说</p>
<p>主要事件：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">触发条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACTION_DOWN</td>
<td align="center">手指按下时触发</td>
</tr>
<tr>
<td align="center">ACTION_MOVE</td>
<td align="center">手指在屏幕上滑动触发，一直滑动会一直触发</td>
</tr>
<tr>
<td align="center">ACTION_UP</td>
<td align="center">手指离开屏幕时触发</td>
</tr>
<tr>
<td align="center">ACTION_CANCEL</td>
<td align="center">事件被上层拦截时触发</td>
</tr>
<tr>
<td align="center">ACTION_OUTSIDE</td>
<td align="center">手指不在控件区域是触发</td>
</tr>
</tbody></table>
<p>ACTION_CANCEL这个事件触发条件是<strong>上层ViewGroup回收了事件</strong>，就是正常来说应该ziView去处理的事件被ViewGroup拦截了。一般还在处理滑动冲突时出现，具体的例子上面滑动冲突的例子，滑动是ViewGroup，点击是View。当我们点下去的时候，子View会接收ACTION_DOWN，我们滑动的时候，父控件拦截了，子View会接收到ACTION_CANCEL，之后便不会接收任何事件。</p>
<p>ACTION_OUTSIDE的触发条件有点奇葩，点击View外面，具体例子是Dialog，点击Dialog外面也会消失就是使用这个事件。这个一般来说不会使用，使用时候还要对View的WindowManager布局参数的flags设置为<code>FLAG_WATCH_OUTSIDE_TOUCH</code>，这样View便可以接收到outside事件。</p>
<h4 id="多点触控"><a href="#多点触控" class="headerlink" title="多点触控"></a>多点触控</h4><p>主要事件类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">触发条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACTION_DOWN</td>
<td align="center">第一个手指按下时触发</td>
</tr>
<tr>
<td align="center">ACTION_MOVE</td>
<td align="center">手指在屏幕上滑动触发，一直滑动会一直触发</td>
</tr>
<tr>
<td align="center">ACTION_UP</td>
<td align="center">最后一个手指离开屏幕时触发</td>
</tr>
<tr>
<td align="center">ACTION_POINTER_DOWN</td>
<td align="center">非第一个手指按下时触发</td>
</tr>
<tr>
<td align="center">ACTION_POINTER_UP</td>
<td align="center">非最后一个手指离开屏幕时触发</td>
</tr>
</tbody></table>
<p>主要方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getActionMasked()</td>
<td align="center">与getAction()一样，用于获取多点触控事件类型</td>
</tr>
<tr>
<td align="center">getActionIndex()</td>
<td align="center">获取该事件由那个指针（手指）产生</td>
</tr>
<tr>
<td align="center">getPointerCount()</td>
<td align="center">获取屏幕上指针（手指）个数</td>
</tr>
<tr>
<td align="center">getPointerId(int pointerIndex)</td>
<td align="center">获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。</td>
</tr>
<tr>
<td align="center">findPointerIndex(int pointerId)</td>
<td align="center">通过PointerId获取到当前状态下PointIndex，之后通过PointIndex获取其他内容。</td>
</tr>
<tr>
<td align="center">getX(int pointerIndex)</td>
<td align="center">获取某一个指针(手指)的X坐标</td>
</tr>
<tr>
<td align="center">getY(int pointerIndex)</td>
<td align="center">获取某一个指针(手指)的Y坐标</td>
</tr>
</tbody></table>
<p><code>getActionMasked</code>和<code>getAction</code>一样，只不过&amp;了一个ACTION_MASK，ACTION_MASK是用来把多点触控的事件类型转化为ACTION_POINTER_DOWN和ACTION_POINTER_UP的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeGetAction(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getActionMasked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeGetAction(mNativePtr) &amp; ACTION_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有三个概念ActionIndex、PointerIndex和PointerId。ActionIndex和PointerIndex可以理解为一样的，他们数值也相等，不同的地方是在Move中无法获取actionIndex，但可以使用pointerIndex，进而使用<code>getX(int pointerIndex)</code>和<code>getY(int pointerIndex)</code>获取更多信息。</p>
<p>而index和pointerId的异同如下:</p>
<ul>
<li>相同点:从 0 开始，自动增长。</li>
<li>相同点:落下手指时优先填补空缺(填补之前抬起手指的编号)。</li>
<li>不同的:Index 会变化，pointId 始终不变。</li>
</ul>
<p>下面代码是获取第二个手指的坐标并记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于判断第2个手指是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> haveSecondPoint = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录第2个手指第位置</span></span><br><span class="line">PointF point = <span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = event.getActionIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">            <span class="comment">// 判断是否是第2个手指按下</span></span><br><span class="line">            <span class="keyword">if</span> (event.getPointerId(index) == <span class="number">1</span>)&#123;</span><br><span class="line">                haveSecondPoint = <span class="keyword">true</span>;</span><br><span class="line">                point.set(event.getY(), event.getX());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">            <span class="comment">// 判断抬起的手指是否是第2个</span></span><br><span class="line">            <span class="keyword">if</span> (event.getPointerId(index) == <span class="number">1</span>)&#123;</span><br><span class="line">                haveSecondPoint = <span class="keyword">false</span>;</span><br><span class="line">                point.set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (haveSecondPoint) &#123;</span><br><span class="line">                <span class="comment">// 通过 pointerId 来获取 pointerIndex</span></span><br><span class="line">                <span class="keyword">int</span> pointerIndex = event.findPointerIndex(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 通过 pointerIndex 来取出对应的坐标</span></span><br><span class="line">                point.set(event.getX(pointerIndex), event.getY(pointerIndex));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Java-BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Java-BlockingQueue/" class="post-title-link" itemprop="url">BlockingQueue</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-08-07 00:00:00 / 修改时间：14:26:54" itemprop="dateCreated datePublished" datetime="2019-08-07T00:00:00+08:00">2019-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>BlockingQueue（阻塞队列）是在Concurrent包下的一个处理并发的安全队列类，在多线程和线程池中有着非常广泛的使用。BlockingQueue的实现类都在内部使用ReentrantLock进行队列的安全性维护。</p>
<h3 id="BlockingQueue的主要方法"><a href="#BlockingQueue的主要方法" class="headerlink" title="BlockingQueue的主要方法"></a>BlockingQueue的主要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素设置到队列中，如果设置成功返回true, 否则返回false。如果是往限定了长度的队列中设置值，推荐使用offer()方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。超过长度抛出特殊值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在给定的时间里，从队列中获取值，时间到了直接调用普通的poll方法，为null则直接返回null。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列中是否拥有该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BlockingQueue主要实现类"><a href="#BlockingQueue主要实现类" class="headerlink" title="BlockingQueue主要实现类"></a>BlockingQueue主要实现类</h3><p>下图是BlockingQueue的实现类得继承关系：</p>
<p><img src="%5CJava-BlockingQueue%5CBlockingQueue%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="BlockingQueue继承图"></p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>是否有界</th>
<th>是否加锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>是</td>
<td>是</td>
<td>数组</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>可选</td>
<td>是</td>
<td>链表</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>有</td>
<td>是</td>
<td>无</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
</tbody></table>
<ul>
<li>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照FIFO的原则对元素进行排序。支持公平锁和非公平锁。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。</li>
<li>PriorityBlockingQueue： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li>
<li>DelayQueue： 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li>
<li>SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
<li>LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li>
<li>LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/java-ThreadPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/java-ThreadPool/" class="post-title-link" itemprop="url">Java 线程池</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-06T00:00:00+08:00">2019-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>93</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中，我们经常需要用到线程，但是大量的线程会占用内存资源可能导致OOM。这时候就需要到线程池来进行线程的调度。</p>
<h2 id="线程池总体结构"><a href="#线程池总体结构" class="headerlink" title="线程池总体结构"></a>线程池总体结构</h2><p><img src="/java-ThreadPool/线程池架构.png" alt="线程池架构"></p>
<p><strong>Executor</strong>: 所有线程池的接口,只有一个方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/java-problem1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/java-problem1/" class="post-title-link" itemprop="url">为什么final ReentrantLock lock = this.lock;</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-06T00:00:00+08:00">2019-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>284</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天在看BlockingQueue相关实现类的时候，发现了一个问题如下：</p>
<p><img src="/java-problem1/DelayQueue源码.jpg" alt="DelayQueue源码"></p>
<p>对于上图中的<code>final ReentrantLock lock = this.lock</code>这种写法，百度之后原作者是说“归根究底是由于内存模型与OOP之间的原则不一致”。</p>
<p>在内存模型上看，当方法中访问类变量会比访问方法中的变量多一步，也就是会先有访问<code>this</code>。如果直接使用，就会变成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.lock.lock();</span><br><span class="line"><span class="keyword">this</span>.lock.unlock();</span><br></pre></td></tr></table></figure>

<p>会比直接访问方法内变量多出一步，事实上反编译出来的结果也是一样，会多出一步：</p>
<p><img src="%5Cjava-problem1%5C%E5%8F%8D%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.jpg" alt="反编译结果"></p>
<p>但是在目前JDK版本已经对这种情况优化了，这种编写方式已是一种习惯编写。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-OpenThird/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-OpenThird/" class="post-title-link" itemprop="url">分享功能</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-30T00:00:00+08:00">2019-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android中的原生分享"><a href="#Android中的原生分享" class="headerlink" title="Android中的原生分享"></a>Android中的原生分享</h2><p>下面是Android原生的分享功能，也就是第三方应用跳转，只不过是在intent中添加Intent.ACtion_SEND来区分这是一个分享：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Intent，设置action为ACtion_SEND</span></span><br><span class="line">Intent textIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line"><span class="comment">//这里设置分享内容类型</span></span><br><span class="line">textIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">//将分享内容放入Extra中</span></span><br><span class="line">textIntent.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是一段分享的文字"</span>);</span><br><span class="line"><span class="comment">//startActivity,这里使用了createChooser让用户选择用哪个应用启动</span></span><br><span class="line"><span class="comment">//还可以直接使用startActivity(intent)，这样可以指定哪个应用启动(第一次需要选择)</span></span><br><span class="line">startActivity(Intent.createChooser(textIntent, <span class="string">"title"</span>));</span><br></pre></td></tr></table></figure>



<h2 id="指定应用分享"><a href="#指定应用分享" class="headerlink" title="指定应用分享"></a>指定应用分享</h2><p>我们跳转第三方应用时，可以设置package来进行指定应用打开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent wechatIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line"><span class="comment">//指定应用</span></span><br><span class="line">wechatIntent.setPackage(<span class="string">"com.tencent.mm"</span>);</span><br><span class="line"><span class="comment">//图片格式</span></span><br><span class="line">wechatIntent.setType(<span class="string">"image/jpeg"</span>);</span><br><span class="line">wechatIntent.putExtra(Intent.EXTRA_STREAM, url);</span><br><span class="line">startActivity(Intent.createChooser(wechatIntent, <span class="string">"title"</span>));</span><br></pre></td></tr></table></figure>

<p>指定应用之后，分享会调到指定的应用，但是具体哪个页面没确定，比如微信会有分享给朋友、分享到朋友圈、分享到收藏等。</p>
<p>我们跳转第三方应用时，可以设置ComponentName来进行指定应用的指定界面打开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String package_name = <span class="string">"xx.xx.xx"</span>;</span><br><span class="line">String activity_path = <span class="string">"xx.xx.xx.ab.xxActivity"</span>;</span><br><span class="line"></span><br><span class="line">Intent intent2 = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent2.putExtra(Intent.EXTRA_TEXT, <span class="string">"hello"</span>);</span><br><span class="line">intent2.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">//----下面两步是设置intent的compnentname，指定应用指定界面</span></span><br><span class="line">ComponentName componentName = <span class="keyword">new</span> ComponentName(package_name,activity_path) ;</span><br><span class="line">intent2.setComponent(componentName);</span><br><span class="line"><span class="comment">//----</span></span><br><span class="line">startActivity(intent2);</span><br></pre></td></tr></table></figure>

<p>使用这种方法需要知道APP的包名和Activity全路径和名称。</p>
<p>下面的方法是使用pm进行分享应用的筛选：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String wechatShareName = <span class="string">"com.tencent.mm.ui.tools.ShareImgUI"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String qqShareName = <span class="string">"com.tencent.mobileqq.activity.JumpActivity"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String rcsShareName = <span class="string">"com.cmic.module_main.ui.activity.WelcomeActivity"</span>;</span><br><span class="line"><span class="comment">//---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PackageManager packageManager = context.getPackageManager();</span><br><span class="line"><span class="comment">//创建指定intent</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">//筛选出指定的Activity集合</span></span><br><span class="line">List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line"><span class="comment">//便利集合</span></span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : resolveInfos) &#123;</span><br><span class="line">    String shareName = resolveInfo.activityInfo.name;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.equals(shareName,wechatShareName)) &#123;</span><br><span class="line">        Intent intent2 = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">        intent2.putExtra(Intent.EXTRA_TEXT, <span class="string">"content"</span>);</span><br><span class="line">        intent2.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(resolveInfo.activityInfo.packageName,</span><br><span class="line">                                              resolveInfo.activityInfo.name));</span><br><span class="line">        context.startActivity(intent2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分享不同格式"><a href="#分享不同格式" class="headerlink" title="分享不同格式"></a>分享不同格式</h2><p>文件分享时一般都要设置好文件类型，默认指定类型为<code>*/*</code>，已默认类型进行分享时有些App不支持这种类型，会导致分享失败，最好的方式是预先根据文件路径设置好文件类型。</p>
<p>常见的文件mimeType格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;.3gp&quot;, &quot;video&#x2F;3gpp&quot;&#125;,  </span><br><span class="line">&#123;&quot;.apk&quot;, &quot;application&#x2F;vnd.android.package-archive&quot;&#125;,  </span><br><span class="line">&#123;&quot;.asf&quot;, &quot;video&#x2F;x-ms-asf&quot;&#125;,  </span><br><span class="line">&#123;&quot;.avi&quot;, &quot;video&#x2F;x-msvideo&quot;&#125;,  </span><br><span class="line">&#123;&quot;.bin&quot;, &quot;application&#x2F;octet-stream&quot;&#125;,  </span><br><span class="line">&#123;&quot;.bmp&quot;, &quot;image&#x2F;bmp&quot;&#125;,  </span><br><span class="line">&#123;&quot;.c&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.class&quot;, &quot;application&#x2F;octet-stream&quot;&#125;,  </span><br><span class="line">&#123;&quot;.conf&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.cpp&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.doc&quot;, &quot;application&#x2F;msword&quot;&#125;,  </span><br><span class="line">&#123;&quot;.exe&quot;, &quot;application&#x2F;octet-stream&quot;&#125;,  </span><br><span class="line">&#123;&quot;.gif&quot;, &quot;image&#x2F;gif&quot;&#125;,  </span><br><span class="line">&#123;&quot;.gtar&quot;, &quot;application&#x2F;x-gtar&quot;&#125;,  </span><br><span class="line">&#123;&quot;.gz&quot;, &quot;application&#x2F;x-gzip&quot;&#125;,  </span><br><span class="line">&#123;&quot;.h&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.htm&quot;, &quot;text&#x2F;html&quot;&#125;,  </span><br><span class="line">&#123;&quot;.html&quot;, &quot;text&#x2F;html&quot;&#125;,  </span><br><span class="line">&#123;&quot;.jar&quot;, &quot;application&#x2F;java-archive&quot;&#125;,  </span><br><span class="line">&#123;&quot;.java&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.jpeg&quot;, &quot;image&#x2F;jpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.jpg&quot;, &quot;image&#x2F;jpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.js&quot;, &quot;application&#x2F;x-javascript&quot;&#125;,  </span><br><span class="line">&#123;&quot;.log&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m3u&quot;, &quot;audio&#x2F;x-mpegurl&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4a&quot;, &quot;audio&#x2F;mp4a-latm&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4b&quot;, &quot;audio&#x2F;mp4a-latm&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4p&quot;, &quot;audio&#x2F;mp4a-latm&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4u&quot;, &quot;video&#x2F;vnd.mpegurl&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4v&quot;, &quot;video&#x2F;x-m4v&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mov&quot;, &quot;video&#x2F;quicktime&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mp2&quot;, &quot;audio&#x2F;x-mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mp3&quot;, &quot;audio&#x2F;x-mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mp4&quot;, &quot;video&#x2F;mp4&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpc&quot;, &quot;application&#x2F;vnd.mpohun.certificate&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpe&quot;, &quot;video&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpeg&quot;, &quot;video&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpg&quot;, &quot;video&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpg4&quot;, &quot;video&#x2F;mp4&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpga&quot;, &quot;audio&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.msg&quot;, &quot;application&#x2F;vnd.ms-outlook&quot;&#125;,  </span><br><span class="line">&#123;&quot;.ogg&quot;, &quot;audio&#x2F;ogg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.pdf&quot;, &quot;application&#x2F;pdf&quot;&#125;,  </span><br><span class="line">&#123;&quot;.png&quot;, &quot;image&#x2F;png&quot;&#125;,  </span><br><span class="line">&#123;&quot;.pps&quot;, &quot;application&#x2F;vnd.ms-powerpoint&quot;&#125;,  </span><br><span class="line">&#123;&quot;.ppt&quot;, &quot;application&#x2F;vnd.ms-powerpoint&quot;&#125;,  </span><br><span class="line">&#123;&quot;.prop&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rar&quot;, &quot;application&#x2F;x-rar-compressed&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rc&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rmvb&quot;, &quot;audio&#x2F;x-pn-realaudio&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rtf&quot;, &quot;application&#x2F;rtf&quot;&#125;,  </span><br><span class="line">&#123;&quot;.sh&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.tar&quot;, &quot;application&#x2F;x-tar&quot;&#125;,  </span><br><span class="line">&#123;&quot;.tgz&quot;, &quot;application&#x2F;x-compressed&quot;&#125;,  </span><br><span class="line">&#123;&quot;.txt&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wav&quot;, &quot;audio&#x2F;x-wav&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wma&quot;, &quot;audio&#x2F;x-ms-wma&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wmv&quot;, &quot;audio&#x2F;x-ms-wmv&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wps&quot;, &quot;application&#x2F;vnd.ms-works&quot;&#125;,  </span><br><span class="line">&#123;&quot;.xml&quot;, &quot;text&#x2F;xml&quot;&#125;,  </span><br><span class="line">&#123;&quot;.xml&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.z&quot;, &quot;application&#x2F;x-compress&quot;&#125;,  </span><br><span class="line">&#123;&quot;.zip&quot;, &quot;application&#x2F;zip&quot;&#125;,  </span><br><span class="line">&#123;&quot;&quot;, &quot;*&#x2F;*&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>intent中对于图片和视频类型的文件我们可以设置type为流式stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.putExtra(Intent.EXTRA_STREAM, content);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-Foreground_rocess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-Foreground_rocess/" class="post-title-link" itemprop="url">判断应用是否是前台进程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-17 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-17T00:00:00+08:00">2019-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="六种方法的区别"><a href="#六种方法的区别" class="headerlink" title="六种方法的区别"></a>六种方法的区别</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">判断原理</th>
<th>需要权限</th>
<th>可以判断其他应用位于前台</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">方法一</td>
<td align="center">RunningTask</td>
<td>否</td>
<td>Android4.0系列可以,5.0以上机器不行</td>
<td>5.0此方法被废弃</td>
</tr>
<tr>
<td align="center">方法二</td>
<td align="center">RunningProcess</td>
<td>否</td>
<td>当App存在后台常驻的Service时失效</td>
<td>无</td>
</tr>
<tr>
<td align="center">方法三</td>
<td align="center">ActivityLifecycleCallbacks</td>
<td>否</td>
<td>否</td>
<td>简单有效,代码最少</td>
</tr>
<tr>
<td align="center">方法四</td>
<td align="center">UsageStatsManager</td>
<td>是</td>
<td>是</td>
<td>需要用户手动授权</td>
</tr>
<tr>
<td align="center">方法五</td>
<td align="center">通过Android无障碍功能实现</td>
<td>否</td>
<td>是</td>
<td>需要用户手动授权</td>
</tr>
<tr>
<td align="center">方法六</td>
<td align="center">读取/proc目录下的信息</td>
<td>否</td>
<td>是</td>
<td>当proc目录下文件夹过多时,过多的IO操作会引起耗时</td>
</tr>
</tbody></table>
<h2 id="一、RunningTask"><a href="#一、RunningTask" class="headerlink" title="一、RunningTask"></a>一、RunningTask</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>此方法在Android4.x上可以执行，当一个APP处于前台时，会处于RunningTask这个栈顶。我们可以取出RunningTask的栈顶进程，然后判断包名是否是要判断的APP的包名。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这种方法不仅能获取到前台进程的包名还能获取到activity名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getForegroundActivity</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ActivityManager mActivityManager =  </span><br><span class="line">        (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);  </span><br><span class="line">    <span class="keyword">if</span> (mActivityManager.getRunningTasks(<span class="number">1</span>) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        Log.e(TAG, <span class="string">"running task is null, ams is abnormal!!!"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ActivityManager.RunningTaskInfo mRunningTask =  </span><br><span class="line">        mActivityManager.getRunningTasks(<span class="number">1</span>).get(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (mRunningTask == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        Log.e(TAG, <span class="string">"failed to get RunningTaskInfo"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    String pkgName = mRunningTask.topActivity.getPackageName();  </span><br><span class="line">    <span class="comment">//String activityName =  mRunningTask.topActivity.getClassName();  </span></span><br><span class="line">    <span class="keyword">return</span> pkgName;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>getRunningTask方法在5.0以上已经被废弃，只会返回自己和系统的一些不敏感的task，不再返回其他应用的task。此方法不能判断其他应用是否在前台。</p>
<h2 id="一、RunningProcess"><a href="#一、RunningProcess" class="headerlink" title="一、RunningProcess"></a>一、RunningProcess</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过runningProcess获取到一个当前正在运行的进程的List，我们遍历这个List中的每一个进程，判断这个进程的一个importance 属性是否是前台进程，并且包名是否与我们判断的APP的包名一样，如果这两个条件都符合，那么这个App就处于前台。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>  以下是判断当前应用是否在前台：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAppForeground</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ActivityManager activityManager =     </span><br><span class="line">        (ActivityManager)context.getSystemService(Service.ACTIVITY_SERVICE);</span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcessInfoList =           		    	     </span><br><span class="line">        activityManager.getRunningAppProcesses();</span><br><span class="line">    <span class="keyword">if</span> (runningAppProcessInfoList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"runningAppProcessInfoList is null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ActivityManager.RunningAppProcessInfo processInfo : runningAppProcessInfoList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processInfo.processName.equals(context.getPackageName())</span><br><span class="line">            &amp;&amp;(processInfo.importance == </span><br><span class="line">               ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND)) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是判断在前台的是哪个应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getForegroundApp</span><span class="params">(Context context)</span> </span>&#123;  </span><br><span class="line">    ActivityManager am =  </span><br><span class="line">        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);  </span><br><span class="line">    List&lt;RunningAppProcesInfo&gt; lr = am.getRunningAppProcesses();  </span><br><span class="line">    <span class="keyword">if</span> (lr == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RunningAppProcessInfo ra : lr) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ra.importance == RunningAppProcessInfo.IMPORTANCE_VISIBLE  </span><br><span class="line">            || ra.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123;  </span><br><span class="line">            <span class="keyword">return</span> ra.processName;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getRunningAppProcess方法只能获取前台包名。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>Android5.0之后已经被废弃。</p>
<p>例如，在聊天类型的App中，常常需要常驻后台来不间断地获取服务器的消息，就需要把Service设置成START_STICKY，kill后会被重启（等待5s左右）来保证Service常驻后台。如果Service设置了这个属性，这个App的进程就会被判断为前台。代码表现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND</span><br></pre></td></tr></table></figure>

<p>上述code永远成立，这样就永远无法判断到底那个是前台了。</p>
<h2 id="三、ActivityLifecycleCallbacks"><a href="#三、ActivityLifecycleCallbacks" class="headerlink" title="三、ActivityLifecycleCallbacks"></a>三、ActivityLifecycleCallbacks</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>AndroidSDK14在Application类里增加了ActivityLifecycleCallbacks，我们可以通过这个Callback拿到App所有Activity的生命周期回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道这些信息，我们就可以用更官方的办法来解决问题，只需要在Application的onCreate()里去注册上述接口，然后由Activity回调回来运行状态即可。</p>
<p>Android应用开发中一般认为back键是可以捕获的，而Home键是不能捕获的（除非修改framework）,但是上述方法从Activity生命周期着手解决问题，虽然这两种方式的Activity生命周期并不相同，但是二者都会执行onStop（）；所以并不关心到底是触发了哪个键切入后台的。另外,Application是否被销毁,都不会影响判断的正确性<strong>。</strong></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>（1）AndroidManifest.xml</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"mytest.example.com.broadcaststudy"</span>&gt;</span><br><span class="line">    &lt;application</span><br><span class="line">        android:name=<span class="string">".TestActivityLifecycleApplcation"</span></span><br><span class="line">            android:allowBackup=<span class="string">"true"</span></span><br><span class="line">                android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">                    android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">                        android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">                            android:theme=<span class="string">"@style/AppTheme"</span>&gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".SendBroadcastActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">                        &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".SecondActivity"</span>&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-Garble/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-Garble/" class="post-title-link" itemprop="url">Android混淆</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-11T00:00:00+08:00">2019-03-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>混淆，能过让我们的的APK更加的安全。没有混淆的APK，经过反编译，很容易就拿到源代码的资源文件，如直接使用Android Studio中的apk分析工具便可看到。因此我们需要读我们的APK进行混淆，混淆又分为两种：1.代码混淆；2.资源混淆。<a href="https://developer.android.com/studio/build/shrink-code?hl=zh-cn" target="_blank" rel="noopener">Android官网</a>也有简略的对其说明</p>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><h3 id="混淆原理"><a href="#混淆原理" class="headerlink" title="混淆原理"></a>混淆原理</h3><p>Java 是一种跨平台、解释型语言，Java 源代码编译成的class文件中有大量包含语义的变量名、方法名的信息，很容易被反编译为Java 源代码。为了防止这种现象，我们可以对Java字节码进行混淆。混淆不仅能将代码中的类名、字段、方法名变为无意义的名称，保护代码，也由于移除无用的类、方法，并使用简短名称对类、字段、方法进行重命名缩小了程序的size。</p>
<h3 id="混淆工具"><a href="#混淆工具" class="headerlink" title="混淆工具"></a>混淆工具</h3><p><a href="https://www.guardsquare.com/en/products/proguard" target="_blank" rel="noopener">ProGuard</a>是一个代码优化工具，它能够很好的堆对代码进行优化，并且能够它已近集成在Android构建环境中，我们进行配置非常方便。它对代码的优化由shrink、optimize、obfuscate和preverify四个步骤组成，每个步骤都是可选的，需要哪些步骤都可以在脚本中配置。 </p>
<ul>
<li><strong>压缩(Shrink)</strong>: 侦测并移除代码中无用的类、字段、方法、和特性(Attribute)。</li>
<li><strong>优化(Optimize)</strong>: 分析和优化字节码。</li>
<li><strong>混淆(Obfuscate)</strong>: 使用a、b、c、d这样简短而无意义的名称，对类、字段和方法进行重命名。</li>
</ul>
<p>上面三个步骤使代码size更小，更高效，也更难被逆向工程。</p>
<ul>
<li><strong>预检(Preveirfy)</strong>:  在java平台上对处理后的代码进行预检。</li>
</ul>
<p>混淆流程如下：</p>
<p><img src="/Android-Garble/proguard流程.png" alt="proguard流程"></p>
<p>Proguard读入input jars(or wars,zips or directories)，经过四个步骤生成处理之后的jars(or wars,ears,zips or directories),Optimization步骤可选择多次进行。</p>
<p>为了确定哪些代码应该被保留，哪些代码应该被移除或混淆，Proguard需要确定一个或多个<strong>Entry Point</strong>（类似标记）。Entry Point经常是带有main methods,applets,midlets的classes,它们在混淆过程中会被保留。我们来看一下Proguard的几个步骤如何处理Entry Points：</p>
<ol>
<li>在压缩阶段，Proguard从上述Entry Points开始遍历搜索哪些类和类成员被使用。其他没有被使用的类和类成员会移除。</li>
<li>在优化阶段，Proguard进一步设置非Entry Point的类和方法为private、static和final来进行优化，不使用的参数会被移除，某些方法会被标记被内联。</li>
<li>在混淆阶段，Proguard重命名非Entry Points的类和类成员。</li>
<li>预检阶段是唯一没有触及Entry Points的阶段。</li>
</ol>
<h3 id="开启混淆"><a href="#开启混淆" class="headerlink" title="开启混淆"></a>开启混淆</h3><p>在<code>build.gradle</code>中配置如下便可开启混淆：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="literal">true</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>minifyEnabled</code>表示混淆是否开启，<code>proguardFiles</code>表示混淆规则文件,它默认从 AndroidSDK—tools/proguard/ 文件夹获<code>proguard-android.txt</code>这个文件的规则进行混淆，后面的<code>proguard-rules.pro</code>使我们自己的规则配置文件，在<code>build.guild</code>文件旁。</p>
<h3 id="构建输出"><a href="#构建输出" class="headerlink" title="构建输出"></a>构建输出</h3><p>混淆打包后会在 <code>/build/outputs/mapping/release/</code> 目录下会输出以下文件：</p>
<ul>
<li><code>dump.txt</code><br>描述APK文件中所有类的内部结构</li>
<li><code>mapping.txt</code><br>提供混淆前后类、方法、类成员等的对照表</li>
<li><code>seeds.txt</code><br>列出没有被混淆的类和成员</li>
<li><code>usage.txt</code><br>列出被移除的代码</li>
</ul>
<p>这些文件要保存备份好，以后Bug调试、堆栈跟踪或者解码的时候就会使用到。</p>
<h3 id="Proguard关键字"><a href="#Proguard关键字" class="headerlink" title="Proguard关键字"></a>Proguard关键字</h3><p>保留选项：</p>
<ul>
<li>-keep {Modifier} {class_specification} 保留类和类中的成员，防止它们被混淆或移除。</li>
<li>-keepclassmembers {modifier} {class_specification} 保护指定类的成员，如果此类受到保护他们会保护的更好。</li>
<li>-keepclasseswithmembers {class_specification} 保留类和类中的成员，防止它们被混淆或移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。</li>
<li>-keepnames {class_specification} 保留类和类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。</li>
<li>-keepclassmembernames {class_specification} 只保留类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。</li>
<li>-keepclasseswithmembernames {class_specification} 保留类和类中的成员，防止它们被混淆，但当成员没有被引用时会被移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。</li>
</ul>
<p>压缩：</p>
<ul>
<li>-dontshrink 不压缩输入的类文件</li>
<li>-whyareyoukeeping {class_specification}</li>
</ul>
<p>优化：</p>
<ul>
<li>-dontoptimize 不优化输入的类文件</li>
<li>-assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用</li>
<li>-allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员</li>
</ul>
<p>混淆：</p>
<ul>
<li>-dontobfuscate 不混淆输入的类文件</li>
<li>-obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称</li>
<li>-overloadaggressively 混淆时应用侵入式重载</li>
<li>-useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆</li>
<li>-flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中</li>
<li>-repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中</li>
<li>-dontusemixedcaseclassnames 混淆时不会产生形形色色的类名</li>
<li>-keepattributes {attribute_name,…} 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses.</li>
<li>-renamesourcefileattribute {string} 设置源文件中给定的字符串常量</li>
</ul>
<p>输出：</p>
<ul>
<li>-printseeds {filename} 列出类和类的成员-keep选项的清单，标准输出到给定的文件</li>
<li>-printusage {filename}</li>
</ul>
<p>通配符：</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;field&gt;</code></td>
<td>匹配类中的所有字段</td>
</tr>
<tr>
<td><code>&lt;method&gt;</code></td>
<td>匹配类中的所有方法</td>
</tr>
<tr>
<td><code>&lt;init&gt;</code></td>
<td>匹配类中的所有构造函数</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意长度字符，但不含包名分隔符(.)。比如说我们的完整类名是com.example.test.MyActivity，使用com.<em>，或者com.exmaple.<em>都是无法匹配的，因为</em>无法匹配包名中的分隔符，正确的匹配方式是com.exmaple.</em>.<em>，或者com.exmaple.test.</em>，这些都是可以的。但如果你不写任何其它内容，只有一个*，那就表示匹配所有的东西。</td>
</tr>
<tr>
<td>**</td>
<td>匹配任意长度字符，并且包含包名分隔符(.)。比如proguard-android.txt中使用的-dontwarn android.support.**就可以匹配android.support包下的所有内容，包括任意长度的子包。</td>
</tr>
<tr>
<td>***</td>
<td>匹配任意参数类型。比如void set<em>(<strong><em>)就能匹配任意传入的参数类型，</em></strong> get</em>()就能匹配任意返回值的类型。</td>
</tr>
<tr>
<td>…</td>
<td>匹配任意长度的任意类型参数。比如void test(…)就能匹配任意void test(String a)或者是void test(int a, String b)这些方法。</td>
</tr>
</tbody></table>
<blockquote>
<p>在android中在android Manifest文件中的activity，service，provider， receviter，等都不能进行混淆。一些在xml中配置的view也不能进行混淆，android提供的默认配置中都有。</p>
</blockquote>
<blockquote>
<p>keep和keepclasseswithmembers区别在于：keep关键字看到class *就认为应该将所有类名进行保留，不关心{}中的参数。而keepclasseswithmembers前提是{}的类中的成员必须存在，如果不存在则还是会混淆</p>
</blockquote>
<h3 id="不能混淆的东西"><a href="#不能混淆的东西" class="headerlink" title="不能混淆的东西"></a>不能混淆的东西</h3><ol>
<li>Android 程序 ，下面这样代码混淆的时候要注意保留。</li>
<li>Android系统组件，系统组件有固定的方法被系统调用。</li>
<li>被Android Resource 文件引用到的。名字已经固定，也不能混淆，比如自定义的View 。</li>
<li>Android Parcelable ，需要使用android 序列化的。</li>
<li>android.app.backup.BackupAgentHelper</li>
<li>android.preference.Preference</li>
<li>com.android.vending.licensing.ILicensingService</li>
<li>Java序列化方法，系统序列化需要固定的方法。</li>
<li>枚举 ，系统需要处理枚举的固定方法。</li>
<li>native 本地方法，不能修改本地方法名</li>
<li>annotations 注释</li>
<li>数据库驱动</li>
<li>有些resource 文件</li>
<li>用到反射的地方，比如调用aidl</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>一、打包过程中，提示 Warning: can’t find superclass or interface/ Warning: can’t find referenced class等警告信息！<br> 解决方法：</p>
<ol>
<li>确保你的代码是否使用这个类，如果使用了，查看对应的第三方包有没有加上去，并且是否拉下来存在项目中</li>
<li>如果该类存在，工程中确实使用了这个类，就在proguard中加上<code>-keep class com.xx.yy.** { *;}</code>，让当前类不混淆。</li>
<li>确保报错的类没有在你的项目中使用到,可以使用”-dontwarn 类名正则表达式”屏蔽警告。</li>
</ol>
<p> 二、程序中使用泛型导致运行错误！<br> 使用的泛型需要在混淆配置文件加了一个过滤泛型的语句，如下。<br> -keepattributes Signature</p>
<h2 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Internet-IMAP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Internet-IMAP/" class="post-title-link" itemprop="url">IMAP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-11T00:00:00+08:00">2019-03-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IMAP（Internet Mail Access Protocol）网络邮件访问协议是一个应用层协议，用于从本地客户端访问远程服务器上的邮件。现在的版本是4rev1（IMAP4rve1）。IMAP协议运行在TCP/IP协议之上，SSL使用的端口是<strong>993</strong>，非SSL使用的端口号是<strong>143</strong>。IMAP的权威定义是RFC3501，具体协议内容可以查阅此<a href="http://www.faqs.org/rfcs/rfc3501.html" target="_blank" rel="noopener">http://www.faqs.org/rfcs/rfc3501.html</a>，中文版的在<a href="http://blog.csdn.net/qqnnhhbb/article/details/6428681" target="_blank" rel="noopener">http://blog.csdn.net/qqnnhhbb/article/details/642868</a>。</p>
<h2 id="和POP3的区别"><a href="#和POP3的区别" class="headerlink" title="和POP3的区别"></a>和POP3的区别</h2><p>传统的POP3协议是将服务器上的文件下载到本地，然后对本地的邮件进行操作，操作是不会反馈到服务器上的。而IMAP提供服务端和客户端之间的双向通信，客户端和服务端的每个操作都会同步。同时，IMAP也提供邮件下载的服务，并且能够访问邮件的每一个MIME部分（几乎所有邮件都是以MIME格式传输），让我们能够根据时间、主题、发件人等信息确定是否下载邮件。此外，IMAP支持多设备随时访问邮件。</p>
<h2 id="IMAP连接"><a href="#IMAP连接" class="headerlink" title="IMAP连接"></a>IMAP连接</h2><p>一次基本的IMAP连接有以下基本完成：</p>
<ol>
<li>建立服务端和客户端的链接</li>
<li>服务器初始欢迎</li>
<li>服务器和客户端进行交互，交互形式为：<ol>
<li>客户端发送命令</li>
<li>服务器返回请求数据</li>
<li>服务器返回完成响应</li>
</ol>
</li>
</ol>
<p>客户端命令引发操作。每个客户端命令以一个标识作为前缀（典型的有字母、数字构成的短字符串，如：A001，A002，等等）――它称为“标签”。客户端为每个命令生成不同的“标签”，也称每个客户端命令都是标签化的。</p>
<p>IMAP服务器端的协议接收端，从客户端读取命令行，解析该命令行及其参数，并传送服务器数据（非标签化，以*或+开头）及一个服务器命令（标签化，有与客户端请求命令相同的前缀）完成结果的响应。</p>
<h2 id="协议状态"><a href="#协议状态" class="headerlink" title="协议状态"></a>协议状态</h2><p>一旦客户端和服务器间的连接建立完成，一个IMAP4rev1连接就会处于4种状态中的某一种：</p>
<ol>
<li>未认证状态 ：在未认证状态下，大多数命令在得到许可前，客户端必须提供认证证书。若非连接已经是预认证了的，一个连接开始时，就进入了未认证状态。 </li>
<li>认证状态 ：在认证状态下，客户端是认证了的，它必须先于影响邮件的命令被许可前，选择一个邮箱以访问。当一个预认证连接开始，被认可的认证证书已经提供，选择一个邮箱发生错误后，或者一个成功的CLOSE命令后，就进入了认证状态。</li>
<li>选中状态 ：在一个选中状态，一个邮箱被选中以访问。当一个邮箱被成功选中时，就进入了这个状态。</li>
<li>注销状态 ：在注销状态下，连接正在被终止。一个客户端请求（通过LOGOUT命令），或者客户端、服务器的单方面动作，都会导致进入这个状态。</li>
</ol>
<p>之所以提及到状态，是因为IMAP协议的很多指令只有在处于某种状态下才会有效。下面是一些基本指令的作用的权限：</p>
<ol>
<li>在任何状态下都有效的指令（全局命令）：CAPALIBILY，NOOP，LOGOUT。</li>
<li>未认证状态下有效的指令（未认证状态命令）：STARTTLS,AUTHENTICATE，LOGIN和全局命令。</li>
<li>认证状态下有效的指令（认证状态命令）：SELECT，EXAMINE，CREATE，DELETE，RENAME，SUBSCRIBE，UNSUBSCRIBE，LIST，LSUB，STATUS，APPEND和全局命令</li>
<li>在选中状态下有效的指令（选中状态指令）：CHECK，CLOSE，EXPUNGE，SEARCH，FETCH，STORE，COPY，UID和全局命令、认证状态命令</li>
</ol>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="create-folder"><a href="#create-folder" class="headerlink" title="create {folder}"></a>create {folder}</h3><p>CREATE可以创建指定名字的新邮箱。邮箱名称通常是带路径的文件夹全名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A003 CREATE owatagusiam/                 </span><br><span class="line">S: A003 OK CREATE completed</span><br><span class="line">C: A004 CREATE owatagusiam/blurdybloop  </span><br><span class="line">S: A004 OK CREATE completed</span><br></pre></td></tr></table></figure>

<h3 id="DELETE-folder"><a href="#DELETE-folder" class="headerlink" title="DELETE {folder}"></a>DELETE {folder}</h3><p>DELETE命令删除指定名字的文件夹。文件夹名字通常是带路径的文件夹全名，当邮箱被删除后，其中的邮件也不复存在。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A683 DELETE blurdybloop</span><br><span class="line">S: A683 OK DELETE completed</span><br><span class="line">C: A684 DELETE foo</span><br><span class="line">S: A684 NO Name <span class="string">"foo"</span> has inferior hierarchical names</span><br><span class="line">C: A685 DELETE foo/bar</span><br><span class="line">S: A685 OK DELETE Completed</span><br></pre></td></tr></table></figure>

<h3 id="RENAME-old-folder-new-folder"><a href="#RENAME-old-folder-new-folder" class="headerlink" title="RENAME {old folder}{new folder}"></a>RENAME {old folder}{new folder}</h3><p>RENAME命令可以修改文件夹的名称，它使用两个参数：当前邮箱名和新邮箱名，两个参数的命名符合标准路径命名规则。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A683 RENAME blurdybloop sarasoop</span><br><span class="line">S: A683 OK RENAME completed</span><br><span class="line">C: A684 RENAME stuff/junk newbox        </span><br><span class="line">S: A684 OK RENAME Completed</span><br></pre></td></tr></table></figure>

<h3 id="LIST-BASE-template"><a href="#LIST-BASE-template" class="headerlink" title="LIST {BASE}{template}"></a>LIST {BASE}{template}</h3><p>LIST命令用于列出邮箱中已有的文件夹，有点像操作系统的列目录命令，有两个参数，邮箱路径参数BASE：表示用户登陆目录；第二个参数template：表示希望显示的邮箱名。这个命令可以包含起始的路径位置和需要列出的文件夹所符合的特征，可以使用通配符”*”。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A101 LIST <span class="string">""</span> <span class="string">""</span></span><br><span class="line">S: * LIST (\Noselect) <span class="string">"/"</span> <span class="string">""</span></span><br><span class="line">S: A101 OK LIST Completed</span><br><span class="line">C: A102 LIST <span class="comment">#news.comp.mail.misc ""</span></span><br><span class="line">S: * LIST (\Noselect) <span class="string">"."</span> <span class="comment">#news.</span></span><br><span class="line">S: A102 OK LIST Completed</span><br><span class="line">C: A103 LIST /usr/staff/jones <span class="string">""</span></span><br><span class="line">S: * LIST (\Noselect) <span class="string">"/"</span> /</span><br><span class="line">S: A103 OK LIST Completed</span><br><span class="line">C: A202 LIST ~/Mail/ %</span><br><span class="line">S: * LIST (\Noselect) <span class="string">"/"</span> ~/Mail/foo</span><br><span class="line">S: * LIST () <span class="string">"/"</span> ~/Mail/meetings</span><br><span class="line">S: A202 OK LIST completed</span><br></pre></td></tr></table></figure>

<h3 id="APPEND-folder-attributes-date-time-size-mail-data"><a href="#APPEND-folder-attributes-date-time-size-mail-data" class="headerlink" title="APPEND {folder}{attributes}{date/time}{size}{mail data}"></a>APPEND {folder}{attributes}{date/time}{size}{mail data}</h3><p>APPEND命令允许Client上载一个邮件到指定的Folder（文件夹/邮箱）中。命令中包含了新邮件的属性、日期/时间、大小，随后是邮件数据。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A003 APPEND saved<span class="literal">-messages</span> (\Seen) &#123;<span class="number">310</span>&#125;</span><br><span class="line">C: Date: Mon， <span class="number">7</span> Feb <span class="number">1994</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">25</span> <span class="literal">-0800</span> (PST)</span><br><span class="line">C: From: Fred Foobar &lt;foobar@Blurdybloop.COM&gt;</span><br><span class="line">C: Subject: afternoon meeting</span><br><span class="line">C: To: mooch@owatagu.siam.edu</span><br><span class="line">C: Message<span class="literal">-Id</span>: &lt;B27397<span class="literal">-0100000</span>@Blurdybloop.COM&gt;</span><br><span class="line">C: MIME<span class="literal">-Version</span>: <span class="number">1.0</span></span><br><span class="line">C: Content<span class="literal">-Type</span>: TEXT/PLAIN; CHARSET=US<span class="literal">-ASCII</span></span><br><span class="line">C:</span><br><span class="line">C: Hello Joe， <span class="keyword">do</span> you think we can meet at <span class="number">3</span>:<span class="number">30</span> tomorrow?</span><br><span class="line">C:</span><br><span class="line">S: A003 OK APPEND completed</span><br></pre></td></tr></table></figure>

<h3 id="SELECT-folder"><a href="#SELECT-folder" class="headerlink" title="SELECT {folder}"></a>SELECT {folder}</h3><p>SELECT命令让Client选定某个邮箱（Folder），表示即将对该邮箱（Folder）内的邮件作操作。邮箱标志的当前状态也返回给了用户，同时返回的还有一些关于邮件和邮箱的附加信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A142 SELECT INBOX</span><br><span class="line">S: * <span class="number">172</span> EXISTS</span><br><span class="line">S: * <span class="number">1</span> RECENT</span><br><span class="line">S: * OK [<span class="type">UNSEEN</span> <span class="number">12</span>] Message <span class="number">12</span> is first unseen</span><br><span class="line">S: * OK [<span class="type">UIDVALIDITY</span> <span class="number">3857529045</span>] UIDs valid</span><br><span class="line">S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)</span><br><span class="line">S: * OK [<span class="type">PERMANENTFLAGS</span> (\<span class="type">Deleted</span> \<span class="type">Seen</span> \*)] Limited</span><br><span class="line">S: A142 OK [<span class="built_in">READ-WRITE</span>] SELECT completed</span><br></pre></td></tr></table></figure>

<h3 id="FETCH-mail-id-datanames"><a href="#FETCH-mail-id-datanames" class="headerlink" title="FETCH {mail id}{datanames}"></a>FETCH {mail id}{datanames}</h3><p>FETCH 命令用于读取邮件的文本信息，且仅用于显示的目的。包含两个参数，messageset：表示希望读取的邮件号列表，IAMP服务器邮箱中的每个邮件都有一个唯一的ID标识，（邮件号列表参数可以是一个邮件号，也可以是由逗号分隔的多个邮件号，或者由冒号间隔的一个范围），IMAP服务器返回邮件号列表中全部邮件的指定数据项内容。</p>
<p>数据名参数确定能够被独立返回的邮件的一部分，下面我们看看各参数返回的邮件信息：</p>
<ul>
<li>ALL：只返回按照一定格式的邮件摘要，包括邮件标志、RFC822.SIZE、自身的时间和信封信息。IMAP客户机能够将标准邮件解析成这些信息并显示出来。</li>
<li>BODY：只返回邮件体文本格式和大小的摘要信息。IMAP客户机可以识别这些细腻，并向用户显示详细的关于邮件的信息。其实是一些非扩展的BODYSTRUCTURE的信息。</li>
<li>FAST：只返回邮件的一些摘要，包括邮件标志、RFC822.SIZE、和自身的时间。</li>
<li>FULL：同样的还是一些摘要信息，包括邮件标志、RFC822.SIZE、自身的时间和BODYSTRUCTURE的信息。</li>
<li>BODYSTRUCTUR：是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来的。包括的内容有：邮件正文的类型、字符集、编码方式等和各附件的类型、字符集、编码方式、文件名称等等。</li>
<li>ENVELOPE：信息的信封结构。是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段得出来的，默认各字段都是需要的。主要包括：自身的时间、附件数、收件人、发件人等。</li>
<li>FLAGS：此邮件的标志。<br>INTERNALDATE：自身的时间。</li>
<li>RFC822.SIZE：邮件的[RFC-2822]大小<br>RFC822.HEADER：在功能上等同于BODY.PEEK[HEADER]。</li>
<li>RFC822：功能上等同于BODY[]。</li>
<li>RFC822.TEXT：功能上等同于BODY[TEXT]。</li>
<li>UID：返回邮件的UID号，UID号是唯一标识邮件的一个号码。</li>
<li>BODY[section] {partial}：返回邮件的中的某一指定部分，返回的部分用section来表示，section部分包含的信息通常是代表某一部分的一个数字或者是下面的某一个部分：HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, and TEXT。如果section部分是空的话，那就代表返回全部的信息，包括头信息。</li>
<li>BODY[HEADER]返回完整的文件头信息。</li>
<li>BODY[HEADER.FIELDS ()]：在小括号里面可以指定返回的特定字段。</li>
<li>BODY[HEADER.FIELDS.NOT ()]：在小括号里面可以指定不需要返回的特定字段。</li>
<li>BODY[MIME]：返回邮件的[MIME-IMB]的头信息，在正常情况下跟BODY[HEADER]没有区别。</li>
<li>BODY[TEXT]：返回整个邮件体，这里的邮件体并不包括邮件头。</li>
</ul>
<p>现在我们遇到了一个问题，如果我们要单独提取邮件的附件怎么办？<br>通过以上的命令我们是无法做到的，但是我们别忘了在section部分还有其他的方式可以来表示我们要提取的邮件的部分，那就的通过区段数来表示。那下面就让我们来看看什么是区段数。</p>
<p>每个邮件都至少有一个区段数，Non-[MIME-IMB]型的邮件和non-multipart [MIME-IMB]的邮件是没有经过MIME编码之后的信息的，那这样的信息只有一个区段数1。多区段型的信息被编排成一个连续的区段数，这和实际信息里出现的是一样的。如果一个特定的区段有类型信息或者是多区段的，一个MESSAGE/RFC822类型的区段也含有嵌套的区段数，这些区段数是指向这些信息区段的信息体的。</p>
<p>说了那么多拗口的，现在我们讲的更简单易懂一些。在一个邮件体里面，区段数1代表的邮件的正文，区段数二代表的是第一个附件，区段数三代表的是第二个附件，以此类推。在这些区段里，如果有哪个区段又是多区段的，比如2区段的内容格式是mulipart或者是 MESSAGE/RFC822类型的，那么这个区段又嵌套了多个子区段，嵌套的各子区段是用2.1，2.2……等等表示，类似，如果2.1又有嵌套，那么还会有2.1.1，2.1.2等区段。这样的嵌套是没有限制的。下面我们通过例子来了解一下fetch具体是怎么按区段下载的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEADER ([RFC-2822] header of the message)</span><br><span class="line">TEXT ([RFC-2822] text body of the message) MULTIPART&#x2F;MIXED</span><br><span class="line">1 TEXT&#x2F;PLAIN</span><br><span class="line">2 APPLICATION&#x2F;OCTET-STREAM</span><br><span class="line">3 MESSAGE&#x2F;RFC822</span><br><span class="line">3.HEADER ([RFC-2822] header of the message)</span><br><span class="line">3. TEXT ([RFC-2822] text body of the message) MULTIPART&#x2F;MIXED</span><br><span class="line">3.1 TEXT&#x2F;PLAIN</span><br><span class="line">3.2 APPLICATION&#x2F;OCTET-STREAM</span><br><span class="line">4 MULTIPART&#x2F;MIXED</span><br><span class="line">4.1 IMAGE&#x2F;GIF</span><br><span class="line">4.1. MIME ([MIME-IMB] header for the IMAGE&#x2F;GIF)</span><br><span class="line">4.2 MESSAGE&#x2F;RFC822</span><br><span class="line">4.2. HEADER ([RFC-2822] header of the message)</span><br><span class="line">4.2. TEXT ([RFC-2822] text body of the message) MULTIPART&#x2F;MIXED</span><br><span class="line">4.2.1 TEXT&#x2F;PLAIN</span><br><span class="line">4.2.2 MULTIPART&#x2F;ALTERNATIVE</span><br><span class="line">4.2.2.1 TEXT&#x2F;PLAIN</span><br><span class="line">4.2.2.2 TEXT&#x2F;RICHTEXT</span><br></pre></td></tr></table></figure>

<p>如果我们需要取第一个附件，那么命令就是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:a2 fetch <span class="number">4</span> body[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>取第三个区段的第一个子区段文本正文，命令就是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:a2 fetch <span class="number">4</span> body[<span class="number">3.1</span>]</span><br></pre></td></tr></table></figure>

<p>取第四个区段的第二个子区段再嵌套的第一个子区段的文本正文，命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:a2 fetch <span class="number">4</span> body[<span class="number">4.2</span><span class="type">.1</span>]</span><br></pre></td></tr></table></figure>

<p>当然这个例子只是针对于一个特殊的邮件结构，一般的邮件应该都没有这么复杂的结构。</p>
<p>再接下来我们再看看最后一个参数有什么用？BODY[section]可以使用partial字段进行修改，该字段包含两个用“.”隔开的数字，第一个数字、是八进制表示的希望显示的数据输出起始位置，第二个数字是八进制表示希望显示的数据长度。这项功能可以进一步设定输出格式，例如，如果你希望显示1号邮件中邮件提的前1500个字符，可以使用命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">FETCH <span class="number">1</span> BODY[<span class="type">TEXT</span>]&lt;<span class="number">0.1500</span>&gt;</span><br></pre></td></tr></table></figure>

<p>该命令取回邮件提的前1500个字符并定义为TEXT，如果邮件体少于1500个字符则返回整个邮件体。</p>
<p>例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: <span class="number">100</span> FETCH <span class="number">3</span>：<span class="number">5</span>  BODY[<span class="type">header.fields</span> (<span class="type">Date</span> <span class="type">From</span> <span class="type">Subject</span>)]  </span><br><span class="line">S: *  <span class="number">3</span>  FETCH  (BODY[<span class="type">HEADER.FIELDS</span> (“<span class="type">DATE</span>” “<span class="type">FROM</span>” “<span class="type">SUBJECT</span>”)]  &#123;<span class="number">112</span>&#125;</span><br><span class="line">DATE: Tue, <span class="number">14</span> Sep <span class="number">1999</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">50</span> <span class="literal">-500</span></span><br><span class="line">From: alex@shadrach.smallorg.org</span><br><span class="line">Subject: This is the first test message</span><br><span class="line">)</span><br><span class="line">S: *  <span class="number">4</span>  FETCH  (BODY[<span class="type">HEADER.FIELDS</span> (“<span class="type">DATE</span>” “<span class="type">FROM</span>” “<span class="type">SUBJECT</span>”)]  &#123;<span class="number">113</span>&#125;</span><br><span class="line">DATE: Tue, <span class="number">14</span> Sep <span class="number">1999</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">04</span> <span class="literal">-500</span></span><br><span class="line">From: alex@shadrach.smallorg.org</span><br><span class="line">Subject: This is the second test message</span><br><span class="line">)</span><br><span class="line">S: *  <span class="number">5</span>  FETCH  (BODY[<span class="type">HEADER.FIELDS</span> (“<span class="type">DATE</span>” “<span class="type">FROM</span>” “<span class="type">SUBJECT</span>”)]  &#123;<span class="number">112</span>&#125;</span><br><span class="line">DATE: Tue, <span class="number">14</span> Sep <span class="number">1999</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">26</span> <span class="literal">-500</span></span><br><span class="line">From: alex@shadrach.smallorg.org</span><br><span class="line">Subject: This is the first test message</span><br><span class="line">S: A100 OK FETCH completed</span><br><span class="line">C: A101 FETCH BODY[<span class="type">TEXT</span>]</span><br><span class="line">S:* This is the fourth test message <span class="keyword">for</span> IMAP</span><br><span class="line">S: A101 OK FETCH completed</span><br></pre></td></tr></table></figure>

<p>FETCH命令是IMAP协议里最复杂的命令。FETCH的命令参数很多、很复杂，但基本的特征是允许将邮件按照MIME结构拆解为零碎的部件来提取。例如，可以利用FETCH命令提取邮件头、某一个附件、或某一邮件附件头部的某一字段，等等。</p>
<h3 id="STORE-mail-id-new-attributes"><a href="#STORE-mail-id-new-attributes" class="headerlink" title="STORE {mail id}{new attributes}"></a>STORE {mail id}{new attributes}</h3><p>STORE 命令用于修改指定邮件的属性，包括给邮件打上已读标记、删除标记，等等。STORE命令当前只有两个数据项类型可用，FLAGS：表示邮件的一组标志； FLAGS.SLIENT，表示一组邮件的标志，通过在两种数据项前加上加号或者减号可以进一步改变它们的执行情况，加号表示数据项的值添加到邮件中，减号表示将数据项的值从邮件中删除。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A003 STORE <span class="number">2</span>:<span class="number">4</span> +FLAGS (\Deleted)     </span><br><span class="line">S: * <span class="number">2</span> FETCH FLAGS (\Deleted \Seen)</span><br><span class="line">S: * <span class="number">3</span> FETCH FLAGS (\Deleted)</span><br><span class="line">S: * <span class="number">4</span> FETCH FLAGS (\Deleted \Flagged \Seen)</span><br><span class="line">S: A003 OK STORE completed</span><br></pre></td></tr></table></figure>



<h3 id="CLOSE"><a href="#CLOSE" class="headerlink" title="CLOSE"></a>CLOSE</h3><p>CLOSE命令表示Client结束对当前Folder（文件夹/邮箱）的访问，关闭邮箱该邮箱中所有标志为、DELETED的邮件就被从物理上删除。CLOSE没有命令参数。随后可以SELECT另一Folder。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A341 CLOSE</span><br><span class="line">S: A341 OK CLOSE completed</span><br></pre></td></tr></table></figure>



<h3 id="EXPUNGE"><a href="#EXPUNGE" class="headerlink" title="EXPUNGE"></a>EXPUNGE</h3><p>EXPUNGE命令在不关闭邮箱的情况下删除所有的标志为、DELETED的邮件。EXPUNGE删除的邮件将不可以恢复。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A202 EXPUNGE</span><br><span class="line">S: * <span class="number">3</span> EXPUNGE</span><br><span class="line">S: * <span class="number">3</span> EXPUNGE</span><br><span class="line">S: * <span class="number">5</span> EXPUNGE</span><br><span class="line">S: * <span class="number">8</span> EXPUNGE</span><br><span class="line">S: A202 OK EXPUNGE completed</span><br></pre></td></tr></table></figure>



<h3 id="EXAMINE-mailbox"><a href="#EXAMINE-mailbox" class="headerlink" title="EXAMINE {mailbox}"></a>EXAMINE {mailbox}</h3><p>EXAMINE命令以只读方式打开邮箱，参数是需要打开的邮箱的名字，使用EXAMINE命令打开的邮箱不允许对邮件进行改动，因此不能增加或删除邮件的标志。</p>
<h3 id="SUBSCRIBE-mailbox"><a href="#SUBSCRIBE-mailbox" class="headerlink" title="SUBSCRIBE {mailbox}"></a>SUBSCRIBE {mailbox}</h3><p>SUBSCRIBE命令用来在客户机的活动邮箱列表中增加一个邮箱，该命令只有一个参数，希望添加的邮箱名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A114 SUBSCRIBE new/anotherbox</span><br><span class="line">S: A114 OK SUBSCRIBE completed</span><br></pre></td></tr></table></figure>



<h3 id="UNSUBSCRIBE-mailbox"><a href="#UNSUBSCRIBE-mailbox" class="headerlink" title="UNSUBSCRIBE {mailbox}"></a>UNSUBSCRIBE {mailbox}</h3><p>UNSUBSCRIBE命令用来从活动列表中去掉一个邮箱，一个参数：希望去掉的邮箱名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A115 UNSUBSCRIBE new/anotherbox</span><br><span class="line">S: A115 OK SUBSCRIBE completed</span><br></pre></td></tr></table></figure>



<h3 id="LSUB-folder-mailbox"><a href="#LSUB-folder-mailbox" class="headerlink" title="LSUB {folder}{mailbox}"></a>LSUB {folder}{mailbox}</h3><p>LSUB命令修正了LIST命令，LIST返回用户$HOME目录下所有的文件，但LSUB命令只显示那些使用SUBSCRIBE命令设置为活动邮箱的文件。两个参数：邮箱路径和邮箱名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A116 LSUB “” *</span><br><span class="line">S:* LSUB () “/” stuff/junk</span><br><span class="line">S:* LSUB () “/” neebox</span><br><span class="line">S:* LSUB () “/” new/anotherbox</span><br><span class="line">S: A116 OK LSUB completed</span><br></pre></td></tr></table></figure>



<h3 id="STATUS-mailbox-parameter1-parameter2-……-parameter5"><a href="#STATUS-mailbox-parameter1-parameter2-……-parameter5" class="headerlink" title="STATUS {mailbox}({parameter1}{parameter2}……{parameter5})"></a>STATUS {mailbox}({parameter1}{parameter2}……{parameter5})</h3><p>STATUS命令查询邮箱的当前状态。第一个参数是需要查询的邮箱名，第二个参数是客户机需要查询的项目列表（要查询显示的信息），当在圆括号中。STATUS可以在不使用SELECT命令（打开邮箱）或者EXAMINE（以只读方式打开邮箱）前提下获取邮箱的信息。</p>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MESSAGE</td>
<td align="center">邮箱中的邮件总数</td>
</tr>
<tr>
<td align="center">RECENT</td>
<td align="center">邮箱中标志为\RECENT的邮件数</td>
</tr>
<tr>
<td align="center">UIDNEXT</td>
<td align="center">可以分配给新邮件的下一个UID</td>
</tr>
<tr>
<td align="center">UIDVALIDITY</td>
<td align="center">邮箱的UID有效性标志</td>
</tr>
<tr>
<td align="center">UNSEEN</td>
<td align="center">邮箱中没有被标志为\UNSEEN的邮件数</td>
</tr>
</tbody></table>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A117 STATUS inbox  (message recent unseen)</span><br><span class="line">S:* STATUS inbox (MESSAGE <span class="number">1</span> RECENT <span class="number">0</span> UNSENN <span class="number">0</span>)</span><br><span class="line">S: A117 OK STATUS completed</span><br><span class="line">C: A118 STATUS newbox  (message recent unseen)</span><br><span class="line">S:* STATUS inbox (MESSAGE <span class="number">1</span> RECENT <span class="number">0</span> UNSENN <span class="number">2</span>)</span><br><span class="line">S: A118 OK STATUS completed</span><br></pre></td></tr></table></figure>



<h3 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h3><p>CHECK命令用来在邮箱设置一个检查点。没有参数。就是IMAP中的sync命令。任何未完成的操作，例如从服务器内存向硬盘写数据，都将会被做完以保持邮箱的一致性状态。该命令确保乃村中的磁盘缓冲数据都被写到了磁盘上。</p>
<h3 id="SEARCH-CHARSET-specification-search-criteria"><a href="#SEARCH-CHARSET-specification-search-criteria" class="headerlink" title="SEARCH [CHARSET specification] (search criteria)"></a>SEARCH [CHARSET specification] (search criteria)</h3><p>命令可以根据搜索条件在处于活动状态的邮箱中搜索邮件，然后显示匹配的邮件编号。字符集标志参数[CHARSET specification]由CHARSET和注册的字符集标志符组成，缺省的标志符是US-ASCⅡ，所以该参数长省略。search criteria：查询条件参数，明确查询的关键字和值。查询关键字有几十种。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A119 SEARCH header subject another</span><br><span class="line">S: SEARCH <span class="number">1</span> <span class="number">2</span></span><br><span class="line">S:* A119 OK SEARCH completed</span><br><span class="line">C: A120 SEARCH header subject another</span><br><span class="line">S: *SEARCH <span class="number">2</span></span><br><span class="line">S: A120 OK SEARCH completed</span><br><span class="line">C: A121 SEARCH UNSEEN</span><br><span class="line">S: *SEARCH <span class="number">1</span> <span class="number">2</span></span><br><span class="line">S: A120 OK SEARCH completed</span><br></pre></td></tr></table></figure>

<p>以上每个例子都在邮件头的Subject:字段中查询一个不同的单词。服务器返回条件的邮件号列表，如果没有匹配邮件则返回不带UID的SEARCH单词。</p>
<h3 id="COPY-mail-id-mailboxname"><a href="#COPY-mail-id-mailboxname" class="headerlink" title="COPY {mail id}{mailboxname}"></a>COPY {mail id}{mailboxname}</h3><p>COPY命令可以把邮件从一个邮箱复制到另一个邮箱，两个参数：mail id是希望从活动邮箱中复制的邮件的标号，mailboxname是希望邮件被复制到的邮箱。IAMP没有定义移动邮件的命令，移动操作相当于先把邮件复制到新邮箱中，然后对源邮箱中的邮件设置\DELETED标志。下一次执行检查点过后，新邮箱中的邮件被删除，新邮件就被显示出来。</p>
<h3 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h3><p>UID 命令和FETCH、COPY、STORE命令或者SEARCH命令一起使用，它允许这些命令使用邮件的UID号而不是在邮箱中的顺序号。UID号是唯一标识邮件系统中邮件的32位证书。通常这些命令都使用顺序号来标识邮箱中的邮件，使用UID可以使IMAP客户机记住不同IMAP会话中的邮件。</p>
<h3 id="CAPABILITY"><a href="#CAPABILITY" class="headerlink" title="CAPABILITY"></a>CAPABILITY</h3><p>CAPABILITY命令请求返回IMAP服务器支持的功能列表，服务器收到客户机发送的CAPABILITY命令后将返回该服务器所支持的功能。无参数。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A122 CAPABILITY</span><br><span class="line">S:*A122 CAPABILITY IMAP4 IMAP4REVl NAMESPACE IDLE SCAN SORT   MAILBOX</span><br><span class="line">-<span class="literal">-REFERRALS</span> [<span class="type">ic</span>:<span class="type">ccc</span>] LOGIN<span class="literal">-REFERRALS</span> AUTH=LOGIN THREAD=</span><br><span class="line">ORDERDSUBJECT</span><br><span class="line">S: A122 OK CAPABILITY completed</span><br></pre></td></tr></table></figure>



<h3 id="NOOP"><a href="#NOOP" class="headerlink" title="NOOP"></a>NOOP</h3><p>NOOP命令什么也不做，用来向服务器发送自动命令，防止因长时间处于不活动状态而导致连接中断，服务器对该命令的响应始终为肯定。无参数。</p>
<h3 id="LOGOUT"><a href="#LOGOUT" class="headerlink" title="LOGOUT"></a>LOGOUT</h3><p>LOGOUT命令使当前登陆用户退出登陆并关闭所有打开的邮箱，任何做了\DELETED标志的邮件都将在这个时候被删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jun"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junzkn</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
