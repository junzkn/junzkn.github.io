<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://junzkn.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Never And Ever">
<meta property="og:url" content="http://junzkn.github.io/page/4/index.html">
<meta property="og:site_name" content="Never And Ever">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://junzkn.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Never And Ever</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Never And Ever</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">thanks for coming</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-时间线">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>时间线</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Internet-Network-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Internet-Network-architecture/" class="post-title-link" itemprop="url">计算机网络体系结构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-24 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-24T00:00:00+08:00">2018-10-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机网络的分层"><a href="#计算机网络的分层" class="headerlink" title="计算机网络的分层"></a>计算机网络的分层</h2><p>两个系统中的实体通信是一个非常复杂的过程，对其使用分层的方式进行建模，可以更加有效的对系统进行实现和维护。计算机网络中，也是用了分层的概念，将整个计算机网络的通信进行层次划分。计算机网络的体系结构就是就层次、各层的协议以及层间接口的集合。模型进行分层的基本原则是：</p>
<ol>
<li><p>每一居都实现一种相对独立的功能 ，降低大系统的复杂度 。</p>
</li>
<li><p>各层之间界面自然清晰 ，易于理解，相互交流尽可能少 。</p>
</li>
<li><p>各层功能的精确定义独立于具体的实现方法 ，可以采用最合适的技术来实现 。</p>
</li>
<li><p>保持下层对上层的独立性 ，上层单向使用下层提供的服务 。</p>
</li>
<li><p>整个分层结构应能促进标准化工作 。</p>
</li>
</ol>
<h2 id="协议与服务"><a href="#协议与服务" class="headerlink" title="协议与服务"></a>协议与服务</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议：就是约定规则的组合。它是一种<strong>水平</strong>方向的，即两边的同一层才会有相同协议的约定。协议由语法、语义和同步三部分组成。语法规定了传输数据的格式；语义规定了所要完成的功能，即需要发出何种控制信息 、完成何种动作以及做出何种应答；同步规定了执行各种操作的条件、时序关系等 ，即事件实现顺序的详细说明 。一个完整的协议通常应具有线路管理（建立、 释放连接）、差错控制 、数据转换等功能 。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务：指下层为紧相邻的上层提供的功能调用，也就是<strong>垂直</strong>的。</p>
<p>协议与服务的关系如下：</p>
<p><img src="/Internet-Network-architecture/协议与服务.png" alt="服务于协议"></p>
<h2 id="计算机网络结构模型"><a href="#计算机网络结构模型" class="headerlink" title="计算机网络结构模型"></a>计算机网络结构模型</h2><ul>
<li>OSI七层模型：开放系统互连参考模型（OSI/RM），一共有七层。自下而上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。</li>
<li>TCP/IP四层模型：对于OSI的一种简化，一共有四层。分别为网络接口层、网络层、运输层、应用层。</li>
<li>五层模型：一种对于OSI和TCP/IP的折中，一共有5层。分别为物理层、数据链路层、网络层、运输层、应用层。</li>
</ul>
<p><img src="/Internet-Network-architecture/计算机网络体系结构.png" alt></p>
<p>下面是五层模型中每层的简要概述：</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul>
<li>作用：他规定了通信端点之间的一些特性，如机械、电气、功能特性。为上层协议提供了一个传输数据的物理媒体。</li>
<li>数据单元为：比特（bit）。</li>
<li>在物理层的互联设备包括：集线器（Hub）、中继器（Repeater）等。</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul>
<li>作用：控制网络层与物理层之间的通信，其主要功能是在不可靠的物理介质上提供可靠的传输。功能包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</li>
<li>数据单元：帧（frame）。</li>
<li>在数据链路层的互联设备包括：网桥（Bridge）、交换机（Switch）等。</li>
<li>在数据链路层的协议有：CSMA/CD等</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>作用：对网络地址和物理地址进行相互翻译，并确定数据如何重发送方发送到接收方。功能包括：对子网间的数据包进行路由选择，实现拥塞控制、网际互连等。</li>
<li>数据单元：数据包（packet）。</li>
<li>在网络层的互联设备包括：路由器（Router）等。</li>
<li>在网络层的协议有：IP、ICMP、ARP、RIP、OSPF等。</li>
</ul>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><ul>
<li>模型中最重要的一层，是第一个端到端，即主机到主机的层次。</li>
<li>作用：负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</li>
<li>协议数据单元：数据段（segment）。</li>
<li>传输层协议的代表包括：TCP、UDP、SPX等。</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>作用：为操作系统或网络应用程序提供访问网络服务的接口。</li>
<li>协议数据单元：报文（message）。</li>
<li>在应用层的互联设备包括：网关（Gateway）等。</li>
<li>传输层协议的代表包括：HTTP、FTP、DNS、SMTP等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Internet-TCP&UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Internet-TCP&UDP/" class="post-title-link" itemprop="url">TCP和UDP的区别</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-23T00:00:00+08:00">2018-10-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP和UDP概述"><a href="#TCP和UDP概述" class="headerlink" title="TCP和UDP概述"></a>TCP和UDP概述</h2><p>在网络框架结构体系中，最主要的便是传输层，它是一个承上启下的环节，主要工作是负责端到端之间的通信。在这一层中有两个重要的协议：1.用户数据报协议UDP(User Datagram Protocol)；传输控制协议TCP(Transmission Control Protocol)。</p>
<p><img src="/Internet-TCP&UDP/TCP和UDP.png" alt></p>
<h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p>TCP，提供<strong>面向连接的服务</strong>，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认连接，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<h2 id="传输层常用端口号"><a href="#传输层常用端口号" class="headerlink" title="传输层常用端口号"></a>传输层常用端口号</h2><p>端口是传输层服务访问点(TSAP)，端口的作用是让应用层的各种应用进程都能将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的进程。下面是常用端口。</p>
<table>
<thead>
<tr>
<th align="center">应用程序</th>
<th align="center">FTP</th>
<th align="center">TELNET</th>
<th align="center">SMTP</th>
<th align="center">HTTP</th>
<th align="center">HTTPS</th>
<th align="center">DNS</th>
<th align="center">TFTP</th>
<th align="center">SNMP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">熟知端口</td>
<td align="center">21</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">80</td>
<td align="center">443</td>
<td align="center">53</td>
<td align="center">69</td>
<td align="center">161</td>
</tr>
<tr>
<td align="center">传输层协议</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">UDP</td>
<td align="center">UDP</td>
<td align="center">UDP</td>
</tr>
</tbody></table>
<h2 id="TCP和UDP首部"><a href="#TCP和UDP首部" class="headerlink" title="TCP和UDP首部"></a>TCP和UDP首部</h2><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p><img src="/Internet-TCP&UDP/TCP首部.jpg" alt="TCP首部"></p>
<ol>
<li><p>第一个4字节：</p>
<ul>
<li>源端口，16位；发送数据的源进程端口。</li>
<li>目的端口，16位；接收数据的进程端口。</li>
</ul>
</li>
<li><p>第二个4字节与第三个4字节</p>
<ul>
<li>序号，32位；代表当前TCP数据段第一个字节占整个字节流的相对位置。</li>
<li>确认号，32位；代表接收端希望接收的数据序号，为上次接收到数据报的序号+1，当ACK标志位为1时才生效。</li>
</ul>
</li>
<li><p>第四个4字节</p>
<ul>
<li><p>数据偏移，4位；实际代表TCP首部长度，最大为60字节。</p>
</li>
<li><p>6个标志位，每个标志位1位。</p>
<p>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p>
<p>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</p>
<p>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p>
<p>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p>
<p>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</p>
<p>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。</p>
</li>
<li><p>窗口值，16位；指的是通知接收方，发送本报文你需要有多大的空间来接受。</p>
</li>
</ul>
</li>
<li><p>第五个4字节</p>
<ul>
<li>校验和，16位；用于检验首部和数据的完整性。</li>
<li>紧急指针，16位；只有当URG标识位为1时，紧急指针才有效。紧急指针的值与序号的相加值为紧急数据的最后一个字节位置。用于发送紧急数据。</li>
</ul>
</li>
</ol>
<h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p><img src="/Internet-TCP&UDP/UDP首部.png" alt="UDP首部"></p>
<ol>
<li><p>后8个字节</p>
<ul>
<li>源端口，16位；发送数据的源进程端口。</li>
<li>目的端口，16位；接收数据的进程端口。</li>
<li>长度，16位；UDP数据长度。</li>
<li>检验和，16位；检测UDP在传输中是否有错，有错早就丢弃。</li>
</ul>
</li>
<li><p>前12个字节</p>
<p>伪首部：不是真正的UDP首部，只是在计算校验和时，临时添加在UDP前，得到一个临时的UDP。校验和就是更根据这个临时的UDP来计算的。伪首部既不向下传递也不向上递交，而是仅仅为了计算校验和。</p>
</li>
</ol>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol>
<li>TCP基于连接；UDP基于无连接。</li>
<li>TCP要求系统资源较多；UDP较少。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。</li>
<li>TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Algorithm_design-LRU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Algorithm_design-LRU/" class="post-title-link" itemprop="url">LRU算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">算法设计</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Algorithm_design-Sorting_Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Algorithm_design-Sorting_Algorithm/" class="post-title-link" itemprop="url">排序算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">算法设计</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h3><p>排序算法中，大类型可以分为两类：非线性时间比较类排序和线性时间非比较类排序。</p>
<ol>
<li><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li>
<li><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li>
</ol>
<p><img src="/Algorithm_design-Sorting_Algorithm/排序算法分类.png" alt="排序算法分类"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>稳定性：相同元素在排序之后前后顺序位置没有交换。</p>
<p>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p>
<p>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p>
<h3 id="各算法复杂度和稳定性比较"><a href="#各算法复杂度和稳定性比较" class="headerlink" title="各算法复杂度和稳定性比较"></a>各算法复杂度和稳定性比较</h3><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>插入排序是一种直观排序方法。工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>第一个元素开始，该元素认为已经排好序。</li>
<li>取下一个元素k，在已经排好序的元素序列中从后往前扫。</li>
<li>如果扫到的元素j比k大，把j往后移动一位。</li>
<li>重复3步骤，直到扫到元素j比k小。</li>
<li>将k插入到扫描到的位置中。</li>
<li>重复2~5步骤。</li>
</ol>
<h3 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/插入排序动态图.gif" alt="插入排序动态图"></p>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;array.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = array[i] ;</span><br><span class="line">        <span class="keyword">int</span> j=i-<span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//从后往前遍历，插入到前面的有序序列中</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; k&lt;array[j])&#123;</span><br><span class="line">            array[j+<span class="number">1</span>] = array[j] ;</span><br><span class="line">            j-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j+<span class="number">1</span>] = k ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性"><a href="#时间复杂度和稳定性" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>直接插入排序中。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需$(n-1)$次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有$n(n-1)/2$次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说直接插入排序的时间复杂度为$O(n^2)$。</p>
<p>应为采用的比较方式不是&lt;=而是&lt;，所以直接插入排序是稳定的排序算。</p>
<h2 id="2-二分插入排序"><a href="#2-二分插入排序" class="headerlink" title="2.二分插入排序"></a>2.二分插入排序</h2><p>与直接插入排序类似，只不过是通过二分查找来先找到需要插入的位置。</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置。</li>
<li>将新元素插入到该位置。</li>
<li>重复2~3步骤。</li>
</ol>
<h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bin_insert_sort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = a[i] ;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span> , right=i-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//采用二分法找第一个比k大的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(a[middle]&gt;k)</span><br><span class="line">                right = middle-<span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = middle+<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span> ; j&gt;=left ; j--)&#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = k ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-1"><a href="#时间复杂度和稳定性-1" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>当n较大时，总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。最佳情况$O(n*\log n)$，最差和平均情况$O(n^2)$。</p>
<p>二分查找中寻找的是第一个比他大，不存在&gt;=情况。所以二分插入排序是稳定的排序算法。</p>
<h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h2><p>希尔排序，也称递减增量排序算法，因DL．Shell于1959年提出而得名，是插入排序的一种高速而稳定的改进版本。采用分组插入的方式进行排序。</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。</li>
<li>所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。</li>
<li>取第二个增量d2&lt;d1重复上述的分组和排序，</li>
<li>直至所取的增量dt=1(dt&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</li>
</ol>
<h3 id="演示图-1"><a href="#演示图-1" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/希尔排序动态图.gif" alt="希尔排序演示图"></p>
<h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里增量取数组长度一半(希尔增量)</span></span><br><span class="line">    <span class="keyword">int</span> gap = a.length/<span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">while</span>(gap&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;gap ; i++)&#123;</span><br><span class="line">            <span class="comment">//内部进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i ; j&lt;a.length ; j+=gap)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j] ;</span><br><span class="line">                <span class="keyword">int</span> k = j-gap ;</span><br><span class="line">                <span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; temp&lt;a[k])&#123;</span><br><span class="line">                    a[k+gap] = a[k] ;</span><br><span class="line">                    k-=gap ;</span><br><span class="line">                &#125;</span><br><span class="line">                a[k+gap] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-2"><a href="#时间复杂度和稳定性-2" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为$O(n^2)$。而Hibbard增量的希尔排序的时间复杂度为$O(n^{5/4})$，但是现今仍然没有人能找出希尔排序的精确下界。平均时间复杂度为$O(n^{1.3})$。</p>
<p>希尔排序是不稳定的。因为在不同增量小组中可能有相同元素，但是会根据不同小组进行排序，导致可能出现换位。</p>
<h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.选择排序"></a>4.选择排序</h2><p>选择排序也是一种比较直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>一开始数组分为有序序列(空)和无序序列([0…n])。</li>
<li>在无序序列中选择一个最小的数，放到有序序列最后面。</li>
<li>重复步骤2，一直直到无序序列为空。</li>
</ol>
<h3 id="演示图-2"><a href="#演示图-2" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/选择排序动态图.gif" alt="直接选择排序动态图"></p>
<h3 id="Java代码-3"><a href="#Java代码-3" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i ;</span><br><span class="line">        <span class="comment">//选取最大的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i ; j&lt;a.length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[k])&#123;</span><br><span class="line">                k = j ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">        a[i] = a[k] ;</span><br><span class="line">        a[k] = temp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-3"><a href="#时间复杂度和稳定性-3" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>选择排序的比较次数为$n(n-1)/2$,交换次数最好情况为$0$，最坏情况为$n-1$。平均时间复杂度为$O(n^2)$。</p>
<p>因为是选择最小的交换到前面，不能保证前面的数交换到的位置。所以是不稳定的排序算法。</p>
<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h2><p>利用堆这种数据结构，实现的排序算法。这里的堆是一个完全二叉树，并满足堆性质：子节点的值或索引小于父结点。</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将序列构建成大顶堆。</li>
<li>将第一个元素与最后一个元素进行交换，并把交换完的最后一个元素移出堆中。</li>
<li>对交换完的第一个元素进行堆调整(把它插入到适合位置，使堆变回大顶堆)。</li>
<li>重复2~3步骤，直到堆中没有元素。</li>
</ol>
<h3 id="演示图-3"><a href="#演示图-3" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/堆排序动态图.gif" alt="堆排序动态图"></p>
<h3 id="Java代码-4"><a href="#Java代码-4" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        HeapAdjust(a,i,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换最前和最后，然后进行堆调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>] ;</span><br><span class="line">        a[<span class="number">0</span>] = a[i] ;</span><br><span class="line">        a[i] = temp ;</span><br><span class="line">        HeapAdjust(a,<span class="number">0</span>,i-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> t, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t&lt;l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t*<span class="number">2</span>+<span class="number">2</span>&lt;=l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[t*<span class="number">2</span>+<span class="number">2</span>]&gt;a[t] &amp;&amp; a[t*<span class="number">2</span>+<span class="number">2</span>]&gt;=a[t*<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[t] ;</span><br><span class="line">                a[t] = a[t*<span class="number">2</span>+<span class="number">2</span>] ;</span><br><span class="line">                a[t*<span class="number">2</span>+<span class="number">2</span>] = temp ;</span><br><span class="line">                t = t*<span class="number">2</span>+<span class="number">2</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[t*<span class="number">2</span>+<span class="number">1</span>]&gt;a[t] &amp;&amp; a[t*<span class="number">2</span>+<span class="number">1</span>]&gt;=a[t*<span class="number">2</span>+<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[t] ;</span><br><span class="line">                a[t] = a[t*<span class="number">2</span>+<span class="number">1</span>] ;</span><br><span class="line">                a[t*<span class="number">2</span>+<span class="number">1</span>] = temp ;</span><br><span class="line">                t = t*<span class="number">2</span>+<span class="number">1</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t*<span class="number">2</span>+<span class="number">1</span>&gt;l)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[t*<span class="number">2</span>+<span class="number">1</span>]&gt;a[t])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[t] ;</span><br><span class="line">                a[t] = a[t*<span class="number">2</span>+<span class="number">1</span>] ;</span><br><span class="line">                a[t*<span class="number">2</span>+<span class="number">1</span>] = temp ;</span><br><span class="line">                t = t*<span class="number">2</span>+<span class="number">1</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-4"><a href="#时间复杂度和稳定性-4" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>因为使用了二叉树结构，数的高度为$\log n$，所以说一次堆调整平均为$\log n$。而堆排序需要对n个数进行堆调整，所以堆排序平均时间复杂度为$O(n*\log n)$。</p>
<p>堆排序是不稳定的。因为在比较节点大小时，只会将最大的放到父结点，对于相同的没有做其他处理。</p>
<h2 id="6-冒泡排序"><a href="#6-冒泡排序" class="headerlink" title="6.冒泡排序"></a>6.冒泡排序</h2><p>使用多次比较的方法，让大的元素“浮”到尾部的排序方法。</p>
<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>比较相邻的两个元素，将较大的元素放到后面。</li>
<li>对序列中每一对元素进行上述操作。</li>
<li>将最大的元素“浮”到最后之后，对剩余的元素进行1~2步骤。</li>
<li>知直到没有剩余元素。</li>
</ol>
<h3 id="演示图-4"><a href="#演示图-4" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/冒泡排序动态图.gif" alt="冒泡排序动态图"></p>
<h3 id="Java代码-5"><a href="#Java代码-5" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;i-<span class="number">1</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j] ;</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>] ;</span><br><span class="line">                a[j+<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-5"><a href="#时间复杂度和稳定性-5" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>需要对n个元素进行n次比较，平均时间复杂度为$O(n^2)$。</p>
<p>比较的时候使用&gt;而不是&gt;=，所以是稳定的算法。</p>
<h2 id="7-鸡尾酒排序"><a href="#7-鸡尾酒排序" class="headerlink" title="7.鸡尾酒排序"></a>7.鸡尾酒排序</h2><p>鸡尾酒排序,也叫双向冒泡排序。是对冒泡排序的一种轻微变形。不同的地方是冒泡排序每次都是从低到高，而鸡尾酒排序则是从低到高然后从高到底这样循环。</p>
<h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>依次比较相邻的数，将小的元素放在前面，将大的元素放到后面。</li>
<li>先从先往后，将最大的放到最后一位。</li>
<li>然后从后往前，将最小的放到第一位。</li>
<li>重复2~3步骤，知道完成排序。</li>
</ol>
<h3 id="演示图-5"><a href="#演示图-5" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/鸡尾酒排序动态图.gif" alt="鸡尾酒排序演示"></p>
<h3 id="Java代码-6"><a href="#Java代码-6" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cocktail_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span> , tail=a.length-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">        <span class="comment">//从前往后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head ; i&lt;tail ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">                a[i] = a[i+<span class="number">1</span>] ;</span><br><span class="line">                a[i+<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-- ;</span><br><span class="line">        <span class="comment">//从后往前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tail ; i&gt;head ; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">                a[i] = a[i-<span class="number">1</span>] ;</span><br><span class="line">                a[i-<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-6"><a href="#时间复杂度和稳定性-6" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>和冒泡排序一样，需要进行n个元素的n次比较。平均时间复杂度为$O(n^2)$。</p>
<p>由于没有使用=，所以算法是稳定的。</p>
<h2 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a>8.快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。其基本思想是基本思想是，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从序列中选取一个元素，称为“基准”。</li>
<li>分别从前后两边扫描，把小于基准的元素放到左边，大一基准的放到右边，此时基准边处于中间位置。</li>
<li>分别对基准左右两边的序列进行上述1~2步骤的递归。</li>
</ol>
<h3 id="演示图-6"><a href="#演示图-6" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/快速排序动态图.gif" alt="快排演示"></p>
<h3 id="Java代码-7"><a href="#Java代码-7" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i=low , j=high ;</span><br><span class="line">    <span class="keyword">int</span> key = a[low] ; <span class="comment">//选取第一个数为基准</span></span><br><span class="line">    <span class="comment">//进行分类，小的分左边，大的分右边</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[j]&gt;key) j-- ;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=key) i++ ;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">            a[i] = a[j] ;</span><br><span class="line">            a[j] = temp ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = a[i] ;</span><br><span class="line">    a[i] = key ;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quick_sort(a,low,i-<span class="number">1</span>);</span><br><span class="line">    quick_sort(a,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于快排的优化：</p>
<ol>
<li>选取随机标准值</li>
<li>在规模小时(&lt;8)使用直接插入排序</li>
<li>重复的数据多时，是用三路快排</li>
</ol>
</blockquote>
<h3 id="时间复杂度和稳定性-7"><a href="#时间复杂度和稳定性-7" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>它的平均时间复杂度是$O(n·\log_2 n)$。在平均状况下，排序n个项目要$Ο(n·\log_2 n)$次比较。在最坏状况下则需要$Ο(n^2)$次比较，但这种状况并不常见。事实上，快速排序通常明显比其他$Ο(n·\log_2 n)$算法更快，因为它的内部循环递归（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>它是不稳定的算法，因为在和比较基准，没有和其他的相同的数比较排放。</p>
<h2 id="9-归并排序"><a href="#9-归并排序" class="headerlink" title="9.归并排序"></a>9.归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。它使用额外的空间来进行分治。</p>
<h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将长度为n的序列分为两个长度为n/2的子序列。</li>
<li>对这两个子序列分别采用归并排序。</li>
<li>将两个子序列合并成有序序列。</li>
</ol>
<h3 id="演示图-7"><a href="#演示图-7" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/归并排序动态图.gif" alt="归并排序演示"></p>
<h3 id="Java代码-8"><a href="#Java代码-8" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger_sort</span><span class="params">(<span class="keyword">int</span>[] a , <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span> ;</span><br><span class="line">    merger_sort(a,low,middle);</span><br><span class="line">    merger_sort(a,middle+<span class="number">1</span>,high);</span><br><span class="line">    <span class="comment">//合并两个有序序列</span></span><br><span class="line">    merger(a,low,middle,high) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[high+<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span> center = middle+<span class="number">1</span> , start = low ;</span><br><span class="line">    <span class="keyword">int</span> i = low ;</span><br><span class="line">    <span class="comment">//比较后放到新数组中</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=middle &amp;&amp; center&lt;=high)</span><br><span class="line">        newArray[i++] = a[start]&gt;a[center] ? a[center++] : a[start++] ;</span><br><span class="line">    <span class="comment">//剩余的放到数组后面</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=middle)</span><br><span class="line">        newArray[i++] = a[start++] ;</span><br><span class="line">    <span class="keyword">while</span>(center&lt;=high)</span><br><span class="line">        newArray[i++] = a[center++] ;</span><br><span class="line">    <span class="comment">//复制数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=low ; j&lt;=high ; j++)&#123;</span><br><span class="line">        a[j] =newArray[j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-8"><a href="#时间复杂度和稳定性-8" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为$O(n)$，故一共为$O(n<em>\log n)$。所有平均复杂度为$O(n</em>\log n)$。</p>
<p>归并排序是稳定的算法。因为采取的是按前往的顺序的递归归并。不会出现后面跳到前面来。</p>
<h2 id="10-计数排序"><a href="#10-计数排序" class="headerlink" title="10.计数排序"></a>10.计数排序</h2><p>计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。所以它也只能对整数进行排序。</p>
<h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项。</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）。</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
<h3 id="演示图-8"><a href="#演示图-8" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/计数排序动态图.gif" alt="计数排序动态图"></p>
<h3 id="Java代码-9"><a href="#Java代码-9" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="keyword">int</span>[] a , <span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//k为数组中最大的数</span></span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length] ;</span><br><span class="line">    <span class="comment">//构建C数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        c[a[i]]+=<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对C数组进行调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;k+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">        c[i] += c[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放到新数组B中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        b[c[a[i]]-<span class="number">1</span>] = a[i] ;</span><br><span class="line">        c[a[i]]-=<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        a[i] = b[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-9"><a href="#时间复杂度和稳定性-9" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>当输入的元素是n个0到k之间的整数时，它的运行时间是$O(n+k)$。所以平均时间复杂度为$O(n)$计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>计数排序是稳定的。因为插入到B数组时，采用的是倒序遍历A数组，插入的位置也是先后再前。</p>
<h2 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11.基数排序"></a>11.基数排序</h2><p>基数排序，桶排序的一种。是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从低位到高位开始，依次进行一次排序。</li>
</ol>
<h3 id="演示图-9"><a href="#演示图-9" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/基数排序动态图.gif" alt="基数排序动态图"></p>
<h3 id="Java代码-10"><a href="#Java代码-10" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找出最大的数的位数times</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE , times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">        times++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//radixArray用于摆放，radixBit用于辅助计数</span></span><br><span class="line">    <span class="keyword">int</span>[][] radixArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length];</span><br><span class="line">    <span class="keyword">int</span>[] radixBit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(times--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//将元素分类放进桶中，这就是排序了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (a[i] / radix) % <span class="number">10</span>;</span><br><span class="line">            radixArray[bit][radixBit[bit]] = a[i];</span><br><span class="line">            radixBit[bit] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按照桶的顺序放回A数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; radixBit.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; radixBit[i]; j++) &#123;</span><br><span class="line">                a[index ++] = radixArray[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            radixBit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-10"><a href="#时间复杂度和稳定性-10" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>基数排序的时间复杂度是$O(k*n)$，其中n是排序元素个数，k是数字位数。但是不一定优于$O(n·\log n)$，因为k的大小一般会受到n的影响。需要使用的额外空间为$O(k+n)$。</p>
<p>它是稳定的排序算法，因为排序过程中没有元素的调换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-Activity_Lunch_model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-Activity_Lunch_model/" class="post-title-link" itemprop="url">Activity启动模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在应用程序中，Activity是使用栈形式管理的，多个Activity一般会按照先进后出的方式存放到Task栈中。Activity间的跳转就是Task栈中各Activity切换，位于栈顶的Activity就是我们可见可交互的Activity。启动模式，可以控制Activity的启动方式，是在Task栈中创建新的Activity还是复用以前的Activity。</p>
<h2 id="启动模式的设置"><a href="#启动模式的设置" class="headerlink" title="启动模式的设置"></a>启动模式的设置</h2><p>在AndroidManifest文件中的Activity配置中设置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MainnActivity"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span>/&gt;</span> <span class="comment">&lt;!--这里设置模式--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Standard模式"><a href="#Standard模式" class="headerlink" title="Standard模式"></a>Standard模式</h2><p>标准模式也是默认模式。Activity在这种模式下，每一个intent发送去启动Activity时，都会创建一个新的Activity并放到Task栈顶中。</p>
<h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>启动Activity时(其他应用的Activity也是)，会创建新的Activity并放到本应用Task栈顶。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式1.jpg" alt></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>没有特殊要求时，一般的Activity都会使用该模式。</p>
<h2 id="SingleTop模式"><a href="#SingleTop模式" class="headerlink" title="SingleTop模式"></a>SingleTop模式</h2><p>Activity在SingleTop模式下，如果Task栈顶已经存在一个该Activity，就不会再创建新的Activity，取而代之的是通过onNewIntent()方法将Intent发送至这个存在的Activity，也就是复用该ctivity。如果Task栈顶不存在相同类型的Activity，就会创建新的Activity并放到Task栈顶。</p>
<h3 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h3><p>如果栈顶不存在该Activity，和standard模式一样。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式2.jpg" alt></p>
<p>如果存在则复用。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式3.jpg" alt></p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>搜索功能界面的Activity。点击搜索之后都是跳回本Activity，不去创建新的Activity。</p>
<h2 id="SingleTask模式"><a href="#SingleTask模式" class="headerlink" title="SingleTask模式"></a>SingleTask模式</h2><p>一个Activity使用了SingleTask的话，如果该Task栈中存在该Activity，启动时就会把该Activity之上所有的Activity移出栈(按适当的生命周期销毁)，使该Activity变成栈顶Activity，并通过onNewIntent()方法复用该Activity。如果Task栈中没有改Activity，便创建新的Activity放到Task栈顶。</p>
<h3 id="表现-2"><a href="#表现-2" class="headerlink" title="表现"></a>表现</h3><p>栈中没有该Activity时，创建Activity并放到栈顶。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式4.jpg" alt></p>
<p>如果存在则是先把上面的Activities移出栈，使用onNewIntent()复用该Activity。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式5.jpg" alt></p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>入口处Activity，例如邮件客户端的收件箱页面或者社交应用的时间轴页面。可以使用该模式。</p>
<h2 id="SingleInstance模式"><a href="#SingleInstance模式" class="headerlink" title="SingleInstance模式"></a>SingleInstance模式</h2><p>这种模式下的Activity，只能一个Activity存在于一个栈中。当启动Activity时，若不存在该Activity，创建一个新的Task栈并创建Activity放到新Task栈顶；如果存在其他Task栈有该Activity，便把该Task栈调至前台。</p>
<h3 id="表现-3"><a href="#表现-3" class="headerlink" title="表现"></a>表现</h3><p>永远都是一个Task栈存放该Activity。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式6.jpg" alt></p>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种模式很少被使用到。一些真实的使用场景是一个用于Launcher的Activity或者是那种你100%确保只有一个 Activity的应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-Activity_life_recycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-Activity_life_recycle/" class="post-title-link" itemprop="url">Activity生命周期</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h2><ol>
<li>运行状态running：Activity位于栈顶。</li>
<li>暂停状态pause：Activity失去了焦点不能交互，但仍然对用户可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕）。</li>
<li>停止状态stop：Activity被其他Activity完全遮挡，此时此Activity对用户不可见。</li>
<li>销毁状态kill：Activity由于人为或系统原因（如低内存等）被销毁。</li>
</ol>
<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p><img src="/Android-Activity_life_recycle/activity生命周期.png" alt="Activity生命周期图"></p>
<ol>
<li>onCreate()：此时Activity创建，进行初始化工作。</li>
<li>onStart()：此时的Activity变成可见了，但是还不可以交互。</li>
<li>onRestart()：此时Activity从不可见变成可见，还不可以交互。</li>
<li>onResume()：此时Activity在前台了，可见可交互。</li>
<li>onPause()：此时Activity不可以交互了，但是可以看见。</li>
<li>onStop()：此时Activity不可见。</li>
<li>onDestroy()：此时Activity被销毁。</li>
</ol>
<p>生命周期调用的例子：</p>
<ol>
<li>A启动：onCreateV()–&gt;onStart()–&gt;onResume()</li>
<li>点击home键退出A：onPause()–&gt;onStop()</li>
<li>再次回到A：onRestarrt()–&gt;onStart()–&gt;onResume()</li>
<li>对出A：onPause()–&gt;onStop()–&gt;onDestroy()</li>
<li>A跳转到B：A:onPause()–&gt;B:onCreate()–&gt;B:onStart()–&gt;B:OnResume()–&gt;A:OnStop()</li>
<li>B返回A：B:onPause()–&gt;A:onRestart()–&gt;A:onStart()–&gt;A:onResume()–&gt;B:onStop()–&gt;B:onDestroy()</li>
<li>A横竖屏切换：        onPause()–&gt;onStop()–&gt;onDestroy()–&gt;onCreate()–&gt;onStart()–&gt;onResume()</li>
</ol>
<blockquote>
<p>A切换到B时A的onStop方法在B启动后执行的原因：</p>
<ol>
<li><p>一个Activity或多或少会占有系统资源，而在官方的建议中，onPause方法将会释放掉很多系统资源，为切换Activity提供流畅性的保障，而不需要再等多两个阶段，这样做切换更快。</p>
</li>
<li><p>按照生命周期图的表示，如果用户在切换Activity的过程中再次切回原Activity，是在onPause方法后直接调用onResume方法的，这样比onPause→onStop→onRestart→onStart→onResume要快得多。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变。</p>
<p>当横竖屏切换时Activity会销毁然后重新创建。</p>
</blockquote>
<h2 id="onSaveInstanceState和onRestoreInstanceState"><a href="#onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState"></a>onSaveInstanceState和onRestoreInstanceState</h2><p>这两个方法不是生命周期中的方法，但是也和生命周期密切相关。当SDK小于3时onSaveInstanceState是在onPause方法中调用的，而大于3时是在onStop方法中调用的。<br>而onRestoreInstanceState是在onStart之后、onResume之前调用的。</p>
<p>onSaveInstanceState是用来保存状态数据，onRestoreInstanceState是用来恢复状态数据。这连个方法的调用时机是：1.系统处于内存不足的原因摧毁activity；2.一些系统设置的改变(屏幕方向，语言设置，键盘弹出等)。因为这两个方法不一定会被调用，因此不适合在该方法中保存持久化数据。</p>
<p>Activity横竖屏切换：onPause()–&gt;onSaveInstanceState()–&gt;onStop()–&gt;onDestory()–&gt;onCreate()–&gt;onStart()–&gt;onRestoreInstanceState()–&gt;onResume()。</p>
<h2 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent()"></a>onNewIntent()</h2><p>当Activity的LaunchMode为SingleTop时且Activity在栈顶，或者当Activity的LaunchMode为SingleInstance,SingleTask且Activity已经在堆栈中。那么启动该Activity时不再是使用onStart(),而是使用onNewIntent()。</p>
<p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Android-Collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Android-Collection/" class="post-title-link" itemprop="url">Android容器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Android系统中，内存对于应用的影响非常大。所以Android官方推荐在一些情况下使用优化的SparseArray、ArrayMap来替代Java的HashMap。</p>
<h3 id="1-SparseArray"><a href="#1-SparseArray" class="headerlink" title="1.SparseArray"></a>1.SparseArray</h3><p>在Android中，当数据长度小于千时，建议使用SparseArray替换HashMap。</p>
<p>SparseArray采用时间换取空间的方式，能够回收空间压缩数组，使用更少的内存来提高手机APP的运行效率，这也是其与HashMap的区别。</p>
<p>SparseArray大部分操作需要使用二分查找方法，不是直接哈希，所以效率会较慢。</p>
<p>在SparseArray内部，维护两个数组int[] mKeys和Object[] mValues。分别用于存放键和值，键只能是int类型。</p>
<p><img src="/Android-Collection/SparseArray结构.png" alt="SparseArray结构"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*put源码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找,key在mKeys列表中对应的index</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    <span class="comment">// 如果找到，说明之前put过相同的key，则直接赋值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 找不到</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// binarySearch方法中，找不到时，i取了其非，这里再次取非</span></span><br><span class="line">        i = ~i;</span><br><span class="line">        <span class="comment">// 如果有数据删除且整好是该位置，赋值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有数据被删除但不是该位置，使用gc函数回收空间，压缩压缩数组</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line">            <span class="comment">//再找一次，因为下标可能会变</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 插入数据，根据情况增长mKeys与mValues列表</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*二分查找方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*gc函数，压缩数组</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="2-ArrayMap"><a href="#2-ArrayMap" class="headerlink" title="2.ArrayMap"></a>2.ArrayMap</h3><p>与SparesArray大致相同，会进行数组压缩，在内部使用二分查找方法，用时间换取空间。</p>
<p>ArrayMap内部维护两个数组：int[] mHashes和Object[] mArray。mHashes用来存放key的哈希值，mArray用来存放键和值下标为单数用于存放key，下标为双数用于存放Value。</p>
<p><img src="/Android-Collection/ArrayMap结构.png" alt="ArrayMap结构"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*put源码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> osize = mSize;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = <span class="number">0</span>;</span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();</span><br><span class="line">        <span class="comment">// 通过二分查找寻找下标</span></span><br><span class="line">        index = indexOf(key, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index大于0表示之前put过相同的key，进行赋值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> V old = (V)mArray[index];</span><br><span class="line">        mArray[index] = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    index = ~index;</span><br><span class="line">    <span class="comment">//需要扩容的情况</span></span><br><span class="line">    <span class="keyword">if</span> (osize &gt;= mHashes.length) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = osize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (osize+(osize&gt;&gt;<span class="number">1</span>))</span><br><span class="line">            : (osize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: grow from "</span> + mHashes.length + <span class="string">" to "</span> + n);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">        <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">        allocArrays(n);  <span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">if</span> (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容后，需要把原来的数据拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: copy 0-"</span> + osize + <span class="string">" to 0"</span>);</span><br><span class="line">            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看被废弃的数组是否还有利用价值</span></span><br><span class="line">        freeArrays(ohashes, oarray, osize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这次put的key对应的hashcode排序没有排在最后（index没有指示到数组结尾），因此需要移动index后面的数据</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; osize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: move "</span> + index + <span class="string">"-"</span> + (osize-index)</span><br><span class="line">                         + <span class="string">" to "</span> + (index+<span class="number">1</span>));</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, osize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CONCURRENT_MODIFICATION_EXCEPTIONS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (osize != mSize || index &gt;= mHashes.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行存放</span></span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">    mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br><span class="line">    mSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* remove源码，对数组进行压缩在这里。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object old = mArray[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//如果数据量小于等于1，说明删除该元素后，没有数组为空，清空两个数组。</span></span><br><span class="line">    <span class="keyword">if</span> (mSize &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Now empty.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: shrink from "</span> + mHashes.length + <span class="string">" to 0"</span>);</span><br><span class="line">        <span class="comment">//put中已有说明</span></span><br><span class="line">        freeArrays(mHashes, mArray, mSize);</span><br><span class="line">        mHashes = EmptyArray.INT;</span><br><span class="line">        mArray = EmptyArray.OBJECT;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果当初申请的数组最大容纳数据个数大于BASE_SIZE的2倍（8），并且现在存储的数据量只用了申请数量的1/3，</span></span><br><span class="line">        <span class="comment">//则需要重新分配空间，已减少对内存的占用</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; (BASE_SIZE*<span class="number">2</span>) &amp;&amp; mSize &lt; mHashes.length/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// Shrunk enough to reduce size of arrays.  We don't allow it to</span></span><br><span class="line">            <span class="comment">// shrink smaller than (BASE_SIZE*2) to avoid flapping between</span></span><br><span class="line">            <span class="comment">// that and BASE_SIZE.</span></span><br><span class="line">            <span class="comment">//新数组的大小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt; (BASE_SIZE*<span class="number">2</span>) ? (mSize + (mSize&gt;&gt;<span class="number">1</span>)) : (BASE_SIZE*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: shrink from "</span> + mHashes.length + <span class="string">" to "</span> + n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">            <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">            allocArrays(n);</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="comment">//index之前的数据拷贝到新数组中</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from 0-"</span> + index + <span class="string">" to 0"</span>);</span><br><span class="line">                System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将index之后的数据拷贝到新数组中，和（index&gt;0）的分支结合，就将index位置的数据删除了</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                                 + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(ohashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(oarray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                                 (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="comment">//将index后的数据向前移位</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: move "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                                 + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(mHashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                                 (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移位后最后一个数据清空</span></span><br><span class="line">            mArray[mSize &lt;&lt; <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            mArray[(mSize &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (V)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Data_structure-Basic_structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Data_structure-Basic_structure/" class="post-title-link" itemprop="url">数据结构的存储表示</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>810</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据结构是用来形容数据之间联系是怎么样的。常见的结构有四种：</p>
<ul>
<li>集合：结构中的数据元素除了“同属于一个集合”的关系外，别无其他关系。</li>
<li>线性：结构中的数据元素存在一个对一个的关系。</li>
<li>树：结构中的数据元素存在一个对多个的关系。</li>
<li>图：结构中的数据元素存在多个对多个的关系。</li>
</ul>
<p><img src="/Data_structure-Basic_structure/数据结构.png" alt></p>
<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性结构是包含n个相同性质的数据元素的有限序列。它的基本特征是：在数据元素的非空优先集中，（1）存在唯一的“第一个元素”；（2）存在唯一的“租后一个元素”；（3）除最后一个元素之外，均有且只有一个“后继”；（4）除第一个元素之外。均有且只有一个“前驱”。</p>
<h3 id="典型的线性结构"><a href="#典型的线性结构" class="headerlink" title="典型的线性结构"></a>典型的线性结构</h3><ul>
<li><strong>栈Stack</strong>，只允许在序列末端进行操作。在栈结构中，遵循<strong>先进后出</strong>的原则。最后一个元素称为栈顶，第一个元素称为栈底，新元素进入栈称为入栈或压栈，元素的删除称为出栈或弹栈。</li>
<li><strong>队列Queue</strong>，只允许在序列两端进行操作。在队列结构中，遵循<strong>先进先出</strong>的原则。</li>
<li><strong>线性表List</strong>，允许在序列任何位置进行操作。</li>
</ul>
<h3 id="线性结构的存储表示"><a href="#线性结构的存储表示" class="headerlink" title="线性结构的存储表示"></a>线性结构的存储表示</h3><p>线性结构的存储表示主要有两种：（1）顺序存储；（2）链式存储。</p>
<p><img src="/Data_structure-Basic_structure/线性结构存储表示.png" alt></p>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>树是含有n(n&gt;=0)个节点的有限集合。在任意一颗非空树中：（1）有且只有一个特定的节点称为<strong>根</strong>root节点；（2）当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集$T_1,T_2,T_3,…,T_m$,其中每一个集合本身就是一棵树，而且称为根的<strong>子树</strong>。</p>
<h3 id="典型的树结构"><a href="#典型的树结构" class="headerlink" title="典型的树结构"></a>典型的树结构</h3><ul>
<li>二叉树：在树的定义(2)上，取m=2，便是二叉树的定义。</li>
</ul>
<h3 id="树型结构的存储表示"><a href="#树型结构的存储表示" class="headerlink" title="树型结构的存储表示"></a>树型结构的存储表示</h3><ul>
<li>二叉树中的表示方式：（1）链式表示；（2）数组表示，一般用于完全二叉树。</li>
</ul>
<p><img src="/Data_structure-Basic_structure/二叉树的链式存储表示.png" alt></p>
<p><img src="/Data_structure-Basic_structure/完全二叉树的顺序存储表示.png" alt></p>
<ul>
<li>普通树中的表示方式：（1）双亲表示法，数组表示；（2）双亲孩子表示法，数组加链表；（3）孩子兄弟表示法，链表。</li>
</ul>
<p><img src="/Data_structure-Basic_structure/树的双亲表示法.png" alt></p>
<p><img src="/Data_structure-Basic_structure/树的双亲孩子表示法.png" alt></p>
<p><img src="/Data_structure-Basic_structure/树的孩子兄弟表示法.png" alt></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>图结构中，允许任何元素都可以有联系，存在多对多的关系。</p>
<h3 id="图结构的存储表示"><a href="#图结构的存储表示" class="headerlink" title="图结构的存储表示"></a>图结构的存储表示</h3><p>图的主要存储表示有两种：（1）邻接矩阵，数组加二维数组；（2）邻接表，数组加链表。</p>
<p><img src="/Data_structure-Basic_structure/图的邻接矩阵和邻接链表存储表示.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Design_patterns-Singleton_mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Design_patterns-Singleton_mode/" class="post-title-link" itemprop="url">单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-10-26 00:00:00" itemprop="dateModified" datetime="2018-10-26T00:00:00+08:00">2018-10-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>作用：保证一个类仅有一个实例，并提供一个访问他的全局访问点。</li>
<li>主要解决：一个全局使用的类频繁创建与销毁。</li>
<li>关键代码：1.构造函数私有化。2.多线程访问时线程安全。</li>
</ul>
<p>单例模式由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。此外，还可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式。</p>
<h2 id="单例模式写法"><a href="#单例模式写法" class="headerlink" title="单例模式写法"></a>单例模式写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>利用了JVM类加载机制，保证单例只会被创建1次，即线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态常量方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载该类时，单例就会自动被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test(); <span class="comment">//静态常量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码块方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Test test ；</span><br><span class="line">    <span class="comment">//加载该类时，单例就会自动被创建</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	test = <span class="keyword">new</span> Test(); <span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：写法简单、线程安全。</p>
<p>缺点：在类加载的时候就完成实例化，没有达到延时加载效果。如果至始至终没有使用过这个实例，则会造成内存浪费。</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>对饿汉模式进行延时加载，当要使用时才会去创建类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程不安全方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程安全方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="comment">//使用synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：做到了延时加载。</p>
<p>缺点：线程安全的时候效率太低。每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p>
<h3 id="双重检查模式"><a href="#双重检查模式" class="headerlink" title="双重检查模式"></a>双重检查模式</h3><p>对懒汉模式的进一步改进，线程安全同时避免过多的同步开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DCL模式(双重检查模式)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用volatile禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="comment">//双重判定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全、延时加载、效率较高。</p>
<p>缺点：代码不简洁。</p>
<h3 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TestHolder.test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用过程说明：</span></span><br><span class="line">      <span class="comment">// 1. 外部调用类的getInstance() </span></span><br><span class="line">      <span class="comment">// 2. 自动调用TestHolder.test</span></span><br><span class="line">       <span class="comment">// 2.1 此时单例类TestHolder得到初始化</span></span><br><span class="line">       <span class="comment">// 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例；</span></span><br><span class="line">       <span class="comment">// 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性</span></span><br><span class="line">      <span class="comment">// 3. 最终只创建1个单例</span></span><br></pre></td></tr></table></figure>

<p>优点：线程安全、延时加载、效率高，代码简洁。</p>
<h3 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h3><p>利用了枚举类的特点实现单例：</p>
<ol>
<li>枚举类型–&gt;不可被继承的类(final)</li>
<li>每个枚举元素–&gt;类静态常量</li>
<li>构造方法私有</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Test&#123;</span><br><span class="line">    <span class="comment">//定义一个枚举元素，是单例的一个实例</span></span><br><span class="line">    INSTANCE ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例的方式：</span></span><br><span class="line">Test test = Test.INSTANCE;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全、线程安全，代码非常简洁。</p>
<p>缺点：没有延时加载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://junzkn.github.io/Design_patterns-Strategy_mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never And Ever">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Design_patterns-Strategy_mode/" class="post-title-link" itemprop="url">策略模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-10-26 00:00:00" itemprop="dateModified" datetime="2018-10-26T00:00:00+08:00">2018-10-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>949</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<p>上面这句话是策略模式的官方定义。策略模式的作用就是将策略(算法)和具体类解耦，让具体类更换不同策略算法时能够更加便捷。UML图如下：</p>
<p><img src="/Design_patterns-Strategy_mode/策略模式UML.png" alt="策略模式UML"></p>
<p>图中，Context表示具体类，他有不同策略接口的引用，内部调用的是策略实现类的方法。当我们实现不同策略后，将侧策略添加到具体类中，具体类便会有不同的反应。</p>
<ul>
<li><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
</li>
<li><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Context类，具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="comment">//持有策略引用</span></span><br><span class="line">    <span class="keyword">private</span> StrategyA strategyA;</span><br><span class="line">    <span class="keyword">private</span> StrategyB strategyB;</span><br><span class="line">    <span class="comment">//设置策略的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetStrategyA</span><span class="params">(StrategyA strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategyA=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetStrategyB</span><span class="params">(StrategyB strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategyB=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用策略中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategyA.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategyB.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> class StrategyB </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承策略接口，实现具体策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">StrategyA</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">StrategyB</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jun"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junzkn</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
