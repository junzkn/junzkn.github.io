<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>problem</title>
    <url>/problem/</url>
    <content><![CDATA[<h3 id="关于gradle构建慢"><a href="#关于gradle构建慢" class="headerlink" title="关于gradle构建慢"></a>关于gradle构建慢</h3><p>最近在run应用时候特别慢，每一次几乎都是3-4分钟。看了一下是build时候<code>transformclasseswithdexfordebug</code>这个步骤拖慢的。最后在<a href="https://stackoverflow.com/questions/34158995/gradle-build-slow-on-transformclasseswithdexfordebug" target="_blank" rel="noopener">这里</a>找到了解决方法，在build.gradle文件中设置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    multiDexEnabled <span class="literal">true</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dexOptions &#123;</span><br><span class="line">    preDexLibraries <span class="literal">true</span></span><br><span class="line">    javaMaxHeapSize <span class="string">"4g"</span> <span class="comment">// Use gig increments depending on needs</span></span><br><span class="line">    incremental <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="找不到android库"><a href="#找不到android库" class="headerlink" title="找不到android库"></a>找不到android库</h3><p>新拉的项目build时候出现如下错误：</p>
<p><img src="/problem/1.PNG" alt="捕获"></p>
<p>错误是指找不到android supprot库。在项目buid.gradle配置中的仓库把<code>google()</code>放到前面</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()  <span class="comment">//把google的仓库放到第一个</span></span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            dirs <span class="string">'libs'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="找不到对应NDK"><a href="#找不到对应NDK" class="headerlink" title="找不到对应NDK"></a>找不到对应NDK</h3><p>在重构旧项目时，拉下项目后build出现了找不到对应NDK版本如下：</p>
<p><code>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</code>。这个错误时因为AS3.0以上开发环境导致的，解决方法有两个：</p>
<ol>
<li>从<a href="https://developer.android.com/ndk/downloads/?hl=zh-cn" target="_blank" rel="noopener">官网</a>上下载16版本的NDK，在toolchains文件夹找到缺失的NDK，弄到本地就行。</li>
<li>改变gradle plugin版本，这个还需要同时改变gradle版本，因为需要对应。不建议改到最新的gradle plugin版本，可能会出现资源整合错误，这个错误需要一个一个文件改成该版本格式。</li>
</ol>
<h3 id="AndroidStudio常用操作"><a href="#AndroidStudio常用操作" class="headerlink" title="AndroidStudio常用操作"></a>AndroidStudio常用操作</h3><p><code>ctrl+F</code>文件内全文件搜索字段</p>
<p><code>ctrl+shift+F</code>路径内全路径搜索字段</p>
<p><code>ctrl+N</code>全局找类名</p>
<p><code>ctrl+shift+N</code>全局找文件</p>
<p><code>shift+shift</code> search everywhere</p>
<p>点击文件再<code>ctrl+D</code>对比文件</p>
<h3 id="设置Activity半透明覆盖于之前Activity上"><a href="#设置Activity半透明覆盖于之前Activity上" class="headerlink" title="设置Activity半透明覆盖于之前Activity上"></a>设置Activity半透明覆盖于之前Activity上</h3><h3 id="关于Glide缓存导致图片资源出错"><a href="#关于Glide缓存导致图片资源出错" class="headerlink" title="关于Glide缓存导致图片资源出错"></a>关于Glide缓存导致图片资源出错</h3><h3 id="圆角图片"><a href="#圆角图片" class="headerlink" title="圆角图片"></a>圆角图片</h3><h2 id="drawable中的selector-shape等"><a href="#drawable中的selector-shape等" class="headerlink" title="drawable中的selector,shape等"></a>drawable中的selector,shape等</h2><h3 id="沉浸式状态栏"><a href="#沉浸式状态栏" class="headerlink" title="沉浸式状态栏"></a>沉浸式状态栏</h3>]]></content>
  </entry>
  <entry>
    <title>Android动画</title>
    <url>/Android-Animation/</url>
    <content><![CDATA[<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>Android中的动画分为两大类：View Animation视图动画和Property Animation属性动画。其中视图动画包括Tween Animation补间动画和Frame Animation帧动画。</p>
<h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><ul>
<li>作用对象：视图控件View。</li>
<li>大致原理：将预先准备好的每一帧播放出来，达到动画效果。</li>
<li>特点：<ul>
<li>优点：使用简单方便。</li>
<li>缺点：可能因为图片的数量或大小会引起OOM。</li>
</ul>
</li>
<li>应用场景：难以代码实现的动画，UI作图我们使用便可。</li>
</ul>
<h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><ul>
<li>作用对象：视图控件View。</li>
<li>大致原理：通过确定开始和结束的样式，中间的状态变化过程由系统补全。插值器可以改变变化速率但改变不了变化状态。</li>
<li>优缺点：<ul>
<li>优点：使用简单方便，有封装好的动画效果。</li>
<li>缺点：没法改变属性，缺乏整体效果控制。</li>
</ul>
</li>
<li>应用场景：<ul>
<li>标准动画：平移、旋转、缩放、透明度。</li>
<li>Activity和Fragment的转场切换效果。</li>
<li>ViewGroup中子元素的出场效果。</li>
</ul>
</li>
</ul>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><ul>
<li>作用对象：任意对象，不局限于View。</li>
<li>大致原理：在一定时间内，通过不断改变数值，给对象的属性设置来达到效果。变化速率可以使用插值器控制，变化效果我们可以手动控制或者使用估值器。</li>
<li>优缺点：<ul>
<li>优点：相比原有的动画扩充了许多，而且不止可以作用于View。</li>
<li>缺点：实现简单的可以使用封装过类，要实现复杂的动画操作起来比较麻烦。</li>
</ul>
</li>
<li>应用场景：需要改变View属性的动画、复杂动画、路径动画等。</li>
</ul>
<h2 id="帧动画-Frame-Animation"><a href="#帧动画-Frame-Animation" class="headerlink" title="帧动画(Frame Animation)"></a>帧动画(Frame Animation)</h2><p>帧动画，就是逐帧播放图片，每一帧都是从资源文件中获取帧，而不是通过系统绘制。因为是获取每一帧图片去播放，所以使用的时候就要注意避免大尺寸鱼片，以免造成OOM。</p>
<h3 id="xml实现帧动画"><a href="#xml实现帧动画" class="headerlink" title="xml实现帧动画"></a>xml实现帧动画</h3><p>先在res/anim下写xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:oneshot</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img0"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img1"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img2"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img3"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img4"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/img5"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    //这里就展示几个item就好了 都是一样的显示时间就不重复贴了</span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们可以在xml文件中对ImageView的android:src/android:background属性直接设置使用或者在代码中设置也是一样的效果的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/iv"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:background</span>=<span class="string">"@drawable/frame_anim"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中开始动画：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过设置android:background时，得到AnimationDrawable 用如下方法</span></span><br><span class="line"><span class="keyword">final</span> AnimationDrawable animationDrawable = (AnimationDrawable) iv.getBackground();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过设置android:src时，得到AnimationDrawable 用如下方法</span></span><br><span class="line"><span class="comment">//AnimationDrawable animationDrawable = (AnimationDrawable) iv.getDrawable();</span></span><br><span class="line"></span><br><span class="line">animationDrawable.start() ;</span><br></pre></td></tr></table></figure>



<h3 id="代码实现帧动画"><a href="#代码实现帧动画" class="headerlink" title="代码实现帧动画"></a>代码实现帧动画</h3><p>先说一下AnimatedVectorDrawable这个类，这个类是用来创建逐帧动画的，有对应的方法来控制帧动画的各种操作。AnimatedVectorDrawable 与它类似，不过是矢量图的，通常与属性动画一起使用。</p>
<p>AnimatedVectorDrawable的常用方法：</p>
<ul>
<li>void start()：开始播放逐帧动画。</li>
<li>void stop()：停止播放逐帧动画。</li>
<li>int getDuration(int index)：得到指定index的帧的持续时间。</li>
<li>Drawable getFrame(int index)：得到指定index的帧所对应的Drawable对象。</li>
<li>int getNumberOfFrames()：得到当前AnimationDrawable的所有帧数量。</li>
<li>boolean isRunning()：判断当前AnimationDrawable是否正在播放。</li>
<li>void setOneShot(boolean oneShot)：设置AnimationDrawable是否执行一次，返true表示执行一次，返回false表示循环播放。</li>
<li>boolean isOneShot()：判断当前AnimationDrawable是否执行一次，返true表示执行一次，返回false表示循环播放。</li>
<li>void addFrame(Drawable frame,int duration)：为AnimationDrawable添加1帧，并设置持续时间。</li>
</ul>
<p>我们在代码中实现帧动画就是使用addFrame来进行动画的初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationDrawable animationDrawable = <span class="keyword">new</span> AnimationDrawable();</span><br><span class="line">animationDrawable.setOneShot(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">83</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = getResources().getIdentifier(<span class="string">"img"</span> + i, <span class="string">"drawable"</span>, getPackageName());</span><br><span class="line">    Drawable drawable = getResources().getDrawable(id);</span><br><span class="line">    animationDrawable.addFrame(drawable, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">iv.setBackground(animationDrawable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意：在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次</span></span><br><span class="line">animationDrawable.stop();</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure>

<p>这里我们使用到了<code>getIdentifier</code>方法来进行对应资源获取，它的第一个参数就是文件名，第二个参数是资源所在的文件类型，第三个参数就是包名。</p>
<h2 id="补间动画-Tween-Animation"><a href="#补间动画-Tween-Animation" class="headerlink" title="补间动画(Tween Animation)"></a>补间动画(Tween Animation)</h2><p>视图动画有5种类型：alpha(透明度)、scale(缩放)、translate(平移)、rotate(旋转)、set(动画组合)。</p>
<ul>
<li>alpha：渐变透明效果。</li>
<li>scale：渐变尺寸伸缩效果。</li>
<li>translate：位置移动效果。</li>
<li>rotate：旋转效果。</li>
<li>set：多种动画集合。</li>
</ul>
<p>视图动画的实现方可以使用xml文件，也可以直接在代码中实现。</p>
<h3 id="xml文件实现补间动画"><a href="#xml文件实现补间动画" class="headerlink" title="xml文件实现补间动画"></a>xml文件实现补间动画</h3><p>下面是一个scale动画的xml实现，先在res/anim下写xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version ="1.0" encoding ="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromXScale</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toXScale</span>=<span class="string">"1.4"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromYScale</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toYScale</span>=<span class="string">"2.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:duration</span>=<span class="string">"700"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再在代码中使用该xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(context,R.anim.scaleanimation) ; <span class="comment">//加载xml动画</span></span><br><span class="line">mView.startAnimation(animation); <span class="comment">//开始播放</span></span><br></pre></td></tr></table></figure>

<p>下面是set动画集合的xml实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version ="1.0" encoding ="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:duration</span>=<span class="string">"700"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromAlpha</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:toAlpha</span>=<span class="string">"1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fromDegrees</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:toDegrees</span>=<span class="string">"720"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotX</span>=<span class="string">"50"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotY</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="各类型动画的属性"><a href="#各类型动画的属性" class="headerlink" title="各类型动画的属性"></a>各类型动画的属性</h3><p>在上面的xml中我们可以看到，scale有自己的属性fromXScale，也有继承自Animation的属性duration。下面分别介绍各类型的各种属性。</p>
<h4 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale(缩放)"></a>scale(缩放)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromXScale</td>
<td align="center">动画起始时，控件在X轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">fromYScale</td>
<td align="center">动画起始时，控件在Y轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">toXScale</td>
<td align="center">动画结束时，控件在X轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">toYScale</td>
<td align="center">动画结束时，控件在Y轴方向上相对自身的缩放比例，浮点值</td>
</tr>
<tr>
<td align="center">pivotX</td>
<td align="center">缩放起始点X轴坐标，可以是数值、百分数、百分数p三种样式</td>
</tr>
<tr>
<td align="center">pivotY</td>
<td align="center">缩放起始点Y轴坐标，可以是数值、百分数、百分数p三种样式</td>
</tr>
</tbody></table>
<p>fromXScale和toXScale中：1.0代表自身无变化，0.5代表缩小1倍，2.0代表放大1倍。</p>
<p>pivotX中：如果是数值，表示在当前视图的左上角，即原点处加上50px，作为缩放起始点X轴坐标；如果是50%，则表示在当前控件的左上角加上自己宽度的50%作为缩放起始点X轴坐标；如果是50%p ，则表示在当前控件的左上角加上父控件宽度的50%作为缩放起始点X轴坐标。pivotX影响的只是动画的起始位置，结束位置始终是不会变的。</p>
<h4 id="alpha-透明度"><a href="#alpha-透明度" class="headerlink" title="alpha(透明度)"></a>alpha(透明度)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromAlpha</td>
<td align="center">动画开始时的透明度，取值范围为0.0~1 .0, 表示全透明,1.0 表示完全不透明。</td>
</tr>
<tr>
<td align="center">toAlpha</td>
<td align="center">动画结束时的透明度，取值范围为0.0~1 .0, 表示全透明,1.0 表示完全不透明。</td>
</tr>
</tbody></table>
<h4 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate(旋转)"></a>rotate(旋转)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromDegrees</td>
<td align="center">动画开始旋转时的角度位置，正值代表顺时针方向的度数，负值 代表逆时针方向的度数</td>
</tr>
<tr>
<td align="center">toDegrees</td>
<td align="center">动画结束时旋转到的角度位置，正值代表顺时针方向的度数，负值 代表逆时针方向的度数</td>
</tr>
<tr>
<td align="center">pivotX</td>
<td align="center">旋转中心点X轴坐标，默认旋转中心点是控件坐标原点。可以是数值、百分数、百分数p</td>
</tr>
<tr>
<td align="center">pivotY</td>
<td align="center">旋转中心点Y轴坐标，默认旋转中心点是控件坐标原点。可以是数值、百分数、百分数p</td>
</tr>
</tbody></table>
<h4 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate(平移)"></a>translate(平移)</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fromXDelta</td>
<td align="center">起始点X轴坐标，可以是数值、百分数、百分数p</td>
</tr>
<tr>
<td align="center">fromYDelta</td>
<td align="center">起始点Y轴坐标，可以是数值、百分数、百分数p</td>
</tr>
<tr>
<td align="center">toXDelta</td>
<td align="center">终点X轴坐标</td>
</tr>
<tr>
<td align="center">to YDelta</td>
<td align="center">终点Y轴坐标</td>
</tr>
</tbody></table>
<h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p>Animation的下面这几个属性是全部类型的动画都有的，因为其他都是继承自Animation</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">duration</td>
<td align="center">用于设置完成一次动画的持续时间，以毫秒为单位</td>
</tr>
<tr>
<td align="center">fillAfter</td>
<td align="center">如果设置为true，控件动画结束时，将保持动画结束时的状态</td>
</tr>
<tr>
<td align="center">fillBefore</td>
<td align="center">如果设置为 true ，则控件动画结束时，将还原到初始化状态</td>
</tr>
<tr>
<td align="center">fillEnable</td>
<td align="center">与fillBefore一样</td>
</tr>
<tr>
<td align="center">repeatCount</td>
<td align="center">用于指定动画的重复次数，当取值为infinite时，表示无限循环</td>
</tr>
<tr>
<td align="center">repeatMode</td>
<td align="center">用于设定重复的类型，有reverse和restart两种值。reverse表示倒序回放，restart表示重放。必须与repeatCount一起使用。</td>
</tr>
<tr>
<td align="center">interpolator</td>
<td align="center">用于设定插器，插值器用于指定动画效果</td>
</tr>
</tbody></table>
<p>注意：在 set 标签中设直 repeateCount 属性是无效的，必须对每个动画单独设直才有作用。</p>
<p>插值器是用来计算时间变化的，计算出来的值表示当前时间对应动画进度百分比。</p>
<h3 id="代码实现视图动画"><a href="#代码实现视图动画" class="headerlink" title="代码实现视图动画"></a>代码实现视图动画</h3><p>视图动画每个类型会有对应的类。scale、rotate、alpha和translate的属性都会在对应类的构造函数中传参，set的属性需要使用对应的setXXX()方法。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">scale</td>
<td align="center">ScaleAnimation</td>
</tr>
<tr>
<td align="center">alpha</td>
<td align="center">AlphaAnimation</td>
</tr>
<tr>
<td align="center">rotate</td>
<td align="center">RotateAnimation</td>
</tr>
<tr>
<td align="center">translate</td>
<td align="center">TranslateAnimation</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">AnimationSet</td>
</tr>
</tbody></table>
<p>下面示例set的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation alpha = <span class="keyword">new</span> AlphaAnimation(<span class="number">1.0f</span>,<span class="number">0.1f</span>) ;  <span class="comment">//alpha动画</span></span><br><span class="line">Animation scale = <span class="keyword">new</span> ScaleAnimation(<span class="number">0.0f</span>,<span class="number">1.4f</span>,<span class="number">0.0f</span>,<span class="number">1.4f</span>); <span class="comment">//scale动画</span></span><br><span class="line"></span><br><span class="line">AnimationSet set = <span class="keyword">new</span> AnimationSet(<span class="keyword">true</span>) ; <span class="comment">//表示集合里面的动画共用同一个插值器</span></span><br><span class="line">set.addAnimation(alpha); <span class="comment">//添加动画</span></span><br><span class="line">set.addAnimation(scale);</span><br><span class="line">set.setDuration(<span class="number">700</span>);</span><br><span class="line">set.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mView.startAnimation(set); <span class="comment">//播放动画集合</span></span><br></pre></td></tr></table></figure>

<p>属性动画可设置动画的监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation alpha = <span class="keyword">new</span> AlphaAnimation(<span class="number">1.0f</span>,<span class="number">0.1f</span>) ;  <span class="comment">//alpha动画</span></span><br><span class="line">alpha.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画开始时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画结束时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画重复播放时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="补间动画的特殊应用场景"><a href="#补间动画的特殊应用场景" class="headerlink" title="补间动画的特殊应用场景"></a>补间动画的特殊应用场景</h3><p>在Android中有些地方对补间动画进行了封装，可以使用特定API或者在xml配置特定参数实现动画效果。特殊的场景有许多，例如Activity的切换动画、Fragment的切换动画、ViewGroup中子元素的出场效果(ListView)。</p>
<h4 id="Activity的切换动画"><a href="#Activity的切换动画" class="headerlink" title="Activity的切换动画"></a>Activity的切换动画</h4><p>启动的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent (<span class="keyword">this</span>,Acvtivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivity(intent);</span><br><span class="line">overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</span><br><span class="line"><span class="comment">// enterAnim：从Activity a跳转到Activity b，进入b时的动画效果资源Id</span></span><br><span class="line"><span class="comment">// exitAnim：从Activity a跳转到Activity b，离开a时的动画效果资源Id</span></span><br><span class="line"><span class="comment">// 特别注意overridePendingTransition()必须要在startActivity(intent)后被调用才能生效</span></span><br></pre></td></tr></table></figure>

<p>退场动画：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.finish();</span><br><span class="line">    overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</span><br><span class="line">    <span class="comment">// enterAnim：从Activity a跳转到Activity b，进入b时的动画效果资源Id</span></span><br><span class="line">    <span class="comment">// exitAnim：从Activity a跳转到Activity b，离开a时的动画效果资源Id</span></span><br><span class="line">    <span class="comment">// 特别注意 overridePendingTransition()必须要在finish()后被调用才能生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于参数 enterAnim &amp; exitAnim 的资源ID，系统有自带的效果android.R.anim.xxx，也可以自己设置动画xml。自己设置的xml就是补间动画的xml，里面可以是alpha、scale、translate、rotate和set。</p>
<h4 id="Fragment的切换动画"><a href="#Fragment的切换动画" class="headerlink" title="Fragment的切换动画"></a>Fragment的切换动画</h4><p>使用系统自带的切换效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">fragmentTransaction.setTransition(<span class="keyword">int</span> transit);</span><br><span class="line"><span class="comment">// 通过setTransition(int transit)进行设置</span></span><br><span class="line"><span class="comment">// 标准动画设置好后，在Fragment添加和移除的时候都会有。</span></span><br></pre></td></tr></table></figure>

<p>自定义动画效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">fragmentTransaction.setCustomAnimations(R.anim.in_from_right,R.anim.out_to_left);</span><br><span class="line"><span class="comment">// in_from_right：从Fragment a跳转到Fragment b，进入b时的动画效果资源Id</span></span><br><span class="line"><span class="comment">// out_to_left：从Fragment a跳转到Fragment b，离开a时的动画效果资源Id</span></span><br></pre></td></tr></table></figure>

<h4 id="ListView的子元素出场动画"><a href="#ListView的子元素出场动画" class="headerlink" title="ListView的子元素出场动画"></a>ListView的子元素出场动画</h4><p>先在ListView的xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/lv"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layoutAnimation</span>=<span class="string">"@anim/anim_layout"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>layoutAnimation设置为我们自定义的anim_layout，然后新建anim_layout：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:delay</span>=<span class="string">"0.5"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:animation</span>=<span class="string">"@anim/view_animation"</span></span></span><br><span class="line"><span class="tag">                 /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">delay:子元素开始动画的时间延迟</span></span><br><span class="line"><span class="comment">animationOrder:表示子元素动画的顺序</span></span><br><span class="line"><span class="comment">animation:自定义的补间动画</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="属性动画-Property-Animation"><a href="#属性动画-Property-Animation" class="headerlink" title="属性动画(Property Animation)"></a>属性动画(Property Animation)</h2><p>属性动画不同于视图动画，视图动画能够实现移动、旋转、拉伸和透明等效果，但是如果想要让颜色做动画渐变就实现不了了。属性动画是通过改变控件的某一个属性来做动画的，可以实现颜色等不同效果。并且是因为属性的改变，所以控件执行动画后的单击区域问题也就不像补间动画那样不能点击。</p>
<p>补间动画的命名都是XXXAnimation，而属性动画则是XXXAnimator。</p>
<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator，他是一个数值变化监听器，不会对控件做任何操作。我们通过给它设定从哪个值运动到哪个值，然后监听值的变化，给对应控件的对应属性设置，从而实现动画。</p>
<p>与Scroller原理类似，Scroller类也是不会对控件执行任何操作的，而是通过设定滚动值和时长来自己计算被动过程的。</p>
<p>ValueAnimator初步使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个int类型变化监听的ValueAnimator</span></span><br><span class="line">ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">400</span>) ;</span><br><span class="line">animator.setDuration(<span class="number">2000</span>) ;</span><br><span class="line">animator.setSatrtDelay(<span class="number">1000</span>); <span class="comment">//延时1</span></span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getAnimatedValue获取当前值</span></span><br><span class="line">        <span class="keyword">int</span> curValue = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">        <span class="comment">//改变属性</span></span><br><span class="line">        mView.layout(curValue,curValue,</span><br><span class="line">                     curValue+mView.getWidth(),curValue+mView.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动动画</span></span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>除了可以设置AnimatorUpdateListener这个监听器监听实时值变化外，还可以设置AnimatorListener来监听动画状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">animator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画取消</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画重复时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在上面使用的是<code>ValueAnimator.ofInt(int... values)</code>来创建ValueAnimator，与他相似的方法是<code>ValueAnimator.ofFloat(float... values)</code>。他们两个都能传入变长参数，第一个是初始值，最后一个是结束值，中间可以插入若干个中间值。</p>
<p>还有一个方法是<code>ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values)</code>，这个方法表前面的ofInt和ofFloat多了一个TypeEvaluator类型的参数，这个就是估值器。因为int类型和float类型系统会使用默认的估值器，而Object的话系统不知道该如何估值，需要我们自定义估计值。</p>
<p>这里说一下插值器和估值器。插值器和补间动画的插值器是一样的，用来计算时间变化的，计算出来的值表示当前时间对应动画进度百分比。而估值器，插值器算出1000毫秒的时候值为0.2，那么这个0.2再通过估值器转化，转化成对应的你要的属性，你可以根据这个百分比设置对应颜色之类的。上面代码中的<code>animation.getAnimatedValue()</code>获得的值是经过估值器计算后的值。</p>
<p>ValueAnimator的流程图如下：</p>
<p><img src="/Android-Animation/属性动画流程图.png" alt="属性动画流程图"></p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator，重写了ofInt和odFloat等几个方法，让我们使用起来更加方便。例如我们需要一个透明度的动画：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator = ObbjectAnimator.ofFloat(mView,<span class="string">"alpha"</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>在上面，</p>
<h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><h2 id="各动画源码分析"><a href="#各动画源码分析" class="headerlink" title="各动画源码分析"></a>各动画源码分析</h2><h3 id="帧动画-1"><a href="#帧动画-1" class="headerlink" title="帧动画"></a>帧动画</h3><h3 id="补间动画-1"><a href="#补间动画-1" class="headerlink" title="补间动画"></a>补间动画</h3><p>属性动画的基本使用在上面已经说明，接着来看这个动画是如何播放的。不论是xml实现还是代码实现，最后都要调用<code>startAnimation()</code>方法进行动画播放，先从这里入手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    animation.setStartTime(Animation.START_ON_FIRST_FRAME);  <span class="comment">//-----1-----</span></span><br><span class="line">    setAnimation(animation);  <span class="comment">//-----2-----</span></span><br><span class="line">    invalidateParentCaches(); <span class="comment">//----3----</span></span><br><span class="line">    invalidate(<span class="keyword">true</span>); <span class="comment">//----4----</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不多，只有四个方法。第一个是对一些变量进行赋值；第二个主要把动画和当前View绑定；</p>
<p>第三个方法<code>invalidateParentCaches</code>在View的滑动中的Scroll中有说到，是用来改变标志从而令ViewGroup发生重绘。</p>
<p>第四个就是常用到的<code>invalidate</code>方法，用于刷新view自身。</p>
<p><code>invalidateParentCaches</code>方法也比较熟悉，它对于绘制的主要致步骤如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    drawBackground(canvas);</span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    onDraw(canvas);            </span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatchDraw</code>中遍历子View绘制子View：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">                <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">                transientIndex++;</span><br><span class="line">                <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                    transientIndex = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">            <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</span><br><span class="line">                ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);   <span class="comment">//------1-----</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处便是对子view调用drawChild(canvas, child, drawingTime)，这里要区别一下，这个调用的是带有三个参数的draw()，不是一个参数的draw()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">        Transformation transformToApply = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> concatMatrix = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> scalingRequired = mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mScalingRequired;</span><br><span class="line">    <span class="keyword">final</span> Animation a = getAnimation();<span class="comment">//获取动画</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);<span class="comment">//-----1----</span></span><br><span class="line">        concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">        <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取的Transformation对象，包含动画矩阵</span></span><br><span class="line">        <span class="comment">//-----2----</span></span><br><span class="line">        transformToApply = parent.getChildTransformation();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">        <span class="keyword">if</span> (!drawingWithRenderNode || transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//-------3.1------</span></span><br><span class="line">            <span class="comment">//保存该canvas</span></span><br><span class="line">            restoreTo = canvas.save();</span><br><span class="line">        &#125;</span><br><span class="line">    ..........</span><br><span class="line">        <span class="keyword">if</span> (transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ..........</span><br><span class="line">                <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">                        <span class="comment">//----4.0----</span></span><br><span class="line">                        renderNode.setAnimationMatrix(transformToApply.getMatrix());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//-------4.1-----</span></span><br><span class="line">                        canvas.translate(-transX, -transY);</span><br><span class="line">                        canvas.concat(transformToApply.getMatrix());<span class="comment">//为该canvas画布应用了该动画矩阵</span></span><br><span class="line">                        canvas.translate(transX, transY);</span><br><span class="line">                        <span class="comment">//------4.1----</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> transformAlpha = transformToApply.getAlpha();</span><br><span class="line">            <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                alpha *= transformAlpha;</span><br><span class="line">                parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span> (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) &#123;</span><br><span class="line">            <span class="comment">//------4.2-----</span></span><br><span class="line">        	canvas.translate(-transX, -transY);</span><br><span class="line">        	canvas.concat(getMatrix());</span><br><span class="line">        	canvas.translate(transX, transY);</span><br><span class="line">            <span class="comment">//------4.2-----</span></span><br><span class="line">    	&#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line">..........</span><br><span class="line">    <span class="keyword">if</span> (restoreTo &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//恢复到之前状态的canvas，所以并不会影响到其它子view的绘制，即使他们使用的都是viewgroup传递下来的画布</span></span><br><span class="line">         <span class="comment">//-------3.2------</span></span><br><span class="line">        canvas.restoreToCount(restoreTo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释2处，Transformation对象中包含一个矩阵和alph值，矩阵是用来做平移、旋转和缩放动画的。</p>
<p>从3.1和3.2可以看出，每绘制一个子view，都会先对画布状态进行保存save()，然后绘制完该子view之后。又会恢复restore()，所以如果在任何一个子view的onDraw(canvas)对canvas进行操作都不会影响到所在的viewgroup和同级的其他子view。</p>
<p>从4.1和4.2看出，我们的视图动画都没有都View进行改变，改变的只是canvas或renderNode。</p>
<p>动画的关键还是在注释1处的<code>applyLegacyAnimation</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyLegacyAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</span><br><span class="line">    Transformation invalidationTransform;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        <span class="comment">//------1------</span></span><br><span class="line">        a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</span><br><span class="line">        <span class="comment">//------2------</span></span><br><span class="line">        a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) a.setListenerHandler(mAttachInfo.mHandler);</span><br><span class="line">        onAnimationStart(); <span class="comment">//---熟悉的视图动画的回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Transformation t = parent.getChildTransformation();</span><br><span class="line">    <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);  <span class="comment">//------3-----</span></span><br><span class="line">    <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</span><br><span class="line">        &#125;</span><br><span class="line">        invalidationTransform = parent.mInvalidationTransformation;</span><br><span class="line">        a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        invalidationTransform = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.willChangeBounds()) &#123; <span class="comment">//--------4------</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==</span><br><span class="line">                ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">                parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == <span class="number">0</span>) &#123;</span><br><span class="line">                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                <span class="comment">//------7-----</span></span><br><span class="line">                parent.invalidate(mLeft, mTop, mRight, mBottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//------5-------</span></span><br><span class="line">            <span class="keyword">if</span> (parent.mInvalidateRegion == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.mInvalidateRegion = <span class="keyword">new</span> RectF();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> RectF region = parent.mInvalidateRegion;</span><br><span class="line">            a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</span><br><span class="line">                  invalidationTransform);</span><br><span class="line">            parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft + (<span class="keyword">int</span>) region.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop + (<span class="keyword">int</span>) region.top;</span><br><span class="line">            <span class="comment">//-----7------</span></span><br><span class="line">            parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</span><br><span class="line">                              top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处，初始化Animation（仅初始化一次）调用Animation.initialize(width, height, parentWidth, parentHeight)，通过View及ParentView的Size来解析Animation中的相关数据。</p>
<p>注释2处，调用Animation.initializeInvalidateRegion(left, top, right, bottom)来设定动画的初始区域，并在fillBefore为true时计算Animation动画进度为0.0f的数据。</p>
<p>注释3处，调用getTransformation根据当前绘制事件生成Animation中对应帧的动画数据。</p>
<p>处理完前三步后，接着是根据动画数据设定重绘制区域：</p>
<p>若为若仅为Alpha动画，注释4，此时动画区域为View的当前区域，且不会产生变化；若包含非Alpha动画，注释5，此时动画区域需要调用<code>Animation.getInvalidateRegion</code>进行计算，该函数会根据上述生成动画数据Thransformation中的Matrix进行计算，并与之前的动画区域执行unio操作，从而获取动画的完整区域。</p>
<p>最后，都通过注释7处，调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域。</p>
<p>我们还要看一下注释3的<code>getTransformation</code>里面是怎么样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartTime == -<span class="number">1</span>) &#123;</span><br><span class="line">        mStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startOffset = getStartOffset();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> duration = mDuration;</span><br><span class="line">    <span class="keyword">float</span> normalizedTime;</span><br><span class="line">    <span class="keyword">if</span> (duration != <span class="number">0</span>) &#123;</span><br><span class="line">        normalizedTime = ((<span class="keyword">float</span>) (currentTime - (mStartTime + startOffset))) /</span><br><span class="line">            (<span class="keyword">float</span>) duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        normalizedTime = currentTime &lt; mStartTime ? <span class="number">0.0f</span> : <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> expired = normalizedTime &gt;= <span class="number">1.0f</span> || isCanceled();</span><br><span class="line">    mMore = !expired;</span><br><span class="line">    <span class="keyword">if</span> (!mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">if</span> ((normalizedTime &gt;= <span class="number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="number">1.0f</span> || mFillAfter)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">            fireAnimationStart();</span><br><span class="line">            mStarted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (NoImagePreloadHolder.USE_CLOSEGUARD) &#123;</span><br><span class="line">                guard.open(<span class="string">"cancel or detach or getTransformation"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCycleFlip) &#123;</span><br><span class="line">            normalizedTime = <span class="number">1.0f</span> - normalizedTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">        <span class="comment">//------1------</span></span><br><span class="line">        applyTransformation(interpolatedTime, outTransformation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法我们可以看到，会通过duration和插值器来计算时间，最后通过注释1处的<code>applyTransformation</code>来绘制每一帧动画。<code>applyTransformation</code>是个空方法，都是子类实现，不懂动画有自己实现。当我们自定义动画就要去重写这个方法。</p>
<h3 id="属性动画-1"><a href="#属性动画-1" class="headerlink" title="属性动画"></a>属性动画</h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中View体系</title>
    <url>/Android-View/</url>
    <content><![CDATA[<h2 id="View与ViewGroup"><a href="#View与ViewGroup" class="headerlink" title="View与ViewGroup"></a>View与ViewGroup</h2><p>View是所有Android控件的基类，而ViewGroup是继承自View，是多个View 的组合。View中可以包含ViewGroup，ViewGroup中可以包含View，以此类推，形成一个View树。</p>
<p><img src="/Android-View/View树.png" alt="View树"></p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><h3 id="Android中的坐标系"><a href="#Android中的坐标系" class="headerlink" title="Android中的坐标系"></a>Android中的坐标系</h3><p>Android系统中，将左上角的顶点作为Android坐标系的原点，原点向右是X轴正方向，原点向下是Y轴正方向。在触摸事件中用getRawX()和getRawY()获取的就是这个坐标系的x和y坐标。</p>
<p><img src="/Android-View/屏幕坐标.png" alt="屏幕坐标"></p>
<h3 id="View中坐标体系"><a href="#View中坐标体系" class="headerlink" title="View中坐标体系"></a>View中坐标体系</h3><p>View坐标体系是对于View而言的坐标，类似于相对坐标。它与Android坐标并不冲突，一般用于对View的控制使用，例如滑动，重新绘制等。</p>
<p><img src="/Android-View/View坐标.png" alt="View坐标"></p>
<p>View自身的方法：</p>
<ul>
<li><code>getTop()</code>：获取View自身顶部到父布局顶部的距离。</li>
<li><code>getBottom()</code>：获取View自身低部到父布局低部的距离。</li>
<li><code>getRight()</code>：获取View自身右边到父布局右边的距离。</li>
<li><code>getLeft()</code>：获取View自身左边到父布局左边的距离。</li>
</ul>
<p>可以用来计算出View的宽度和高度。</p>
<p>MotionEvent提供的方法：</p>
<ul>
<li><code>getX()</code>：获取点击事件到控件左边距离，是相对坐标。</li>
<li><code>getY()</code>：获取点击事件到控件顶部距离，是相对坐标。</li>
<li><code>getRawX()</code>：获取点击事件到屏幕左边距离，是绝对坐标。</li>
<li><code>getRawY()</code>：获取点击事件到屏幕顶部距离，是绝对坐标。</li>
</ul>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>View滑动是开发中非常多使用到的，其基本思想是：当点击事件传递到View时，系统记录下触摸点的坐标，手指滑动时记录滑动后的坐标，然后计算出偏移量，通过偏移量来修改View的相关属性，达到滑动效果。</p>
<h3 id="调用layout-方法"><a href="#调用layout-方法" class="headerlink" title="调用layout()方法"></a>调用layout()方法</h3><p>View绘制的时候会调用<code>layout()</code>方法来设置显示的位置，设置是会根据自身的mTop、mLeft、mBottom、mRight四个属性去放置位置。<code>layout()</code>中的四个left、top、right、bottom四个参数就是用来改变mTop、mLeft、mBottom、mRight的。所以我们可以自己算出偏移量再去调用<code>layout()</code>方法便可实现滑动。</p>
<p>重写View的OnTouchEvent方法可以实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)event.getX() ;</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>)event.getY() ;</span><br><span class="line">    <span class="keyword">switch</span>(event.getAction())&#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">//初始位置</span></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">//计算偏移量</span></span><br><span class="line">            <span class="keyword">int</span> offsetX = x - lastX ;</span><br><span class="line">            <span class="keyword">int</span> offsetY = y - lastY ; </span><br><span class="line">            <span class="comment">//调用layout()方法重新放置位置</span></span><br><span class="line">            layout(getLeft()+offsetX,getYop()+offsetY,getRight()+offsetX,getBottom()+offsetY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="调用offsetLeftAndRight-与offsetTopAndBottom-方法"><a href="#调用offsetLeftAndRight-与offsetTopAndBottom-方法" class="headerlink" title="调用offsetLeftAndRight()与offsetTopAndBottom()方法"></a>调用offsetLeftAndRight()与offsetTopAndBottom()方法</h3><p><code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code>两个方法和<code>layout()</code>方法差不多，也是通过修改View自身的mTop、mLeft、mBottom、mRight四个属性从而去改变View的位置。</p>
<p>我们可以在上面ACTION_MOVE中将<code>layout()</code>方法换成<code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">          <span class="comment">//计算偏移量</span></span><br><span class="line">          <span class="keyword">int</span> offsetX = x - lastX ;</span><br><span class="line">          <span class="keyword">int</span> offsetY = y - lastY ; </span><br><span class="line">          <span class="comment">//进行偏移</span></span><br><span class="line">          offsetLeftAndRight(offsetX) ; </span><br><span class="line">   offsetTopAndBottom(offsetY) ; </span><br><span class="line">          <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h3 id="使用LayoutParams改变布局参数"><a href="#使用LayoutParams改变布局参数" class="headerlink" title="使用LayoutParams改变布局参数"></a>使用LayoutParams改变布局参数</h3><p>LayoutParams保存了一个View的布局参数，在View的measure过程中，是根据父控件的MeasureSpec和View自身的LayoutParams来决定的。也就是说我们可以通过改变View的LayoutParams来改变View在父控件中的位置，达到View滑动效果。</p>
<p>需要注意，在获取LayoutParams的时候要根据父容器的类型还获得不同的LayoutParams。推荐使用ViewGroup.MarginLayoutParams来实现，将ACTION_MOVE改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为父布局是LinearLayout，所以使用LinearLayout.LayoutParams</span></span><br><span class="line"><span class="comment">//如果父布局是RelativeLayout则使用RelativeLayout.LayoutParams</span></span><br><span class="line">LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams)getLayoutParams() ;</span><br><span class="line">layoutParams.leftMargin() = getLeft() + offsetX ; </span><br><span class="line">layoutParams.topMargin() = getTop() + offsetY ; </span><br><span class="line">setLayoutParams(layoutParams) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了使用布局的用LayoutParams，还可以使用ViewGroup.MarginLayoutParams</span></span><br><span class="line">ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams)getLayoutParams() ;</span><br><span class="line">layoutParams.leftMargin() = getLeft() + offsetX ; </span><br><span class="line">layoutParams.topMargin() = getTop() + offsetY ; </span><br><span class="line">setLayoutParams(layoutParams) ;</span><br></pre></td></tr></table></figure>




<h3 id="scrollTo-、scollBy"><a href="#scrollTo-、scollBy" class="headerlink" title="scrollTo()、scollBy()"></a>scrollTo()、scollBy()</h3><p>scollTo/scollBy是Android专门提供的让View滑动的方法，是View里面的方法，这种方法是通过<code>invalidateParentCaches()</code>重新绘制父布局来达到滑动效果，重绘父布局的时候也会重新绘制其下子View的布局。scrollTo（x，y）表示移动到一个具体的坐标点，而scrollBy（dx，dy）则表示移动的增量为dx、dy。其实scollBy最终也是要调用scollTo的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();  <span class="comment">//这里重新绘制父布局</span></span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scrollTo里面通过改变mScrollY和mScrollX，这个mScrollX是指View的左边缘到View的内容的左边缘的距离，mScrollY是指View的上边缘到View的内容的上边缘的距离。用下图来表达更为清晰：</p>
<p><img src="/Android-View/距离状态.jpg" alt="距离状态"></p>
<p>要注意的两个点，第一个是这里mScrollY和mScrollX的正负值，与平时我们理解的是反过来的。第二个移动的不是View而是View的内容，也就是红色表示区域在移动。怎么理解View和View的内容呢？如果该View没有子View，那么移动的就是View的内容（比如说调用一个Button的相应方法，会发现Button本身并不会移动，移动 的是Button的文本内容）；如果该View中有子View，那么移动的就是子View（比如说一个FrameLayout中有一个Button，调用FrameLayout的相应方法，会发现Button移动而FrameLayout不移动）。</p>
<p>将ACTION_MOVE改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为是View的内容移动，所以要用父布局去scrollBy</span></span><br><span class="line">((View)getParent()).scrollBy(-offsetX,-offsetY);</span><br></pre></td></tr></table></figure>




<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>我们还可以使用Android官方提供的动画来实现View的滑动，动画的原理大致是，将需要进行的动画的每一帧存到一个数组中，根据这个数组重新绘制父布局来实现动画效果。和<code>scrollTo()</code>一样会调用<code>invalidateParentCaches()</code>重新绘父布局。</p>
<p>需要注意的是，补间动画只是重新绘制了View的位置，View的属性并没有改变。而属性动画会改变View自身的一些translation属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//补间动画例子</span></span><br><span class="line">mCustomView.setAnimation(AnimationUtils.loadAnimation(context,R.anim.translate));</span><br><span class="line"><span class="comment">//属性动画例子</span></span><br><span class="line">ObjectAnimator.ofFloat(mCustomView,<span class="string">"translationX"</span>,<span class="number">0</span>,<span class="number">300</span>).setDuration(<span class="number">1000</span>).start();</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>上面的5中方法，其中前三种是一个原理，通过改变view的属性参数去实现滑动，scrollTo/scrollBy则是View原有的滑动API，动画是专门针对View的位置大小改变的库。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">改变布局参数</td>
<td align="center">操作复杂，适合用于有交互的View的简单移动变化</td>
</tr>
<tr>
<td align="center">scrollTo/scrollBy</td>
<td align="center">操作简单，适合对View内容进行滑动</td>
</tr>
<tr>
<td align="center">动画</td>
<td align="center">操作简单，适用于没有交互的View进行复杂的移动变化</td>
</tr>
</tbody></table>
<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><h3 id="Activity构成"><a href="#Activity构成" class="headerlink" title="Activity构成"></a>Activity构成</h3><p>我们点击屏幕，系统会将点击事件包装，最先传递到Activity的，然后再由Activity根据布局传递。所以需要先分析Activity的布局源码。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们一般在Activity的<code>onCreate()</code>中调用<code>setContentView()</code>方法来设置布局：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用window的setContentView</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity内又会调用<code>window.setContentView()</code>，这个<code>getWindow()</code>返回的是一个PhoneWindow对象，它继承自Window。PhoneWindow的setContentView方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor(); <span class="comment">//--------1-------</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"> 	.........</span><br><span class="line">    mContentParent = generateLayout(mDecor);<span class="comment">//--------2-------</span></span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要看注释1处的<code>installDecor()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ........</span><br><span class="line">	<span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>); <span class="comment">//------1-----</span></span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释1处，<code>generateDecor()</code>返回一个DecorView，这个DecorView就是Activity中的根View了。DecorView是PhoneWindow的内部类，继承自FrameLayout。上一个代码块的注释2处，<code>generateLayout(mDecor)</code>的作用就是更根据不同情况加载不同布局，一般情况下会加载<code>R.layout.screen_title</code>这个布局，布局如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">"?android:attr/windowTitleSize"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">style</span>=<span class="string">"?android:attr/windowTitleBackgroundStyle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@android:id/title"</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">style</span>=<span class="string">"?android:attr/windowTitleStyle"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:background</span>=<span class="string">"@null"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:fadingEdge</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的ViewStub是用来显示Actionbar的。下面的两个FrameLayout：一个是title，用来显示标题；另一个是content，用来显示内容。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看到上面的源码，大家就知道了一个Activity包含一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根 View，而这个 DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平常做应用所写的布局正是展示在ContentView中的。</p>
<p><img src="/Android-View/Activity构成.png" alt="Activity构成"></p>
<h3 id="事件传递分发机制"><a href="#事件传递分发机制" class="headerlink" title="事件传递分发机制"></a>事件传递分发机制</h3><p>我们的点击事系统会包装成一个类：MotionEvent。Activity会将这个MotionEvent传递到View层级，然后就是View对这个事件的分发和消费。</p>
<p>在View和ViewGroup中，事件分发有三个重要方法：</p>
<ul>
<li><code>dispatchTouchEvent(MotionEvent ev)</code>  —— 负责进行对事件分发，是否传递事件，是否消费事件。ViewGroup继承自View，它对这个方法进行了重写。</li>
<li><code>onInterceptTouchEvent(MotionEvent ev)</code> —— 判断ViewGroup是否拦截事件，这个方法仅仅在ViewGroup中重写的<code>dispatchTouchEvent</code>中有。</li>
<li><code>onTouchEvent(MotionEvent ev)</code>  —— 事件响应在这方法内，这个方法是在<code>dispatchTouchEvent</code>中调用。</li>
</ul>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>先看ViewGroup重写过的<code>dispatchTouchEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        cancelAndClearTouchTargets(ev);</span><br><span class="line">        <span class="comment">//清除FLAG_DISALLOW_INTERCEPT设置，并且将mFirstTouchTarget设置为null</span></span><br><span class="line">        resetTouchState();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">    <span class="comment">//-------1-------</span></span><br><span class="line">    <span class="comment">//“actionMasked == MotionEvent.ACTION_DOWN”用来判断是否是一个新的事件，一个新的事件都是DOWN开始的</span></span><br><span class="line">    <span class="comment">//“mFirstTouchTarget != null”用来判断是否是拦截事件，为null的时候是拦截了</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//------2-----</span></span><br><span class="line">        <span class="comment">//这个disallowIntercept是判断是否阻止拦截</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">            intercepted = onInterceptTouchEvent(ev);<span class="comment">//------3------</span></span><br><span class="line">            ev.setAction(action); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//onInterceptTouchEvent方法没有重写的话默认返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//默认返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1有一个mFirstTouchTarget，这个标记是标识ViewGroup是否拦截事件，当ViewGroup执行了<code>onInterceptTouchEvent</code>方法后这个就会设置为null。如果之前已经拦截过事件，那么注释3处的<code>onInterceptTouchEvent</code>就不会执行，会直接往下执行。所以，当拦截后，同一个事件序列的后续的事件都会交给ViewGroup处理，不会再调用<code>onInterceptTouchEvent</code>方法。</p>
<p>注释2处，<code>onInterceptTouchEvent</code>之前还有一个判断，这个用来判断是否阻止拦截。FLAG_DISALLOW_INTERCEPT这个标志会在子View中使用<code>requestDisallowInterceptTouchEvent</code>来进行设置，是子View干预父View的事件分发过程(ACTION_DOWN事件除外)的方法，也处理滑动冲突的重要方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示阻止拦截，父ViewGroup不会调用onInterceptTouchEvent方法</span></span><br><span class="line">childView.getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>剩余的<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="comment">//遍历子View</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//-------1--------</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">            childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">            preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//-----2-----</span></span><br><span class="line">        <span class="comment">//用于判断子View是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//--------3-------</span></span><br><span class="line">        <span class="comment">//已经有子View处理，跳出循环</span></span><br><span class="line">        newTouchTarget = getTouchTarget(child);</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resetCancelNextUpFlag(child);</span><br><span class="line">        <span class="comment">//-------3.5------</span></span><br><span class="line">        <span class="comment">//子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign))&#123;</span><br><span class="line">            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                        mLastTouchDownIndex = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLastTouchDownIndex = childIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTouchDownX = ev.getX();</span><br><span class="line">            mLastTouchDownY = ev.getY();</span><br><span class="line">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;<span class="comment">//------4-----</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">	 <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//-----5------</span></span><br><span class="line">         <span class="comment">//mFirstTouchTarget之前有说过，如果为null则是ViewGroup拦截了</span></span><br><span class="line">         <span class="comment">//dispatchTransformedTouchEvent传cancel和null</span></span><br><span class="line">         handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         .....</span><br><span class="line">         <span class="comment">//------6.0------</span></span><br><span class="line">         <span class="comment">//这里遍历可以传递事件的目标子View，注释3处有子View处理就是在这处理</span></span><br><span class="line">         <span class="keyword">while</span> (target != <span class="keyword">null</span>)&#123;  </span><br><span class="line">         	 <span class="comment">//-----6-------</span></span><br><span class="line">             <span class="comment">//alreadyDispatchedToNewTouchTarget在注释4处处理了，如果子View消费事件，则直接返回true    </span></span><br><span class="line">             <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                 handled = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//------7------</span></span><br><span class="line">                 <span class="comment">//如果子View没有消费事件，就dispatchTransformedTouchEvent</span></span><br><span class="line">                 <span class="comment">//这里和注释3的效果是一样的</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)|| intercepted;</span><br><span class="line">                 <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, </span><br><span class="line">                     cancelChild,target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                     handled = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ViewGroup没有拦截事件，注释1处会用一个for循环来遍历子View，要注意的是自View的遍历循序的按图层的从上往下的去遍历。</p>
<p>注释2处是判断点击事件是否在当前子View的范围内，或者当前子View是否在播放动画中，不符合条件就continue。注释3处是找到一个符合条件的子View，将他记录好。如果有特殊情况，则进入<code>dispatchTransformedTouchEvent</code>方法，这时传的是false和child。</p>
<p>注释5处就是对应之前的mFirstTouchTarget，拦截了事件，也会调用<code>dispatchTransformedTouchEvent</code>方法，不过参数里面传的子View是null。</p>
<p>注释6，如果有过在3.5处子View消费事件，直接返回true。</p>
<p>注释7，没有拦截事件，也没有在3.5处处理过事件，传递事件。要注意，如果这时<code>onInterceptTouchEvent</code>返回的是true，则会传cancel事件即ACTION_CANCEL给子View，表示被ViewGroup拦截了，子View事件终止。传递ACTION_CANCEL的情况会出现在VIewGroup在ACTION_DOWN没有拦截，而ACTION_MOVE或者ACTION_UP拦截的时候。</p>
<p>下面是<code>dispatchTransformedTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，有子View就会调用子View的<code>dispatchTouchEvent</code>方法，没有子View则会super.dispatchTouchEvent。因为ViewGroup继承自View，也就是调用View的<code>dispatchTouchEvent</code>方法。</p>
<p>上面是ViewGroup重写过的<code>dispatchTouchEvent</code>分析，下面看回View的<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123; <span class="comment">//-----1----</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123; <span class="comment">//-----2-----</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释1处可以看出，如果给View设置onTouchListener后，Listener中的方法会优先于View中的<code>onTouchEvent</code>方法。2处便是三个重要方法中的<code>onTouchevent</code>了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//-------1-----</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE|| (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)|| (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">    ....</span><br><span class="line">     <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">     	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        	<span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            	....</span><br><span class="line">            	performClickInternal(); <span class="comment">//----2----</span></span><br><span class="line">            	....</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: </span><br><span class="line">            	....</span><br><span class="line">            	checkForLongClick(<span class="number">0</span>, x, y); <span class="comment">//----3----</span></span><br><span class="line">            	....</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1处，View的CLICKABLE和LONG_CLICKABLE有一个为true，那么onTouchEvent（）就会返回true消耗这个事件。CLICKABLE和LONG_CLICKABLE代表View可以被点击和长按点击，可以通过View的setClickable和setLongClickable方法来设置，也可以通过View的setOnClickListenter和setOnLongClickListener来设置，它们会自动将View设置为CLICKABLE和LONG_CLICKABLE。</p>
<p>2处是触发onClickListener，3处是触发onLongClickListener。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/Android-View/流程图.png" alt="流程图"></p>
<p>上图是ViewGroup和View的事件分发关键方法的流程图。蓝色区域是ViewGroup的流程，红色区域是View的部分。</p>
<p><img src="/Android-View/事件传递.png" alt="事件传递"></p>
<h3 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h3><p>两个控件都可以滑动或点击的时候，就会出现滑动冲突的情况，我们的解决方法有如下两种，外部拦截和内部拦截，一般推荐外部拦截，符合事件传递机制，实现起来也比较简单。</p>
<h4 id="方法一：外部拦截"><a href="#方法一：外部拦截" class="headerlink" title="方法一：外部拦截"></a>方法一：外部拦截</h4><p>外部拦截也就是事件会先经过父容器的拦截处理，如果需要则拦截消费，不需要就往下层传递，这种处理方式符合拦截机制。我们需要在外部的ViewGroup的进行拦截，在<code>onInterceptTouchEvent</code>方法进行判断。如果是条件符合则拦截，条件不符合则不拦截。</p>
<p>ViewGroup重写<code>onInterceptTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部ViewGroup重写onInterceptTouchEvent方法进行拦截</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;  <span class="comment">//必须返回false</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*符合拦截条件*/</span>)&#123;</span><br><span class="line">            	intercepted = <span class="keyword">true</span>; <span class="comment">//拦截滑动</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>; <span class="comment">//不拦截</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>; <span class="comment">//UP这里也需要返回false</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，首先down事件父容器必须返回false ，因为若是返回true，也就是拦截了down事件，那么后续的move和up事件就都会传递给父容器，子元素就没有机会处理事件了。其次是up事件也返回了false，一是因为up事件对父容器没什么意义，其次是因为若事件是子元素处理的，却没有收到up事件会让子元素的onClick等事件无法触发。</p>
<h4 id="方法二：内部拦截法"><a href="#方法二：内部拦截法" class="headerlink" title="方法二：内部拦截法"></a>方法二：内部拦截法</h4><p>内部拦截的是指父容器ViewGroup不拦截任何事件，将所有事件传递给子元素，如果子元素需要则消耗掉，如果不需要则通过<code>requestDisallowInterceptTouchEvent</code>方法交给父容器处理。外部拦截复杂一些。</p>
<p>View重写<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部View重写dispatchTouchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            <span class="comment">//DOWN事件不让父容器拦截</span></span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*符合拦截条件*/</span>)&#123;</span><br><span class="line">            	<span class="comment">//让父View拦截</span></span><br><span class="line">           		getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewGroup重写<code>onInterceptTouchevent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部ViewGroup重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">//父容器也不能拦截down事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父容器不拦截DOEN事件前面说过了，因为拦截后后续的MOVE和UP事件都会给父容器拦截掉。</p>
<h3 id="MotionEvent事件"><a href="#MotionEvent事件" class="headerlink" title="MotionEvent事件"></a>MotionEvent事件</h3><p>上面讲到的事件分发机制，分发的便是MotionEvent。这个MotionEvent我们分为单点触控和多点触控来看它的主要方法和事件类型。</p>
<h4 id="单点触控"><a href="#单点触控" class="headerlink" title="单点触控"></a>单点触控</h4><p>主要方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAction()</td>
<td align="center">获取事件类型</td>
</tr>
<tr>
<td align="center">getX()、getY()</td>
<td align="center">获取触点在当前View的坐标</td>
</tr>
<tr>
<td align="center">getRawX()、getRawY()</td>
<td align="center">获取触点在整个屏幕的坐标</td>
</tr>
</tbody></table>
<p>获取坐标的四个方法在坐标系中有说</p>
<p>主要事件：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">触发条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACTION_DOWN</td>
<td align="center">手指按下时触发</td>
</tr>
<tr>
<td align="center">ACTION_MOVE</td>
<td align="center">手指在屏幕上滑动触发，一直滑动会一直触发</td>
</tr>
<tr>
<td align="center">ACTION_UP</td>
<td align="center">手指离开屏幕时触发</td>
</tr>
<tr>
<td align="center">ACTION_CANCEL</td>
<td align="center">事件被上层拦截时触发</td>
</tr>
<tr>
<td align="center">ACTION_OUTSIDE</td>
<td align="center">手指不在控件区域是触发</td>
</tr>
</tbody></table>
<p>ACTION_CANCEL这个事件触发条件是<strong>上层ViewGroup回收了事件</strong>，就是正常来说应该ziView去处理的事件被ViewGroup拦截了。一般还在处理滑动冲突时出现，具体的例子上面滑动冲突的例子，滑动是ViewGroup，点击是View。当我们点下去的时候，子View会接收ACTION_DOWN，我们滑动的时候，父控件拦截了，子View会接收到ACTION_CANCEL，之后便不会接收任何事件。</p>
<p>ACTION_OUTSIDE的触发条件有点奇葩，点击View外面，具体例子是Dialog，点击Dialog外面也会消失就是使用这个事件。这个一般来说不会使用，使用时候还要对View的WindowManager布局参数的flags设置为<code>FLAG_WATCH_OUTSIDE_TOUCH</code>，这样View便可以接收到outside事件。</p>
<h4 id="多点触控"><a href="#多点触控" class="headerlink" title="多点触控"></a>多点触控</h4><p>主要事件类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">触发条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACTION_DOWN</td>
<td align="center">第一个手指按下时触发</td>
</tr>
<tr>
<td align="center">ACTION_MOVE</td>
<td align="center">手指在屏幕上滑动触发，一直滑动会一直触发</td>
</tr>
<tr>
<td align="center">ACTION_UP</td>
<td align="center">最后一个手指离开屏幕时触发</td>
</tr>
<tr>
<td align="center">ACTION_POINTER_DOWN</td>
<td align="center">非第一个手指按下时触发</td>
</tr>
<tr>
<td align="center">ACTION_POINTER_UP</td>
<td align="center">非最后一个手指离开屏幕时触发</td>
</tr>
</tbody></table>
<p>主要方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getActionMasked()</td>
<td align="center">与getAction()一样，用于获取多点触控事件类型</td>
</tr>
<tr>
<td align="center">getActionIndex()</td>
<td align="center">获取该事件由那个指针（手指）产生</td>
</tr>
<tr>
<td align="center">getPointerCount()</td>
<td align="center">获取屏幕上指针（手指）个数</td>
</tr>
<tr>
<td align="center">getPointerId(int pointerIndex)</td>
<td align="center">获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。</td>
</tr>
<tr>
<td align="center">findPointerIndex(int pointerId)</td>
<td align="center">通过PointerId获取到当前状态下PointIndex，之后通过PointIndex获取其他内容。</td>
</tr>
<tr>
<td align="center">getX(int pointerIndex)</td>
<td align="center">获取某一个指针(手指)的X坐标</td>
</tr>
<tr>
<td align="center">getY(int pointerIndex)</td>
<td align="center">获取某一个指针(手指)的Y坐标</td>
</tr>
</tbody></table>
<p><code>getActionMasked</code>和<code>getAction</code>一样，只不过&amp;了一个ACTION_MASK，ACTION_MASK是用来把多点触控的事件类型转化为ACTION_POINTER_DOWN和ACTION_POINTER_UP的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeGetAction(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getActionMasked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeGetAction(mNativePtr) &amp; ACTION_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有三个概念ActionIndex、PointerIndex和PointerId。ActionIndex和PointerIndex可以理解为一样的，他们数值也相等，不同的地方是在Move中无法获取actionIndex，但可以使用pointerIndex，进而使用<code>getX(int pointerIndex)</code>和<code>getY(int pointerIndex)</code>获取更多信息。</p>
<p>而index和pointerId的异同如下:</p>
<ul>
<li>相同点:从 0 开始，自动增长。</li>
<li>相同点:落下手指时优先填补空缺(填补之前抬起手指的编号)。</li>
<li>不同的:Index 会变化，pointId 始终不变。</li>
</ul>
<p>下面代码是获取第二个手指的坐标并记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于判断第2个手指是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> haveSecondPoint = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录第2个手指第位置</span></span><br><span class="line">PointF point = <span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = event.getActionIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">            <span class="comment">// 判断是否是第2个手指按下</span></span><br><span class="line">            <span class="keyword">if</span> (event.getPointerId(index) == <span class="number">1</span>)&#123;</span><br><span class="line">                haveSecondPoint = <span class="keyword">true</span>;</span><br><span class="line">                point.set(event.getY(), event.getX());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">            <span class="comment">// 判断抬起的手指是否是第2个</span></span><br><span class="line">            <span class="keyword">if</span> (event.getPointerId(index) == <span class="number">1</span>)&#123;</span><br><span class="line">                haveSecondPoint = <span class="keyword">false</span>;</span><br><span class="line">                point.set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (haveSecondPoint) &#123;</span><br><span class="line">                <span class="comment">// 通过 pointerId 来获取 pointerIndex</span></span><br><span class="line">                <span class="keyword">int</span> pointerIndex = event.findPointerIndex(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 通过 pointerIndex 来取出对应的坐标</span></span><br><span class="line">                point.set(event.getX(pointerIndex), event.getY(pointerIndex));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>BlockingQueue</title>
    <url>/Java-BlockingQueue/</url>
    <content><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>BlockingQueue（阻塞队列）是在Concurrent包下的一个处理并发的安全队列类，在多线程和线程池中有着非常广泛的使用。BlockingQueue的实现类都在内部使用ReentrantLock进行队列的安全性维护。</p>
<h3 id="BlockingQueue的主要方法"><a href="#BlockingQueue的主要方法" class="headerlink" title="BlockingQueue的主要方法"></a>BlockingQueue的主要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素设置到队列中，如果设置成功返回true, 否则返回false。如果是往限定了长度的队列中设置值，推荐使用offer()方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。超过长度抛出特殊值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在给定的时间里，从队列中获取值，时间到了直接调用普通的poll方法，为null则直接返回null。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列中是否拥有该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BlockingQueue主要实现类"><a href="#BlockingQueue主要实现类" class="headerlink" title="BlockingQueue主要实现类"></a>BlockingQueue主要实现类</h3><p>下图是BlockingQueue的实现类得继承关系：</p>
<p><img src="%5CJava-BlockingQueue%5CBlockingQueue%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="BlockingQueue继承图"></p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>是否有界</th>
<th>是否加锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>是</td>
<td>是</td>
<td>数组</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>可选</td>
<td>是</td>
<td>链表</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>有</td>
<td>是</td>
<td>无</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>无</td>
<td>是</td>
<td>堆</td>
</tr>
</tbody></table>
<ul>
<li>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照FIFO的原则对元素进行排序。支持公平锁和非公平锁。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。</li>
<li>PriorityBlockingQueue： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li>
<li>DelayQueue： 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li>
<li>SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
<li>LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li>
<li>LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程池</title>
    <url>/java-ThreadPool/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中，我们经常需要用到线程，但是大量的线程会占用内存资源可能导致OOM。这时候就需要到线程池来进行线程的调度。</p>
<h2 id="线程池总体结构"><a href="#线程池总体结构" class="headerlink" title="线程池总体结构"></a>线程池总体结构</h2><p><img src="/java-ThreadPool/线程池架构.png" alt="线程池架构"></p>
<p><strong>Executor</strong>: 所有线程池的接口,只有一个方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么final ReentrantLock lock = this.lock;</title>
    <url>/java-problem1/</url>
    <content><![CDATA[<p>今天在看BlockingQueue相关实现类的时候，发现了一个问题如下：</p>
<p><img src="/java-problem1/DelayQueue源码.jpg" alt="DelayQueue源码"></p>
<p>对于上图中的<code>final ReentrantLock lock = this.lock</code>这种写法，百度之后原作者是说“归根究底是由于内存模型与OOP之间的原则不一致”。</p>
<p>在内存模型上看，当方法中访问类变量会比访问方法中的变量多一步，也就是会先有访问<code>this</code>。如果直接使用，就会变成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.lock.lock();</span><br><span class="line"><span class="keyword">this</span>.lock.unlock();</span><br></pre></td></tr></table></figure>

<p>会比直接访问方法内变量多出一步，事实上反编译出来的结果也是一样，会多出一步：</p>
<p><img src="%5Cjava-problem1%5C%E5%8F%8D%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.jpg" alt="反编译结果"></p>
<p>但是在目前JDK版本已经对这种情况优化了，这种编写方式已是一种习惯编写。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>小问题</tag>
      </tags>
  </entry>
  <entry>
    <title>分享功能</title>
    <url>/Android-OpenThird/</url>
    <content><![CDATA[<h2 id="Android中的原生分享"><a href="#Android中的原生分享" class="headerlink" title="Android中的原生分享"></a>Android中的原生分享</h2><p>下面是Android原生的分享功能，也就是第三方应用跳转，只不过是在intent中添加Intent.ACtion_SEND来区分这是一个分享：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Intent，设置action为ACtion_SEND</span></span><br><span class="line">Intent textIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line"><span class="comment">//这里设置分享内容类型</span></span><br><span class="line">textIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">//将分享内容放入Extra中</span></span><br><span class="line">textIntent.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是一段分享的文字"</span>);</span><br><span class="line"><span class="comment">//startActivity,这里使用了createChooser让用户选择用哪个应用启动</span></span><br><span class="line"><span class="comment">//还可以直接使用startActivity(intent)，这样可以指定哪个应用启动(第一次需要选择)</span></span><br><span class="line">startActivity(Intent.createChooser(textIntent, <span class="string">"title"</span>));</span><br></pre></td></tr></table></figure>



<h2 id="指定应用分享"><a href="#指定应用分享" class="headerlink" title="指定应用分享"></a>指定应用分享</h2><p>我们跳转第三方应用时，可以设置package来进行指定应用打开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent wechatIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line"><span class="comment">//指定应用</span></span><br><span class="line">wechatIntent.setPackage(<span class="string">"com.tencent.mm"</span>);</span><br><span class="line"><span class="comment">//图片格式</span></span><br><span class="line">wechatIntent.setType(<span class="string">"image/jpeg"</span>);</span><br><span class="line">wechatIntent.putExtra(Intent.EXTRA_STREAM, url);</span><br><span class="line">startActivity(Intent.createChooser(wechatIntent, <span class="string">"title"</span>));</span><br></pre></td></tr></table></figure>

<p>指定应用之后，分享会调到指定的应用，但是具体哪个页面没确定，比如微信会有分享给朋友、分享到朋友圈、分享到收藏等。</p>
<p>我们跳转第三方应用时，可以设置ComponentName来进行指定应用的指定界面打开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String package_name = <span class="string">"xx.xx.xx"</span>;</span><br><span class="line">String activity_path = <span class="string">"xx.xx.xx.ab.xxActivity"</span>;</span><br><span class="line"></span><br><span class="line">Intent intent2 = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent2.putExtra(Intent.EXTRA_TEXT, <span class="string">"hello"</span>);</span><br><span class="line">intent2.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">//----下面两步是设置intent的compnentname，指定应用指定界面</span></span><br><span class="line">ComponentName componentName = <span class="keyword">new</span> ComponentName(package_name,activity_path) ;</span><br><span class="line">intent2.setComponent(componentName);</span><br><span class="line"><span class="comment">//----</span></span><br><span class="line">startActivity(intent2);</span><br></pre></td></tr></table></figure>

<p>使用这种方法需要知道APP的包名和Activity全路径和名称。</p>
<p>下面的方法是使用pm进行分享应用的筛选：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String wechatShareName = <span class="string">"com.tencent.mm.ui.tools.ShareImgUI"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String qqShareName = <span class="string">"com.tencent.mobileqq.activity.JumpActivity"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String rcsShareName = <span class="string">"com.cmic.module_main.ui.activity.WelcomeActivity"</span>;</span><br><span class="line"><span class="comment">//---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PackageManager packageManager = context.getPackageManager();</span><br><span class="line"><span class="comment">//创建指定intent</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">//筛选出指定的Activity集合</span></span><br><span class="line">List&lt;ResolveInfo&gt; resolveInfos = packageManager.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line"><span class="comment">//便利集合</span></span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : resolveInfos) &#123;</span><br><span class="line">    String shareName = resolveInfo.activityInfo.name;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.equals(shareName,wechatShareName)) &#123;</span><br><span class="line">        Intent intent2 = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">        intent2.putExtra(Intent.EXTRA_TEXT, <span class="string">"content"</span>);</span><br><span class="line">        intent2.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(resolveInfo.activityInfo.packageName,</span><br><span class="line">                                              resolveInfo.activityInfo.name));</span><br><span class="line">        context.startActivity(intent2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分享不同格式"><a href="#分享不同格式" class="headerlink" title="分享不同格式"></a>分享不同格式</h2><p>文件分享时一般都要设置好文件类型，默认指定类型为<code>*/*</code>，已默认类型进行分享时有些App不支持这种类型，会导致分享失败，最好的方式是预先根据文件路径设置好文件类型。</p>
<p>常见的文件mimeType格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;.3gp&quot;, &quot;video&#x2F;3gpp&quot;&#125;,  </span><br><span class="line">&#123;&quot;.apk&quot;, &quot;application&#x2F;vnd.android.package-archive&quot;&#125;,  </span><br><span class="line">&#123;&quot;.asf&quot;, &quot;video&#x2F;x-ms-asf&quot;&#125;,  </span><br><span class="line">&#123;&quot;.avi&quot;, &quot;video&#x2F;x-msvideo&quot;&#125;,  </span><br><span class="line">&#123;&quot;.bin&quot;, &quot;application&#x2F;octet-stream&quot;&#125;,  </span><br><span class="line">&#123;&quot;.bmp&quot;, &quot;image&#x2F;bmp&quot;&#125;,  </span><br><span class="line">&#123;&quot;.c&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.class&quot;, &quot;application&#x2F;octet-stream&quot;&#125;,  </span><br><span class="line">&#123;&quot;.conf&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.cpp&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.doc&quot;, &quot;application&#x2F;msword&quot;&#125;,  </span><br><span class="line">&#123;&quot;.exe&quot;, &quot;application&#x2F;octet-stream&quot;&#125;,  </span><br><span class="line">&#123;&quot;.gif&quot;, &quot;image&#x2F;gif&quot;&#125;,  </span><br><span class="line">&#123;&quot;.gtar&quot;, &quot;application&#x2F;x-gtar&quot;&#125;,  </span><br><span class="line">&#123;&quot;.gz&quot;, &quot;application&#x2F;x-gzip&quot;&#125;,  </span><br><span class="line">&#123;&quot;.h&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.htm&quot;, &quot;text&#x2F;html&quot;&#125;,  </span><br><span class="line">&#123;&quot;.html&quot;, &quot;text&#x2F;html&quot;&#125;,  </span><br><span class="line">&#123;&quot;.jar&quot;, &quot;application&#x2F;java-archive&quot;&#125;,  </span><br><span class="line">&#123;&quot;.java&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.jpeg&quot;, &quot;image&#x2F;jpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.jpg&quot;, &quot;image&#x2F;jpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.js&quot;, &quot;application&#x2F;x-javascript&quot;&#125;,  </span><br><span class="line">&#123;&quot;.log&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m3u&quot;, &quot;audio&#x2F;x-mpegurl&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4a&quot;, &quot;audio&#x2F;mp4a-latm&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4b&quot;, &quot;audio&#x2F;mp4a-latm&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4p&quot;, &quot;audio&#x2F;mp4a-latm&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4u&quot;, &quot;video&#x2F;vnd.mpegurl&quot;&#125;,  </span><br><span class="line">&#123;&quot;.m4v&quot;, &quot;video&#x2F;x-m4v&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mov&quot;, &quot;video&#x2F;quicktime&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mp2&quot;, &quot;audio&#x2F;x-mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mp3&quot;, &quot;audio&#x2F;x-mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mp4&quot;, &quot;video&#x2F;mp4&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpc&quot;, &quot;application&#x2F;vnd.mpohun.certificate&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpe&quot;, &quot;video&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpeg&quot;, &quot;video&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpg&quot;, &quot;video&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpg4&quot;, &quot;video&#x2F;mp4&quot;&#125;,  </span><br><span class="line">&#123;&quot;.mpga&quot;, &quot;audio&#x2F;mpeg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.msg&quot;, &quot;application&#x2F;vnd.ms-outlook&quot;&#125;,  </span><br><span class="line">&#123;&quot;.ogg&quot;, &quot;audio&#x2F;ogg&quot;&#125;,  </span><br><span class="line">&#123;&quot;.pdf&quot;, &quot;application&#x2F;pdf&quot;&#125;,  </span><br><span class="line">&#123;&quot;.png&quot;, &quot;image&#x2F;png&quot;&#125;,  </span><br><span class="line">&#123;&quot;.pps&quot;, &quot;application&#x2F;vnd.ms-powerpoint&quot;&#125;,  </span><br><span class="line">&#123;&quot;.ppt&quot;, &quot;application&#x2F;vnd.ms-powerpoint&quot;&#125;,  </span><br><span class="line">&#123;&quot;.prop&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rar&quot;, &quot;application&#x2F;x-rar-compressed&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rc&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rmvb&quot;, &quot;audio&#x2F;x-pn-realaudio&quot;&#125;,  </span><br><span class="line">&#123;&quot;.rtf&quot;, &quot;application&#x2F;rtf&quot;&#125;,  </span><br><span class="line">&#123;&quot;.sh&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.tar&quot;, &quot;application&#x2F;x-tar&quot;&#125;,  </span><br><span class="line">&#123;&quot;.tgz&quot;, &quot;application&#x2F;x-compressed&quot;&#125;,  </span><br><span class="line">&#123;&quot;.txt&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wav&quot;, &quot;audio&#x2F;x-wav&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wma&quot;, &quot;audio&#x2F;x-ms-wma&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wmv&quot;, &quot;audio&#x2F;x-ms-wmv&quot;&#125;,  </span><br><span class="line">&#123;&quot;.wps&quot;, &quot;application&#x2F;vnd.ms-works&quot;&#125;,  </span><br><span class="line">&#123;&quot;.xml&quot;, &quot;text&#x2F;xml&quot;&#125;,  </span><br><span class="line">&#123;&quot;.xml&quot;, &quot;text&#x2F;plain&quot;&#125;,  </span><br><span class="line">&#123;&quot;.z&quot;, &quot;application&#x2F;x-compress&quot;&#125;,  </span><br><span class="line">&#123;&quot;.zip&quot;, &quot;application&#x2F;zip&quot;&#125;,  </span><br><span class="line">&#123;&quot;&quot;, &quot;*&#x2F;*&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>intent中对于图片和视频类型的文件我们可以设置type为流式stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.putExtra(Intent.EXTRA_STREAM, content);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android，分享</tag>
      </tags>
  </entry>
  <entry>
    <title>判断应用是否是前台进程</title>
    <url>/Android-Foreground_rocess/</url>
    <content><![CDATA[<h2 id="六种方法的区别"><a href="#六种方法的区别" class="headerlink" title="六种方法的区别"></a>六种方法的区别</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">判断原理</th>
<th>需要权限</th>
<th>可以判断其他应用位于前台</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">方法一</td>
<td align="center">RunningTask</td>
<td>否</td>
<td>Android4.0系列可以,5.0以上机器不行</td>
<td>5.0此方法被废弃</td>
</tr>
<tr>
<td align="center">方法二</td>
<td align="center">RunningProcess</td>
<td>否</td>
<td>当App存在后台常驻的Service时失效</td>
<td>无</td>
</tr>
<tr>
<td align="center">方法三</td>
<td align="center">ActivityLifecycleCallbacks</td>
<td>否</td>
<td>否</td>
<td>简单有效,代码最少</td>
</tr>
<tr>
<td align="center">方法四</td>
<td align="center">UsageStatsManager</td>
<td>是</td>
<td>是</td>
<td>需要用户手动授权</td>
</tr>
<tr>
<td align="center">方法五</td>
<td align="center">通过Android无障碍功能实现</td>
<td>否</td>
<td>是</td>
<td>需要用户手动授权</td>
</tr>
<tr>
<td align="center">方法六</td>
<td align="center">读取/proc目录下的信息</td>
<td>否</td>
<td>是</td>
<td>当proc目录下文件夹过多时,过多的IO操作会引起耗时</td>
</tr>
</tbody></table>
<h2 id="一、RunningTask"><a href="#一、RunningTask" class="headerlink" title="一、RunningTask"></a>一、RunningTask</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>此方法在Android4.x上可以执行，当一个APP处于前台时，会处于RunningTask这个栈顶。我们可以取出RunningTask的栈顶进程，然后判断包名是否是要判断的APP的包名。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这种方法不仅能获取到前台进程的包名还能获取到activity名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getForegroundActivity</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ActivityManager mActivityManager =  </span><br><span class="line">        (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);  </span><br><span class="line">    <span class="keyword">if</span> (mActivityManager.getRunningTasks(<span class="number">1</span>) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        Log.e(TAG, <span class="string">"running task is null, ams is abnormal!!!"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ActivityManager.RunningTaskInfo mRunningTask =  </span><br><span class="line">        mActivityManager.getRunningTasks(<span class="number">1</span>).get(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (mRunningTask == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        Log.e(TAG, <span class="string">"failed to get RunningTaskInfo"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    String pkgName = mRunningTask.topActivity.getPackageName();  </span><br><span class="line">    <span class="comment">//String activityName =  mRunningTask.topActivity.getClassName();  </span></span><br><span class="line">    <span class="keyword">return</span> pkgName;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>getRunningTask方法在5.0以上已经被废弃，只会返回自己和系统的一些不敏感的task，不再返回其他应用的task。此方法不能判断其他应用是否在前台。</p>
<h2 id="一、RunningProcess"><a href="#一、RunningProcess" class="headerlink" title="一、RunningProcess"></a>一、RunningProcess</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过runningProcess获取到一个当前正在运行的进程的List，我们遍历这个List中的每一个进程，判断这个进程的一个importance 属性是否是前台进程，并且包名是否与我们判断的APP的包名一样，如果这两个条件都符合，那么这个App就处于前台。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>  以下是判断当前应用是否在前台：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAppForeground</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ActivityManager activityManager =     </span><br><span class="line">        (ActivityManager)context.getSystemService(Service.ACTIVITY_SERVICE);</span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcessInfoList =           		    	     </span><br><span class="line">        activityManager.getRunningAppProcesses();</span><br><span class="line">    <span class="keyword">if</span> (runningAppProcessInfoList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG,<span class="string">"runningAppProcessInfoList is null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ActivityManager.RunningAppProcessInfo processInfo : runningAppProcessInfoList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processInfo.processName.equals(context.getPackageName())</span><br><span class="line">            &amp;&amp;(processInfo.importance == </span><br><span class="line">               ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND)) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是判断在前台的是哪个应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getForegroundApp</span><span class="params">(Context context)</span> </span>&#123;  </span><br><span class="line">    ActivityManager am =  </span><br><span class="line">        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);  </span><br><span class="line">    List&lt;RunningAppProcesInfo&gt; lr = am.getRunningAppProcesses();  </span><br><span class="line">    <span class="keyword">if</span> (lr == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RunningAppProcessInfo ra : lr) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ra.importance == RunningAppProcessInfo.IMPORTANCE_VISIBLE  </span><br><span class="line">            || ra.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123;  </span><br><span class="line">            <span class="keyword">return</span> ra.processName;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getRunningAppProcess方法只能获取前台包名。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>Android5.0之后已经被废弃。</p>
<p>例如，在聊天类型的App中，常常需要常驻后台来不间断地获取服务器的消息，就需要把Service设置成START_STICKY，kill后会被重启（等待5s左右）来保证Service常驻后台。如果Service设置了这个属性，这个App的进程就会被判断为前台。代码表现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND</span><br></pre></td></tr></table></figure>

<p>上述code永远成立，这样就永远无法判断到底那个是前台了。</p>
<h2 id="三、ActivityLifecycleCallbacks"><a href="#三、ActivityLifecycleCallbacks" class="headerlink" title="三、ActivityLifecycleCallbacks"></a>三、ActivityLifecycleCallbacks</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>AndroidSDK14在Application类里增加了ActivityLifecycleCallbacks，我们可以通过这个Callback拿到App所有Activity的生命周期回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道这些信息，我们就可以用更官方的办法来解决问题，只需要在Application的onCreate()里去注册上述接口，然后由Activity回调回来运行状态即可。</p>
<p>Android应用开发中一般认为back键是可以捕获的，而Home键是不能捕获的（除非修改framework）,但是上述方法从Activity生命周期着手解决问题，虽然这两种方式的Activity生命周期并不相同，但是二者都会执行onStop（）；所以并不关心到底是触发了哪个键切入后台的。另外,Application是否被销毁,都不会影响判断的正确性<strong>。</strong></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>（1）AndroidManifest.xml</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"mytest.example.com.broadcaststudy"</span>&gt;</span><br><span class="line">    &lt;application</span><br><span class="line">        android:name=<span class="string">".TestActivityLifecycleApplcation"</span></span><br><span class="line">            android:allowBackup=<span class="string">"true"</span></span><br><span class="line">                android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">                    android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">                        android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">                            android:theme=<span class="string">"@style/AppTheme"</span>&gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".SendBroadcastActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">                        &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".SecondActivity"</span>&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android混淆</title>
    <url>/Android-Garble/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>混淆，能过让我们的的APK更加的安全。没有混淆的APK，经过反编译，很容易就拿到源代码的资源文件，如直接使用Android Studio中的apk分析工具便可看到。因此我们需要读我们的APK进行混淆，混淆又分为两种：1.代码混淆；2.资源混淆。<a href="https://developer.android.com/studio/build/shrink-code?hl=zh-cn" target="_blank" rel="noopener">Android官网</a>也有简略的对其说明</p>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><h3 id="混淆原理"><a href="#混淆原理" class="headerlink" title="混淆原理"></a>混淆原理</h3><p>Java 是一种跨平台、解释型语言，Java 源代码编译成的class文件中有大量包含语义的变量名、方法名的信息，很容易被反编译为Java 源代码。为了防止这种现象，我们可以对Java字节码进行混淆。混淆不仅能将代码中的类名、字段、方法名变为无意义的名称，保护代码，也由于移除无用的类、方法，并使用简短名称对类、字段、方法进行重命名缩小了程序的size。</p>
<h3 id="混淆工具"><a href="#混淆工具" class="headerlink" title="混淆工具"></a>混淆工具</h3><p><a href="https://www.guardsquare.com/en/products/proguard" target="_blank" rel="noopener">ProGuard</a>是一个代码优化工具，它能够很好的堆对代码进行优化，并且能够它已近集成在Android构建环境中，我们进行配置非常方便。它对代码的优化由shrink、optimize、obfuscate和preverify四个步骤组成，每个步骤都是可选的，需要哪些步骤都可以在脚本中配置。 </p>
<ul>
<li><strong>压缩(Shrink)</strong>: 侦测并移除代码中无用的类、字段、方法、和特性(Attribute)。</li>
<li><strong>优化(Optimize)</strong>: 分析和优化字节码。</li>
<li><strong>混淆(Obfuscate)</strong>: 使用a、b、c、d这样简短而无意义的名称，对类、字段和方法进行重命名。</li>
</ul>
<p>上面三个步骤使代码size更小，更高效，也更难被逆向工程。</p>
<ul>
<li><strong>预检(Preveirfy)</strong>:  在java平台上对处理后的代码进行预检。</li>
</ul>
<p>混淆流程如下：</p>
<p><img src="/Android-Garble/proguard流程.png" alt="proguard流程"></p>
<p>Proguard读入input jars(or wars,zips or directories)，经过四个步骤生成处理之后的jars(or wars,ears,zips or directories),Optimization步骤可选择多次进行。</p>
<p>为了确定哪些代码应该被保留，哪些代码应该被移除或混淆，Proguard需要确定一个或多个<strong>Entry Point</strong>（类似标记）。Entry Point经常是带有main methods,applets,midlets的classes,它们在混淆过程中会被保留。我们来看一下Proguard的几个步骤如何处理Entry Points：</p>
<ol>
<li>在压缩阶段，Proguard从上述Entry Points开始遍历搜索哪些类和类成员被使用。其他没有被使用的类和类成员会移除。</li>
<li>在优化阶段，Proguard进一步设置非Entry Point的类和方法为private、static和final来进行优化，不使用的参数会被移除，某些方法会被标记被内联。</li>
<li>在混淆阶段，Proguard重命名非Entry Points的类和类成员。</li>
<li>预检阶段是唯一没有触及Entry Points的阶段。</li>
</ol>
<h3 id="开启混淆"><a href="#开启混淆" class="headerlink" title="开启混淆"></a>开启混淆</h3><p>在<code>build.gradle</code>中配置如下便可开启混淆：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="literal">true</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>minifyEnabled</code>表示混淆是否开启，<code>proguardFiles</code>表示混淆规则文件,它默认从 AndroidSDK—tools/proguard/ 文件夹获<code>proguard-android.txt</code>这个文件的规则进行混淆，后面的<code>proguard-rules.pro</code>使我们自己的规则配置文件，在<code>build.guild</code>文件旁。</p>
<h3 id="构建输出"><a href="#构建输出" class="headerlink" title="构建输出"></a>构建输出</h3><p>混淆打包后会在 <code>/build/outputs/mapping/release/</code> 目录下会输出以下文件：</p>
<ul>
<li><code>dump.txt</code><br>描述APK文件中所有类的内部结构</li>
<li><code>mapping.txt</code><br>提供混淆前后类、方法、类成员等的对照表</li>
<li><code>seeds.txt</code><br>列出没有被混淆的类和成员</li>
<li><code>usage.txt</code><br>列出被移除的代码</li>
</ul>
<p>这些文件要保存备份好，以后Bug调试、堆栈跟踪或者解码的时候就会使用到。</p>
<h3 id="Proguard关键字"><a href="#Proguard关键字" class="headerlink" title="Proguard关键字"></a>Proguard关键字</h3><p>保留选项：</p>
<ul>
<li>-keep {Modifier} {class_specification} 保留类和类中的成员，防止它们被混淆或移除。</li>
<li>-keepclassmembers {modifier} {class_specification} 保护指定类的成员，如果此类受到保护他们会保护的更好。</li>
<li>-keepclasseswithmembers {class_specification} 保留类和类中的成员，防止它们被混淆或移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。</li>
<li>-keepnames {class_specification} 保留类和类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。</li>
<li>-keepclassmembernames {class_specification} 只保留类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。</li>
<li>-keepclasseswithmembernames {class_specification} 保留类和类中的成员，防止它们被混淆，但当成员没有被引用时会被移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。</li>
</ul>
<p>压缩：</p>
<ul>
<li>-dontshrink 不压缩输入的类文件</li>
<li>-whyareyoukeeping {class_specification}</li>
</ul>
<p>优化：</p>
<ul>
<li>-dontoptimize 不优化输入的类文件</li>
<li>-assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用</li>
<li>-allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员</li>
</ul>
<p>混淆：</p>
<ul>
<li>-dontobfuscate 不混淆输入的类文件</li>
<li>-obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称</li>
<li>-overloadaggressively 混淆时应用侵入式重载</li>
<li>-useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆</li>
<li>-flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中</li>
<li>-repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中</li>
<li>-dontusemixedcaseclassnames 混淆时不会产生形形色色的类名</li>
<li>-keepattributes {attribute_name,…} 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses.</li>
<li>-renamesourcefileattribute {string} 设置源文件中给定的字符串常量</li>
</ul>
<p>输出：</p>
<ul>
<li>-printseeds {filename} 列出类和类的成员-keep选项的清单，标准输出到给定的文件</li>
<li>-printusage {filename}</li>
</ul>
<p>通配符：</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;field&gt;</code></td>
<td>匹配类中的所有字段</td>
</tr>
<tr>
<td><code>&lt;method&gt;</code></td>
<td>匹配类中的所有方法</td>
</tr>
<tr>
<td><code>&lt;init&gt;</code></td>
<td>匹配类中的所有构造函数</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意长度字符，但不含包名分隔符(.)。比如说我们的完整类名是com.example.test.MyActivity，使用com.<em>，或者com.exmaple.<em>都是无法匹配的，因为</em>无法匹配包名中的分隔符，正确的匹配方式是com.exmaple.</em>.<em>，或者com.exmaple.test.</em>，这些都是可以的。但如果你不写任何其它内容，只有一个*，那就表示匹配所有的东西。</td>
</tr>
<tr>
<td>**</td>
<td>匹配任意长度字符，并且包含包名分隔符(.)。比如proguard-android.txt中使用的-dontwarn android.support.**就可以匹配android.support包下的所有内容，包括任意长度的子包。</td>
</tr>
<tr>
<td>***</td>
<td>匹配任意参数类型。比如void set<em>(<strong><em>)就能匹配任意传入的参数类型，</em></strong> get</em>()就能匹配任意返回值的类型。</td>
</tr>
<tr>
<td>…</td>
<td>匹配任意长度的任意类型参数。比如void test(…)就能匹配任意void test(String a)或者是void test(int a, String b)这些方法。</td>
</tr>
</tbody></table>
<blockquote>
<p>在android中在android Manifest文件中的activity，service，provider， receviter，等都不能进行混淆。一些在xml中配置的view也不能进行混淆，android提供的默认配置中都有。</p>
</blockquote>
<blockquote>
<p>keep和keepclasseswithmembers区别在于：keep关键字看到class *就认为应该将所有类名进行保留，不关心{}中的参数。而keepclasseswithmembers前提是{}的类中的成员必须存在，如果不存在则还是会混淆</p>
</blockquote>
<h3 id="不能混淆的东西"><a href="#不能混淆的东西" class="headerlink" title="不能混淆的东西"></a>不能混淆的东西</h3><ol>
<li>Android 程序 ，下面这样代码混淆的时候要注意保留。</li>
<li>Android系统组件，系统组件有固定的方法被系统调用。</li>
<li>被Android Resource 文件引用到的。名字已经固定，也不能混淆，比如自定义的View 。</li>
<li>Android Parcelable ，需要使用android 序列化的。</li>
<li>android.app.backup.BackupAgentHelper</li>
<li>android.preference.Preference</li>
<li>com.android.vending.licensing.ILicensingService</li>
<li>Java序列化方法，系统序列化需要固定的方法。</li>
<li>枚举 ，系统需要处理枚举的固定方法。</li>
<li>native 本地方法，不能修改本地方法名</li>
<li>annotations 注释</li>
<li>数据库驱动</li>
<li>有些resource 文件</li>
<li>用到反射的地方，比如调用aidl</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>一、打包过程中，提示 Warning: can’t find superclass or interface/ Warning: can’t find referenced class等警告信息！<br> 解决方法：</p>
<ol>
<li>确保你的代码是否使用这个类，如果使用了，查看对应的第三方包有没有加上去，并且是否拉下来存在项目中</li>
<li>如果该类存在，工程中确实使用了这个类，就在proguard中加上<code>-keep class com.xx.yy.** { *;}</code>，让当前类不混淆。</li>
<li>确保报错的类没有在你的项目中使用到,可以使用”-dontwarn 类名正则表达式”屏蔽警告。</li>
</ol>
<p> 二、程序中使用泛型导致运行错误！<br> 使用的泛型需要在混淆配置文件加了一个过滤泛型的语句，如下。<br> -keepattributes Signature</p>
<h2 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h2>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>IMAP</title>
    <url>/Internet-IMAP/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IMAP（Internet Mail Access Protocol）网络邮件访问协议是一个应用层协议，用于从本地客户端访问远程服务器上的邮件。现在的版本是4rev1（IMAP4rve1）。IMAP协议运行在TCP/IP协议之上，SSL使用的端口是<strong>993</strong>，非SSL使用的端口号是<strong>143</strong>。IMAP的权威定义是RFC3501，具体协议内容可以查阅此<a href="http://www.faqs.org/rfcs/rfc3501.html" target="_blank" rel="noopener">http://www.faqs.org/rfcs/rfc3501.html</a>，中文版的在<a href="http://blog.csdn.net/qqnnhhbb/article/details/6428681" target="_blank" rel="noopener">http://blog.csdn.net/qqnnhhbb/article/details/642868</a>。</p>
<h2 id="和POP3的区别"><a href="#和POP3的区别" class="headerlink" title="和POP3的区别"></a>和POP3的区别</h2><p>传统的POP3协议是将服务器上的文件下载到本地，然后对本地的邮件进行操作，操作是不会反馈到服务器上的。而IMAP提供服务端和客户端之间的双向通信，客户端和服务端的每个操作都会同步。同时，IMAP也提供邮件下载的服务，并且能够访问邮件的每一个MIME部分（几乎所有邮件都是以MIME格式传输），让我们能够根据时间、主题、发件人等信息确定是否下载邮件。此外，IMAP支持多设备随时访问邮件。</p>
<h2 id="IMAP连接"><a href="#IMAP连接" class="headerlink" title="IMAP连接"></a>IMAP连接</h2><p>一次基本的IMAP连接有以下基本完成：</p>
<ol>
<li>建立服务端和客户端的链接</li>
<li>服务器初始欢迎</li>
<li>服务器和客户端进行交互，交互形式为：<ol>
<li>客户端发送命令</li>
<li>服务器返回请求数据</li>
<li>服务器返回完成响应</li>
</ol>
</li>
</ol>
<p>客户端命令引发操作。每个客户端命令以一个标识作为前缀（典型的有字母、数字构成的短字符串，如：A001，A002，等等）――它称为“标签”。客户端为每个命令生成不同的“标签”，也称每个客户端命令都是标签化的。</p>
<p>IMAP服务器端的协议接收端，从客户端读取命令行，解析该命令行及其参数，并传送服务器数据（非标签化，以*或+开头）及一个服务器命令（标签化，有与客户端请求命令相同的前缀）完成结果的响应。</p>
<h2 id="协议状态"><a href="#协议状态" class="headerlink" title="协议状态"></a>协议状态</h2><p>一旦客户端和服务器间的连接建立完成，一个IMAP4rev1连接就会处于4种状态中的某一种：</p>
<ol>
<li>未认证状态 ：在未认证状态下，大多数命令在得到许可前，客户端必须提供认证证书。若非连接已经是预认证了的，一个连接开始时，就进入了未认证状态。 </li>
<li>认证状态 ：在认证状态下，客户端是认证了的，它必须先于影响邮件的命令被许可前，选择一个邮箱以访问。当一个预认证连接开始，被认可的认证证书已经提供，选择一个邮箱发生错误后，或者一个成功的CLOSE命令后，就进入了认证状态。</li>
<li>选中状态 ：在一个选中状态，一个邮箱被选中以访问。当一个邮箱被成功选中时，就进入了这个状态。</li>
<li>注销状态 ：在注销状态下，连接正在被终止。一个客户端请求（通过LOGOUT命令），或者客户端、服务器的单方面动作，都会导致进入这个状态。</li>
</ol>
<p>之所以提及到状态，是因为IMAP协议的很多指令只有在处于某种状态下才会有效。下面是一些基本指令的作用的权限：</p>
<ol>
<li>在任何状态下都有效的指令（全局命令）：CAPALIBILY，NOOP，LOGOUT。</li>
<li>未认证状态下有效的指令（未认证状态命令）：STARTTLS,AUTHENTICATE，LOGIN和全局命令。</li>
<li>认证状态下有效的指令（认证状态命令）：SELECT，EXAMINE，CREATE，DELETE，RENAME，SUBSCRIBE，UNSUBSCRIBE，LIST，LSUB，STATUS，APPEND和全局命令</li>
<li>在选中状态下有效的指令（选中状态指令）：CHECK，CLOSE，EXPUNGE，SEARCH，FETCH，STORE，COPY，UID和全局命令、认证状态命令</li>
</ol>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="create-folder"><a href="#create-folder" class="headerlink" title="create {folder}"></a>create {folder}</h3><p>CREATE可以创建指定名字的新邮箱。邮箱名称通常是带路径的文件夹全名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A003 CREATE owatagusiam/                 </span><br><span class="line">S: A003 OK CREATE completed</span><br><span class="line">C: A004 CREATE owatagusiam/blurdybloop  </span><br><span class="line">S: A004 OK CREATE completed</span><br></pre></td></tr></table></figure>

<h3 id="DELETE-folder"><a href="#DELETE-folder" class="headerlink" title="DELETE {folder}"></a>DELETE {folder}</h3><p>DELETE命令删除指定名字的文件夹。文件夹名字通常是带路径的文件夹全名，当邮箱被删除后，其中的邮件也不复存在。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A683 DELETE blurdybloop</span><br><span class="line">S: A683 OK DELETE completed</span><br><span class="line">C: A684 DELETE foo</span><br><span class="line">S: A684 NO Name <span class="string">"foo"</span> has inferior hierarchical names</span><br><span class="line">C: A685 DELETE foo/bar</span><br><span class="line">S: A685 OK DELETE Completed</span><br></pre></td></tr></table></figure>

<h3 id="RENAME-old-folder-new-folder"><a href="#RENAME-old-folder-new-folder" class="headerlink" title="RENAME {old folder}{new folder}"></a>RENAME {old folder}{new folder}</h3><p>RENAME命令可以修改文件夹的名称，它使用两个参数：当前邮箱名和新邮箱名，两个参数的命名符合标准路径命名规则。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A683 RENAME blurdybloop sarasoop</span><br><span class="line">S: A683 OK RENAME completed</span><br><span class="line">C: A684 RENAME stuff/junk newbox        </span><br><span class="line">S: A684 OK RENAME Completed</span><br></pre></td></tr></table></figure>

<h3 id="LIST-BASE-template"><a href="#LIST-BASE-template" class="headerlink" title="LIST {BASE}{template}"></a>LIST {BASE}{template}</h3><p>LIST命令用于列出邮箱中已有的文件夹，有点像操作系统的列目录命令，有两个参数，邮箱路径参数BASE：表示用户登陆目录；第二个参数template：表示希望显示的邮箱名。这个命令可以包含起始的路径位置和需要列出的文件夹所符合的特征，可以使用通配符”*”。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A101 LIST <span class="string">""</span> <span class="string">""</span></span><br><span class="line">S: * LIST (\Noselect) <span class="string">"/"</span> <span class="string">""</span></span><br><span class="line">S: A101 OK LIST Completed</span><br><span class="line">C: A102 LIST <span class="comment">#news.comp.mail.misc ""</span></span><br><span class="line">S: * LIST (\Noselect) <span class="string">"."</span> <span class="comment">#news.</span></span><br><span class="line">S: A102 OK LIST Completed</span><br><span class="line">C: A103 LIST /usr/staff/jones <span class="string">""</span></span><br><span class="line">S: * LIST (\Noselect) <span class="string">"/"</span> /</span><br><span class="line">S: A103 OK LIST Completed</span><br><span class="line">C: A202 LIST ~/Mail/ %</span><br><span class="line">S: * LIST (\Noselect) <span class="string">"/"</span> ~/Mail/foo</span><br><span class="line">S: * LIST () <span class="string">"/"</span> ~/Mail/meetings</span><br><span class="line">S: A202 OK LIST completed</span><br></pre></td></tr></table></figure>

<h3 id="APPEND-folder-attributes-date-time-size-mail-data"><a href="#APPEND-folder-attributes-date-time-size-mail-data" class="headerlink" title="APPEND {folder}{attributes}{date/time}{size}{mail data}"></a>APPEND {folder}{attributes}{date/time}{size}{mail data}</h3><p>APPEND命令允许Client上载一个邮件到指定的Folder（文件夹/邮箱）中。命令中包含了新邮件的属性、日期/时间、大小，随后是邮件数据。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A003 APPEND saved<span class="literal">-messages</span> (\Seen) &#123;<span class="number">310</span>&#125;</span><br><span class="line">C: Date: Mon， <span class="number">7</span> Feb <span class="number">1994</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">25</span> <span class="literal">-0800</span> (PST)</span><br><span class="line">C: From: Fred Foobar &lt;foobar@Blurdybloop.COM&gt;</span><br><span class="line">C: Subject: afternoon meeting</span><br><span class="line">C: To: mooch@owatagu.siam.edu</span><br><span class="line">C: Message<span class="literal">-Id</span>: &lt;B27397<span class="literal">-0100000</span>@Blurdybloop.COM&gt;</span><br><span class="line">C: MIME<span class="literal">-Version</span>: <span class="number">1.0</span></span><br><span class="line">C: Content<span class="literal">-Type</span>: TEXT/PLAIN; CHARSET=US<span class="literal">-ASCII</span></span><br><span class="line">C:</span><br><span class="line">C: Hello Joe， <span class="keyword">do</span> you think we can meet at <span class="number">3</span>:<span class="number">30</span> tomorrow?</span><br><span class="line">C:</span><br><span class="line">S: A003 OK APPEND completed</span><br></pre></td></tr></table></figure>

<h3 id="SELECT-folder"><a href="#SELECT-folder" class="headerlink" title="SELECT {folder}"></a>SELECT {folder}</h3><p>SELECT命令让Client选定某个邮箱（Folder），表示即将对该邮箱（Folder）内的邮件作操作。邮箱标志的当前状态也返回给了用户，同时返回的还有一些关于邮件和邮箱的附加信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A142 SELECT INBOX</span><br><span class="line">S: * <span class="number">172</span> EXISTS</span><br><span class="line">S: * <span class="number">1</span> RECENT</span><br><span class="line">S: * OK [<span class="type">UNSEEN</span> <span class="number">12</span>] Message <span class="number">12</span> is first unseen</span><br><span class="line">S: * OK [<span class="type">UIDVALIDITY</span> <span class="number">3857529045</span>] UIDs valid</span><br><span class="line">S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)</span><br><span class="line">S: * OK [<span class="type">PERMANENTFLAGS</span> (\<span class="type">Deleted</span> \<span class="type">Seen</span> \*)] Limited</span><br><span class="line">S: A142 OK [<span class="built_in">READ-WRITE</span>] SELECT completed</span><br></pre></td></tr></table></figure>

<h3 id="FETCH-mail-id-datanames"><a href="#FETCH-mail-id-datanames" class="headerlink" title="FETCH {mail id}{datanames}"></a>FETCH {mail id}{datanames}</h3><p>FETCH 命令用于读取邮件的文本信息，且仅用于显示的目的。包含两个参数，messageset：表示希望读取的邮件号列表，IAMP服务器邮箱中的每个邮件都有一个唯一的ID标识，（邮件号列表参数可以是一个邮件号，也可以是由逗号分隔的多个邮件号，或者由冒号间隔的一个范围），IMAP服务器返回邮件号列表中全部邮件的指定数据项内容。</p>
<p>数据名参数确定能够被独立返回的邮件的一部分，下面我们看看各参数返回的邮件信息：</p>
<ul>
<li>ALL：只返回按照一定格式的邮件摘要，包括邮件标志、RFC822.SIZE、自身的时间和信封信息。IMAP客户机能够将标准邮件解析成这些信息并显示出来。</li>
<li>BODY：只返回邮件体文本格式和大小的摘要信息。IMAP客户机可以识别这些细腻，并向用户显示详细的关于邮件的信息。其实是一些非扩展的BODYSTRUCTURE的信息。</li>
<li>FAST：只返回邮件的一些摘要，包括邮件标志、RFC822.SIZE、和自身的时间。</li>
<li>FULL：同样的还是一些摘要信息，包括邮件标志、RFC822.SIZE、自身的时间和BODYSTRUCTURE的信息。</li>
<li>BODYSTRUCTUR：是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来的。包括的内容有：邮件正文的类型、字符集、编码方式等和各附件的类型、字符集、编码方式、文件名称等等。</li>
<li>ENVELOPE：信息的信封结构。是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段得出来的，默认各字段都是需要的。主要包括：自身的时间、附件数、收件人、发件人等。</li>
<li>FLAGS：此邮件的标志。<br>INTERNALDATE：自身的时间。</li>
<li>RFC822.SIZE：邮件的[RFC-2822]大小<br>RFC822.HEADER：在功能上等同于BODY.PEEK[HEADER]。</li>
<li>RFC822：功能上等同于BODY[]。</li>
<li>RFC822.TEXT：功能上等同于BODY[TEXT]。</li>
<li>UID：返回邮件的UID号，UID号是唯一标识邮件的一个号码。</li>
<li>BODY[section] {partial}：返回邮件的中的某一指定部分，返回的部分用section来表示，section部分包含的信息通常是代表某一部分的一个数字或者是下面的某一个部分：HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, and TEXT。如果section部分是空的话，那就代表返回全部的信息，包括头信息。</li>
<li>BODY[HEADER]返回完整的文件头信息。</li>
<li>BODY[HEADER.FIELDS ()]：在小括号里面可以指定返回的特定字段。</li>
<li>BODY[HEADER.FIELDS.NOT ()]：在小括号里面可以指定不需要返回的特定字段。</li>
<li>BODY[MIME]：返回邮件的[MIME-IMB]的头信息，在正常情况下跟BODY[HEADER]没有区别。</li>
<li>BODY[TEXT]：返回整个邮件体，这里的邮件体并不包括邮件头。</li>
</ul>
<p>现在我们遇到了一个问题，如果我们要单独提取邮件的附件怎么办？<br>通过以上的命令我们是无法做到的，但是我们别忘了在section部分还有其他的方式可以来表示我们要提取的邮件的部分，那就的通过区段数来表示。那下面就让我们来看看什么是区段数。</p>
<p>每个邮件都至少有一个区段数，Non-[MIME-IMB]型的邮件和non-multipart [MIME-IMB]的邮件是没有经过MIME编码之后的信息的，那这样的信息只有一个区段数1。多区段型的信息被编排成一个连续的区段数，这和实际信息里出现的是一样的。如果一个特定的区段有类型信息或者是多区段的，一个MESSAGE/RFC822类型的区段也含有嵌套的区段数，这些区段数是指向这些信息区段的信息体的。</p>
<p>说了那么多拗口的，现在我们讲的更简单易懂一些。在一个邮件体里面，区段数1代表的邮件的正文，区段数二代表的是第一个附件，区段数三代表的是第二个附件，以此类推。在这些区段里，如果有哪个区段又是多区段的，比如2区段的内容格式是mulipart或者是 MESSAGE/RFC822类型的，那么这个区段又嵌套了多个子区段，嵌套的各子区段是用2.1，2.2……等等表示，类似，如果2.1又有嵌套，那么还会有2.1.1，2.1.2等区段。这样的嵌套是没有限制的。下面我们通过例子来了解一下fetch具体是怎么按区段下载的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEADER ([RFC-2822] header of the message)</span><br><span class="line">TEXT ([RFC-2822] text body of the message) MULTIPART&#x2F;MIXED</span><br><span class="line">1 TEXT&#x2F;PLAIN</span><br><span class="line">2 APPLICATION&#x2F;OCTET-STREAM</span><br><span class="line">3 MESSAGE&#x2F;RFC822</span><br><span class="line">3.HEADER ([RFC-2822] header of the message)</span><br><span class="line">3. TEXT ([RFC-2822] text body of the message) MULTIPART&#x2F;MIXED</span><br><span class="line">3.1 TEXT&#x2F;PLAIN</span><br><span class="line">3.2 APPLICATION&#x2F;OCTET-STREAM</span><br><span class="line">4 MULTIPART&#x2F;MIXED</span><br><span class="line">4.1 IMAGE&#x2F;GIF</span><br><span class="line">4.1. MIME ([MIME-IMB] header for the IMAGE&#x2F;GIF)</span><br><span class="line">4.2 MESSAGE&#x2F;RFC822</span><br><span class="line">4.2. HEADER ([RFC-2822] header of the message)</span><br><span class="line">4.2. TEXT ([RFC-2822] text body of the message) MULTIPART&#x2F;MIXED</span><br><span class="line">4.2.1 TEXT&#x2F;PLAIN</span><br><span class="line">4.2.2 MULTIPART&#x2F;ALTERNATIVE</span><br><span class="line">4.2.2.1 TEXT&#x2F;PLAIN</span><br><span class="line">4.2.2.2 TEXT&#x2F;RICHTEXT</span><br></pre></td></tr></table></figure>

<p>如果我们需要取第一个附件，那么命令就是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:a2 fetch <span class="number">4</span> body[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>取第三个区段的第一个子区段文本正文，命令就是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:a2 fetch <span class="number">4</span> body[<span class="number">3.1</span>]</span><br></pre></td></tr></table></figure>

<p>取第四个区段的第二个子区段再嵌套的第一个子区段的文本正文，命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:a2 fetch <span class="number">4</span> body[<span class="number">4.2</span><span class="type">.1</span>]</span><br></pre></td></tr></table></figure>

<p>当然这个例子只是针对于一个特殊的邮件结构，一般的邮件应该都没有这么复杂的结构。</p>
<p>再接下来我们再看看最后一个参数有什么用？BODY[section]可以使用partial字段进行修改，该字段包含两个用“.”隔开的数字，第一个数字、是八进制表示的希望显示的数据输出起始位置，第二个数字是八进制表示希望显示的数据长度。这项功能可以进一步设定输出格式，例如，如果你希望显示1号邮件中邮件提的前1500个字符，可以使用命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">FETCH <span class="number">1</span> BODY[<span class="type">TEXT</span>]&lt;<span class="number">0.1500</span>&gt;</span><br></pre></td></tr></table></figure>

<p>该命令取回邮件提的前1500个字符并定义为TEXT，如果邮件体少于1500个字符则返回整个邮件体。</p>
<p>例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: <span class="number">100</span> FETCH <span class="number">3</span>：<span class="number">5</span>  BODY[<span class="type">header.fields</span> (<span class="type">Date</span> <span class="type">From</span> <span class="type">Subject</span>)]  </span><br><span class="line">S: *  <span class="number">3</span>  FETCH  (BODY[<span class="type">HEADER.FIELDS</span> (“<span class="type">DATE</span>” “<span class="type">FROM</span>” “<span class="type">SUBJECT</span>”)]  &#123;<span class="number">112</span>&#125;</span><br><span class="line">DATE: Tue, <span class="number">14</span> Sep <span class="number">1999</span> <span class="number">10</span>:<span class="number">09</span>:<span class="number">50</span> <span class="literal">-500</span></span><br><span class="line">From: alex@shadrach.smallorg.org</span><br><span class="line">Subject: This is the first test message</span><br><span class="line">)</span><br><span class="line">S: *  <span class="number">4</span>  FETCH  (BODY[<span class="type">HEADER.FIELDS</span> (“<span class="type">DATE</span>” “<span class="type">FROM</span>” “<span class="type">SUBJECT</span>”)]  &#123;<span class="number">113</span>&#125;</span><br><span class="line">DATE: Tue, <span class="number">14</span> Sep <span class="number">1999</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">04</span> <span class="literal">-500</span></span><br><span class="line">From: alex@shadrach.smallorg.org</span><br><span class="line">Subject: This is the second test message</span><br><span class="line">)</span><br><span class="line">S: *  <span class="number">5</span>  FETCH  (BODY[<span class="type">HEADER.FIELDS</span> (“<span class="type">DATE</span>” “<span class="type">FROM</span>” “<span class="type">SUBJECT</span>”)]  &#123;<span class="number">112</span>&#125;</span><br><span class="line">DATE: Tue, <span class="number">14</span> Sep <span class="number">1999</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">26</span> <span class="literal">-500</span></span><br><span class="line">From: alex@shadrach.smallorg.org</span><br><span class="line">Subject: This is the first test message</span><br><span class="line">S: A100 OK FETCH completed</span><br><span class="line">C: A101 FETCH BODY[<span class="type">TEXT</span>]</span><br><span class="line">S:* This is the fourth test message <span class="keyword">for</span> IMAP</span><br><span class="line">S: A101 OK FETCH completed</span><br></pre></td></tr></table></figure>

<p>FETCH命令是IMAP协议里最复杂的命令。FETCH的命令参数很多、很复杂，但基本的特征是允许将邮件按照MIME结构拆解为零碎的部件来提取。例如，可以利用FETCH命令提取邮件头、某一个附件、或某一邮件附件头部的某一字段，等等。</p>
<h3 id="STORE-mail-id-new-attributes"><a href="#STORE-mail-id-new-attributes" class="headerlink" title="STORE {mail id}{new attributes}"></a>STORE {mail id}{new attributes}</h3><p>STORE 命令用于修改指定邮件的属性，包括给邮件打上已读标记、删除标记，等等。STORE命令当前只有两个数据项类型可用，FLAGS：表示邮件的一组标志； FLAGS.SLIENT，表示一组邮件的标志，通过在两种数据项前加上加号或者减号可以进一步改变它们的执行情况，加号表示数据项的值添加到邮件中，减号表示将数据项的值从邮件中删除。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A003 STORE <span class="number">2</span>:<span class="number">4</span> +FLAGS (\Deleted)     </span><br><span class="line">S: * <span class="number">2</span> FETCH FLAGS (\Deleted \Seen)</span><br><span class="line">S: * <span class="number">3</span> FETCH FLAGS (\Deleted)</span><br><span class="line">S: * <span class="number">4</span> FETCH FLAGS (\Deleted \Flagged \Seen)</span><br><span class="line">S: A003 OK STORE completed</span><br></pre></td></tr></table></figure>



<h3 id="CLOSE"><a href="#CLOSE" class="headerlink" title="CLOSE"></a>CLOSE</h3><p>CLOSE命令表示Client结束对当前Folder（文件夹/邮箱）的访问，关闭邮箱该邮箱中所有标志为、DELETED的邮件就被从物理上删除。CLOSE没有命令参数。随后可以SELECT另一Folder。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A341 CLOSE</span><br><span class="line">S: A341 OK CLOSE completed</span><br></pre></td></tr></table></figure>



<h3 id="EXPUNGE"><a href="#EXPUNGE" class="headerlink" title="EXPUNGE"></a>EXPUNGE</h3><p>EXPUNGE命令在不关闭邮箱的情况下删除所有的标志为、DELETED的邮件。EXPUNGE删除的邮件将不可以恢复。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A202 EXPUNGE</span><br><span class="line">S: * <span class="number">3</span> EXPUNGE</span><br><span class="line">S: * <span class="number">3</span> EXPUNGE</span><br><span class="line">S: * <span class="number">5</span> EXPUNGE</span><br><span class="line">S: * <span class="number">8</span> EXPUNGE</span><br><span class="line">S: A202 OK EXPUNGE completed</span><br></pre></td></tr></table></figure>



<h3 id="EXAMINE-mailbox"><a href="#EXAMINE-mailbox" class="headerlink" title="EXAMINE {mailbox}"></a>EXAMINE {mailbox}</h3><p>EXAMINE命令以只读方式打开邮箱，参数是需要打开的邮箱的名字，使用EXAMINE命令打开的邮箱不允许对邮件进行改动，因此不能增加或删除邮件的标志。</p>
<h3 id="SUBSCRIBE-mailbox"><a href="#SUBSCRIBE-mailbox" class="headerlink" title="SUBSCRIBE {mailbox}"></a>SUBSCRIBE {mailbox}</h3><p>SUBSCRIBE命令用来在客户机的活动邮箱列表中增加一个邮箱，该命令只有一个参数，希望添加的邮箱名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A114 SUBSCRIBE new/anotherbox</span><br><span class="line">S: A114 OK SUBSCRIBE completed</span><br></pre></td></tr></table></figure>



<h3 id="UNSUBSCRIBE-mailbox"><a href="#UNSUBSCRIBE-mailbox" class="headerlink" title="UNSUBSCRIBE {mailbox}"></a>UNSUBSCRIBE {mailbox}</h3><p>UNSUBSCRIBE命令用来从活动列表中去掉一个邮箱，一个参数：希望去掉的邮箱名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A115 UNSUBSCRIBE new/anotherbox</span><br><span class="line">S: A115 OK SUBSCRIBE completed</span><br></pre></td></tr></table></figure>



<h3 id="LSUB-folder-mailbox"><a href="#LSUB-folder-mailbox" class="headerlink" title="LSUB {folder}{mailbox}"></a>LSUB {folder}{mailbox}</h3><p>LSUB命令修正了LIST命令，LIST返回用户$HOME目录下所有的文件，但LSUB命令只显示那些使用SUBSCRIBE命令设置为活动邮箱的文件。两个参数：邮箱路径和邮箱名。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A116 LSUB “” *</span><br><span class="line">S:* LSUB () “/” stuff/junk</span><br><span class="line">S:* LSUB () “/” neebox</span><br><span class="line">S:* LSUB () “/” new/anotherbox</span><br><span class="line">S: A116 OK LSUB completed</span><br></pre></td></tr></table></figure>



<h3 id="STATUS-mailbox-parameter1-parameter2-……-parameter5"><a href="#STATUS-mailbox-parameter1-parameter2-……-parameter5" class="headerlink" title="STATUS {mailbox}({parameter1}{parameter2}……{parameter5})"></a>STATUS {mailbox}({parameter1}{parameter2}……{parameter5})</h3><p>STATUS命令查询邮箱的当前状态。第一个参数是需要查询的邮箱名，第二个参数是客户机需要查询的项目列表（要查询显示的信息），当在圆括号中。STATUS可以在不使用SELECT命令（打开邮箱）或者EXAMINE（以只读方式打开邮箱）前提下获取邮箱的信息。</p>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MESSAGE</td>
<td align="center">邮箱中的邮件总数</td>
</tr>
<tr>
<td align="center">RECENT</td>
<td align="center">邮箱中标志为\RECENT的邮件数</td>
</tr>
<tr>
<td align="center">UIDNEXT</td>
<td align="center">可以分配给新邮件的下一个UID</td>
</tr>
<tr>
<td align="center">UIDVALIDITY</td>
<td align="center">邮箱的UID有效性标志</td>
</tr>
<tr>
<td align="center">UNSEEN</td>
<td align="center">邮箱中没有被标志为\UNSEEN的邮件数</td>
</tr>
</tbody></table>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A117 STATUS inbox  (message recent unseen)</span><br><span class="line">S:* STATUS inbox (MESSAGE <span class="number">1</span> RECENT <span class="number">0</span> UNSENN <span class="number">0</span>)</span><br><span class="line">S: A117 OK STATUS completed</span><br><span class="line">C: A118 STATUS newbox  (message recent unseen)</span><br><span class="line">S:* STATUS inbox (MESSAGE <span class="number">1</span> RECENT <span class="number">0</span> UNSENN <span class="number">2</span>)</span><br><span class="line">S: A118 OK STATUS completed</span><br></pre></td></tr></table></figure>



<h3 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h3><p>CHECK命令用来在邮箱设置一个检查点。没有参数。就是IMAP中的sync命令。任何未完成的操作，例如从服务器内存向硬盘写数据，都将会被做完以保持邮箱的一致性状态。该命令确保乃村中的磁盘缓冲数据都被写到了磁盘上。</p>
<h3 id="SEARCH-CHARSET-specification-search-criteria"><a href="#SEARCH-CHARSET-specification-search-criteria" class="headerlink" title="SEARCH [CHARSET specification] (search criteria)"></a>SEARCH [CHARSET specification] (search criteria)</h3><p>命令可以根据搜索条件在处于活动状态的邮箱中搜索邮件，然后显示匹配的邮件编号。字符集标志参数[CHARSET specification]由CHARSET和注册的字符集标志符组成，缺省的标志符是US-ASCⅡ，所以该参数长省略。search criteria：查询条件参数，明确查询的关键字和值。查询关键字有几十种。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A119 SEARCH header subject another</span><br><span class="line">S: SEARCH <span class="number">1</span> <span class="number">2</span></span><br><span class="line">S:* A119 OK SEARCH completed</span><br><span class="line">C: A120 SEARCH header subject another</span><br><span class="line">S: *SEARCH <span class="number">2</span></span><br><span class="line">S: A120 OK SEARCH completed</span><br><span class="line">C: A121 SEARCH UNSEEN</span><br><span class="line">S: *SEARCH <span class="number">1</span> <span class="number">2</span></span><br><span class="line">S: A120 OK SEARCH completed</span><br></pre></td></tr></table></figure>

<p>以上每个例子都在邮件头的Subject:字段中查询一个不同的单词。服务器返回条件的邮件号列表，如果没有匹配邮件则返回不带UID的SEARCH单词。</p>
<h3 id="COPY-mail-id-mailboxname"><a href="#COPY-mail-id-mailboxname" class="headerlink" title="COPY {mail id}{mailboxname}"></a>COPY {mail id}{mailboxname}</h3><p>COPY命令可以把邮件从一个邮箱复制到另一个邮箱，两个参数：mail id是希望从活动邮箱中复制的邮件的标号，mailboxname是希望邮件被复制到的邮箱。IAMP没有定义移动邮件的命令，移动操作相当于先把邮件复制到新邮箱中，然后对源邮箱中的邮件设置\DELETED标志。下一次执行检查点过后，新邮箱中的邮件被删除，新邮件就被显示出来。</p>
<h3 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h3><p>UID 命令和FETCH、COPY、STORE命令或者SEARCH命令一起使用，它允许这些命令使用邮件的UID号而不是在邮箱中的顺序号。UID号是唯一标识邮件系统中邮件的32位证书。通常这些命令都使用顺序号来标识邮箱中的邮件，使用UID可以使IMAP客户机记住不同IMAP会话中的邮件。</p>
<h3 id="CAPABILITY"><a href="#CAPABILITY" class="headerlink" title="CAPABILITY"></a>CAPABILITY</h3><p>CAPABILITY命令请求返回IMAP服务器支持的功能列表，服务器收到客户机发送的CAPABILITY命令后将返回该服务器所支持的功能。无参数。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C: A122 CAPABILITY</span><br><span class="line">S:*A122 CAPABILITY IMAP4 IMAP4REVl NAMESPACE IDLE SCAN SORT   MAILBOX</span><br><span class="line">-<span class="literal">-REFERRALS</span> [<span class="type">ic</span>:<span class="type">ccc</span>] LOGIN<span class="literal">-REFERRALS</span> AUTH=LOGIN THREAD=</span><br><span class="line">ORDERDSUBJECT</span><br><span class="line">S: A122 OK CAPABILITY completed</span><br></pre></td></tr></table></figure>



<h3 id="NOOP"><a href="#NOOP" class="headerlink" title="NOOP"></a>NOOP</h3><p>NOOP命令什么也不做，用来向服务器发送自动命令，防止因长时间处于不活动状态而导致连接中断，服务器对该命令的响应始终为肯定。无参数。</p>
<h3 id="LOGOUT"><a href="#LOGOUT" class="headerlink" title="LOGOUT"></a>LOGOUT</h3><p>LOGOUT命令使当前登陆用户退出登陆并关闭所有打开的邮箱，任何做了\DELETED标志的邮件都将在这个时候被删除。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/VCS-Git/</url>
    <content><![CDATA[<h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p>不同于其他版本控制系统，Git是分布式的。每次一拉取到本地都是一个完整的项目而不仅仅是快照。并且它所执行的的操作几乎都是本地操作，就如你可以不用联网来查看历史版本。</p>
<h2 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h2><p>下面是git的三种状态和对应的工作区域的概念：</p>
<ul>
<li>已提交（committed）；Git仓库</li>
<li>已修改（modified）；工作目录</li>
<li>已暂存（staged）；暂存区域</li>
</ul>
<p><img src="/VCS-Git/工作目录、暂存区域以及Git仓库.PNG" alt="工作目录、暂存区域以及 Git 仓库"></p>
<p>Git 仓库目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。工作目录：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。</p>
<h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>获取Git仓库有两种方法：1.在现有的本地文件夹创建本地仓库，然后再提交到远程。2.从远程克隆仓库到本地。</p>
<h3 id="在现有目录初始化仓库"><a href="#在现有目录初始化仓库" class="headerlink" title="在现有目录初始化仓库"></a>在现有目录初始化仓库</h3><p>在文件夹中使用<code>git init</code>创建一个名为<code>.git</code>的文件夹，这是就已经创建好仓库了。然后可以使用<code>git add</code>命令跟踪指定的文件。可以使用<code>git commit</code>将文件提交到远程。</p>
<h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>使用<code>git clone</code>命令可以将远程全部的数据拷贝到本地。克隆仓库的命令格式是<code>git clone [url]</code> ，这里的url支持多种协议，https协议、git协议、SSH协议都支持。</p>
<h2 id="文件状态修改"><a href="#文件状态修改" class="headerlink" title="文件状态修改"></a>文件状态修改</h2><p>刚才有说到，我们自己创建仓库时需要跟踪文件后，git才会把它当做需要的文件去提交的远程。对于使用git管理的文件，它有四个状态：跟踪、未修改、已修改、暂存。</p>
<p><img src="/VCS-Git/文件的状态变化周期.PNG" alt="文件的状态变化周期"></p>
<p>查看什么文件处于什么状态，可以使用<code>git status</code>命令查看文件的状态，也可以使用<code>git status --short</code>查看简略版。使用<code>git add</code>命令可以使任何状态的文件变为暂存版本。    </p>
<p>除了<code>git status</code>可以查看状态，使用<code>git diff</code>可以知道具体修改了什么地方。<code>git diff</code>命令是比较工作目录中当前文件和暂存区快照之间的差异，就是修改了但没有<code>git add</code>的变化内容。若要查看已暂存的将要添加到下次提交里的内容，使用<code>git diff --cache</code>或者<code>git diff --staged</code>。</p>
<h2 id="文件提交更新"><a href="#文件提交更新" class="headerlink" title="文件提交更新"></a>文件提交更新</h2><p><code>git commit</code>命令使暂存区的文件提交。可以使用<code>git commit -m</code>把提交信息和命令放在同一行。</p>
<p>使用<code>git commit -a</code>可以跳过<code>git add</code>步骤，把所有跟踪文集暂存并且提交。    </p>
<h2 id="文件移除"><a href="#文件移除" class="headerlink" title="文件移除"></a>文件移除</h2><p>如果单单删除本地文件，git还是会跟踪，我们需要使用<code>git rm</code>命令来进行文件移除，同时可以删除本地文件。但是删除之前修改过并且已经放到暂存区，这样必须使用强制删除选项<code>git rm -f</code></p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>使用<code>git log</code>可以按提交时间列出所有的更新。这个命令可以携带参数，带上<code>-p</code>用来显示每次提交内容的差异。带上<code>-2</code>用来仅显示最近两次提交。<code>--stat</code>用来显示简略信息。<code>--pretty</code>用来指定使用不同于默认格式的方式展示提交历史。</p>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p><code>git commit --amend</code>命令：有时我们提交问完后发现有几个文件没有添加或者提交信息写错了，这时可以使用这个命令再次提交，这样我们最终只会有一个提交。</p>
<p><code>git reset HEAD [文件名]</code> 命令：有时我们有两个文件需要分别两次提交，但是不小心都add到了暂存区域。这时我们可以使用这个命令把其中一个移出暂存区域。</p>
<p><code>git checkout -- [文件名]</code>命令：这个命令能够撤销修改了的文件，将它还原成上次提交的样子。这个别乱用。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p><code>git remote</code>查看项目远程仓库。</p>
<p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code>给本地仓库添加一个远程仓库，让他们同步。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客的搭建</title>
    <url>/Blog-Build/</url>
    <content><![CDATA[<p><img src="/Blog-Build/Hexo+GitPage.jpg" alt="Hexo+GitPage"></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起搭建个人博客，以前的话都会想到使用<a href="https://zh-cn.wordpress.com/" target="_blank" rel="noopener">WordPress</a>，它功能强大，自定义的定制简单，但现在为止还有许多使用它的网站。但是，对于个人博客而言，我们平时都是写点小文章之类的，如果要去使用 WordPress 的话，需要搭建和维护一整套的LNMP，耗时耗力成本高。现在我们搭建个人博客的话，能偷懒就偷懒，直接使用静态博客，把博客的页面用框架全部生成好，再弄个HTTP服务器把页面挂上去，搞定！</p>
<h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><p>刚才有说到，现在我们搭建个人博客的话简化为以下三个步骤：</p>
<ul>
<li>写文章</li>
<li>用框架把文章生成页面</li>
<li>把页面挂到服务器上</li>
</ul>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>文章的话我还是推荐使用<a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown</a>格式来进行编写，不仅仅是因为它能够很好的配合框架转化为网页，我更喜欢的是它码起字来特别爽，可以双手不用离开键盘一敲到底。</p>
<p>对于Markdown的编写，可以选择的工具非常之多。个人比较推荐使用<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，一个界面简约的 Markdown 编辑器，在Win和Mac平台都有，能够源码和演示相互切换，而不是传统的分屏显示。而且它有侧边栏的目录管理和大纲，非常适合对多文章的编辑。而且还有不同主题选择，这是我最喜欢的，因为它能够自己写CSS来做主题，这样就可以把框架生成页面时那套CSS拿过来，直接就可以在编写文章时看出网页效果（当然我自己没有那么做，因为我懒）。</p>
<h3 id="生成框架"><a href="#生成框架" class="headerlink" title="生成框架"></a>生成框架</h3><p>框架也是网上一搜一大把，毕竟程序员非常的多，大前端的程序员就更加的多！下面是四款比较好的框架：</p>
<ul>
<li><a href="https://www.jekyll.com.cn/" target="_blank" rel="noopener">Jekyll</a> - 基于Ruby，第一个吃螃蟹的人，非常多人使用。</li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> - 基于Node,js，功能强大，什么插件npm上都有。</li>
<li><a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> - 来自Go社区，无依赖部署。</li>
<li><a href="https://www.gitbook.com" target="_blank" rel="noopener">GitBook</a> - 生成书籍文档样式的站点。</li>
</ul>
<p>类似的框架<a href="https://www.staticgen.com/" target="_blank" rel="noopener">非常之多</a>。</p>
<p>我比较推荐Hexo，它的作者是台湾人，对中文支持也友好，部署生成也比较方便，还可以本地调试。而且真的是什么插件都有，只有你想不到，大前端是真的厉害！</p>
<h3 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h3><p>我们要把网页挂上服务器，但是不是每个人都有一个服务器一直开着，我们还是选择一些第三方的服务。它们允许我们把写好的网页放到它们的服务器上给别人访问，而且还免费，良心啊！国外的Dropbox、Github都有提供这类服务，国内的Coding.net、码云也有模仿Github提供类似服务。</p>
<p>Dropbox因为墙的缘故访问有限，所以我推荐使用Github的<a href="https://pages.github.com/" target="_blank" rel="noopener">GithubPages</a>，免费良心商家。</p>
<h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>工具我们选择好了：Hexo+GithubPages。下面是搭建步骤。</p>
<ol>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>Github创建个人仓库</li>
<li>部署Hexo到Github上</li>
</ol>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>window上：到官网<a href="https://gitforwindows.org/" target="_blank" rel="noopener">gitforwindows</a>下载安装。</p>
<p>Linux上：<code>sudo apt-get install git</code></p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>window上：到官网<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node.js</a>选择LTS版下载</p>
<p>linux上：<code>sudo apt-get install nodejs</code>  、<code>sudo apt-get install npm</code></p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>输入<code>npm install hexo-cli -g</code>安装Hexo。选择好一个文件夹，cd到文件夹下，然后输入<code>hexo init</code>进行Hexo初始化。初始化后该文件夹会有如下一些重要部分：</p>
<ul>
<li>node_modules 依赖包</li>
<li>public 存放生成的页面</li>
<li>source 自己写的文章存放</li>
<li>themes 主题存放</li>
<li>_congif.yml 全局配置文件</li>
</ul>
<p>输入<code>hexo g</code>会根据你的source下的文章生成对应页面放到public下。</p>
<p>输入<code>hexo s</code>打开本地服务器，在浏览器输入<code>localhost:4000</code>便可看到你的博客的样子如下：</p>
<p><img src="/Blog-Build/博客首页.PNG" alt="本地博客"></p>
<h3 id="Github创建个人仓库"><a href="#Github创建个人仓库" class="headerlink" title="Github创建个人仓库"></a>Github创建个人仓库</h3><p>在你的github上New repository创建新仓库，仓库的名称需要是“你的Github账户名.github.io”，如下图：</p>
<p><img src="/Blog-Build/创建个人仓库.PNG" alt="创建仓库"></p>
<h3 id="部署Hexo到Github上"><a href="#部署Hexo到Github上" class="headerlink" title="部署Hexo到Github上"></a>部署Hexo到Github上</h3><p>最后一步，将你的Hexo部署到Github上。先打开<code>_config.yml</code>文件，在最后面的deploy中添加上git上传方式：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span> <span class="comment">#上传类型</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/junzkn/junzkn.github.io.git</span> <span class="comment">#仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment">#分支选择</span></span><br></pre></td></tr></table></figure>

<p>配置好这个文件后，安装一个deploy-git的上传插件<code>npm install hexo-deployer-git --save</code>。用这个插件才能上传到github上。</p>
<p>最后<code>hexo d</code>便可以把你的public中的内容传到github上，这是我们的个人博客就已经完成了。在浏览器中输入<code>你的github账户名.github.io</code>就可以顺利访问到你挂在github上的网页：</p>
<p><img src="/Blog-Build/挂到github.PNG" alt="挂到github上"></p>
<p>因为gitPage可能不是实时更新，你要等几分钟后再去访问网页，那就会出现了。</p>
<p>要注意，如果<code>hexo d</code>的时候失败出现<code>unable to auto-detect email address</code>，是因为你安装git的时候没有全局配置你的用户名和邮箱，你在.deploy/.git文件夹下的config配置上如下信息便可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	email&#x3D;your email</span><br><span class="line">	name&#x3D;your name</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的功能配置</title>
    <url>/Blog-Config/</url>
    <content><![CDATA[<p><img src="/Blog-Config/Hexo.jpg" alt="Hexo"></p>
<a id="more"></a>

<p>使用Hexo创建博客之后，我们已经使用基本的功能来写博客了。我们还可以对Hexo进行高度自定制，具体的配置可以到<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官网</a>上查看，官网不仅有文章说明解析，还配了视频解释。下面就来说一下我的Hexo中的一些插件使用和配置吧。</p>
<h2 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h2><p>这个文件是在根目录下的配置文件，是Hexo的全局配置文件，绝大多数的配置都需要在里面写。下面简单说明一下一些重要的配置。全部的参数具体可以查看<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官网的文档</a>，下面写上主要的参数。</p>
<p>站点配置是一些网址描述的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 站点配置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Never</span> <span class="string">And</span> <span class="string">Ever</span>  <span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">thanks</span> <span class="string">for</span> <span class="string">coming</span>  <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">keywords:</span>  <span class="comment">#关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Jun</span>  <span class="comment">#你的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#网站使用语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment">#网站时区</span></span><br></pre></td></tr></table></figure>

<p>文章地址配置是你文章链接的设置，我这里仅设置为title方便阅读：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 博客文章的绝对地址配置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://junzkn.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure>

<p>页面配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span> <span class="comment">#主页索引</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="attr">archive_generator:</span> <span class="comment">#档案索引</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">yearly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">monthly:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tag_generator:</span> <span class="comment">#标签索引</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>分类、标签的主要属性配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span>      <span class="comment">#默认分类</span></span><br><span class="line"><span class="attr">category_map:</span>                        <span class="comment">#分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span>                             <span class="comment">#标签别名</span></span><br></pre></td></tr></table></figure>

<p>分页配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">### Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>                   <span class="comment">#每页显示的文章量 (0 = 关闭分页功能)</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>           <span class="comment">#分页目录</span></span><br></pre></td></tr></table></figure>



<p>Hexo可以选择的主题有很多，我选择了比较热门的Next主题。在后面会详细说明这个主题：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主题配置</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>部署的配置之前有说到，是为了上传的一些属性配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署配置</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/junzkn/junzkn.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>



<h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2><p>Hexo本身自带一个landscape的主题，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>有很多优秀的第三方制作的主题，用的最多的是<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next</a>主题，网上关于它的教程也很多，我们用起来也方便，而且有许多插件可以使用。Next的安装可以参照<a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">官网文档</a>。</p>
<p>主题下载好后放到<code>themes</code>目录下，在上述配置文件的themes更改后，<code>hexo clean</code>一下再<code>hexo g</code>构建便可以看到如下主题：</p>
<p><img src="/Blog-Config/Next主题.PNG" alt="Next主题"></p>
<h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p>和站点的配置文件一样，具区的参数我就不在这里详细描述，可以查看<a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">官方文档</a>。一些常用的功能我在下面分开展示，其余的就不再详述。我把站点的配置文件和主题的配置文件放到附录。</p>
<h2 id="图片链接生成插件"><a href="#图片链接生成插件" class="headerlink" title="图片链接生成插件"></a>图片链接生成插件</h2><p>npm安装<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code>插件。</p>
<p>这个插件可能有的电脑安装后会有bug。此时打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">    <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">        <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">        <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">        link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">                ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">                xmlMode: <span class="literal">false</span>,</span><br><span class="line">                lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">                decodeEntities: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">                    <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">                    <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">                    <span class="comment">//url解码，以免有的文件名会生成url编码格式，没有的话可以去除</span></span><br><span class="line">                    src = <span class="built_in">decodeURIComponent</span>(src).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">                       !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">                        <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">                        <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">                        <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                            srcArray.shift();</span><br><span class="line">                        src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">                        $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">                        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">                    <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            data[key] = $.html();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后在站点配置文件上修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开了之后会把资源文件也打包</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>没有安装这个插件时，编写文章时插入的图片在生成博客的时候不会生成对应的链接。在你的<code>_post</code>文件夹下新建Markdown文章时，再新建一个同名的文件夹。图片资源放到那文件夹里面，在编译时就会生成对应的网页的图片链接</p>
<h2 id="关于、分类、标签页面的设置"><a href="#关于、分类、标签页面的设置" class="headerlink" title="关于、分类、标签页面的设置"></a>关于、分类、标签页面的设置</h2><p>使用<code>hexo new page about</code>创建关于页，会在<code>source</code>文件夹下生成<code>about</code>文件夹，在里面的Markdown的上方添加如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于我</span><br><span class="line">type: "about"</span><br><span class="line">comments: false</span><br><span class="line">date: 2018-10-19 11:54:04</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>使用<code>hexo new page tags</code>创建关于页，会在<code>source</code>文件夹下生成<code>tags</code>文件夹，在里面的Markdown的上方添加如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">date: 2018-10-19 11:53:31</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>使用<code>hexo new page categories</code>创建分类页，会在<code>source</code>文件夹下生成<code>categories</code>文件夹，在里面的Markdown的上方添加如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">date: 2018-10-19 11:53:16</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加完页面后，还需要在主题配置文件中进行设置，这样便能展示了：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#菜单配置</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>



<h2 id="本地搜索功能"><a href="#本地搜索功能" class="headerlink" title="本地搜索功能"></a>本地搜索功能</h2><p>npm安装<code>npm install hexo-generator-searchdb --save</code>插件。</p>
<p>修改站点配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>修改主题配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h2 id="字数统计功能"><a href="#字数统计功能" class="headerlink" title="字数统计功能"></a>字数统计功能</h2><p>npm安装<code>npm install hexo-symbols-count-time --save</code>插件。</p>
<p>修改站点配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment"># 阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span> <span class="comment"># 所有文章总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span> <span class="comment"># 所有文章阅读中时长</span></span><br></pre></td></tr></table></figure>

<p>修改主题配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>



<h2 id="图片浏览功能"><a href="#图片浏览功能" class="headerlink" title="图片浏览功能"></a>图片浏览功能</h2><p>git下载<code>git clone https://github.com/theme-next/theme-next-fancybox3 themes/next/source/lib/fancybox</code>插件，在主题配置文件中修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h2 id="支持Latex数学公式"><a href="#支持Latex数学公式" class="headerlink" title="支持Latex数学公式"></a>支持Latex数学公式</h2><p>Latex是支持打印排版的数学公式排版系统，我们要在文章中使用，先npm安装<code>npm install hexo-renderer-kramed --save</code>，然后在主题文件中修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后我们在需要使用到数学公式的文章的顶部信息加入如下信息，这样我们便可以在网页上渲染我们的数学公式了 。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<h2 id="文章置顶功能"><a href="#文章置顶功能" class="headerlink" title="文章置顶功能"></a>文章置顶功能</h2><p>根目录找到<code>node_modules/hexo-generator-index/lib/generator.js</code>这个文件。定位到<code>var posts = locals.posts;</code>这行代码，在下面添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">        <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样设置后便可以在我文章添加top使用，会根据top值排行：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello</span><br><span class="line">date: 2018-10-19 </span><br><span class="line">top: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>打开：<code>/blog/themes/next/layout/_macro</code> 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;font color&#x3D;000000&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>这样设置后便会显示指定标签了哦。</p>
<h2 id="文章加密功能"><a href="#文章加密功能" class="headerlink" title="文章加密功能"></a>文章加密功能</h2><p>npm安装<code>npm install --save hexo-blog-encrypt</code>插件。</p>
<p>在站点配置文件中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">default_abstract:</span> <span class="string">加密文章</span></span><br><span class="line">    <span class="attr">default_message:</span> <span class="string">请输入密码</span></span><br></pre></td></tr></table></figure>

<p>在你需要加密的文章添加上password：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello world</span><br><span class="line">password: hello</span><br><span class="line">abstract: Welcome to my blog, enter password to read.</span><br><span class="line">message: Welcome to my blog, enter password to read.</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>要注意的是他是使用cookies记录是否要输入密码，如果你输入密码过后就不用再输入了。</p>
<h2 id="相关文章功能"><a href="#相关文章功能" class="headerlink" title="相关文章功能"></a>相关文章功能</h2><p>npm安装<code>npm install hexo-related-popular-posts --save</code>插件。</p>
<p>修改主题配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="comment">#isExcerpt: false</span></span><br></pre></td></tr></table></figure>



<h2 id="sitemap配置"><a href="#sitemap配置" class="headerlink" title="sitemap配置"></a>sitemap配置</h2><p>用于站点地图配置，主要用于SEO优化。</p>
<p>npm安装<code>npm install hexo-generator-sitemap --save</code>和<code>npm install hexo-generator-baidu-sitemap --save</code>，然后站点配置文件添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>



<h2 id="添加Live-2D模型"><a href="#添加Live-2D模型" class="headerlink" title="添加Live 2D模型"></a>添加Live 2D模型</h2><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">Live2D模型</a>可以让我们的hexo添加一个萌萌哒的吉祥物。</p>
<p>安装<code>npm install --save hexo-helper-live2d</code>，接下来修改next主题目录的_layout.swig文件，路径为hexo\themes\next\layout\，在合适的地方给它安个家，要在body标签之间就行，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>&#123;&#123; live2d() &#125;&#125;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后再站点配置文件添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>里面的model的use就是你要的模型，你的模型需要放在Hexo根目录中新建文件夹live2d_models的里面。模型下载的<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">看这里</a>，我们在这里下载完之后整个模型的文件夹放到刚刚说的live2d_models，然后要用哪个就修改对应名字便可。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="站点配置文件yml："><a href="#站点配置文件yml：" class="headerlink" title="站点配置文件yml："></a>站点配置文件yml：</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点配置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Never</span> <span class="string">And</span> <span class="string">Ever</span>  <span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">thanks</span> <span class="string">for</span> <span class="string">coming</span>  <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">keywords:</span>  <span class="comment">#关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Jun</span>  <span class="comment">#你的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#网站使用语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment">#网站时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL配置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://junzkn.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing 'index.html' from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing '.html' from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="attr">archive_generator:</span> <span class="comment">#档案索引</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">yearly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">monthly:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## Use post's date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">7</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the 'source/' folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="comment"># 部署配置</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/junzkn/junzkn.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment"># 阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span> <span class="comment"># 所有文章总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span> <span class="comment"># 所有文章阅读中时长</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">abstract:</span> <span class="string">加密文章</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">请输入密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo-neat 静态资源压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">false</span> </span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span> </span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'*.min.css'</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'*.min.js'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">130</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="主题配置文件yml："><a href="#主题配置文件yml：" class="headerlink" title="主题配置文件yml："></a>主题配置文件yml：</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Theme Core Configuration Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If false, merge configs from `_data/next.yml` into default configuration (rewrite).</span></span><br><span class="line"><span class="comment"># If true, will fully override default configuration by options from `_data/next.yml` (override). Only for NexT settings.</span></span><br><span class="line"><span class="comment"># And if true, all config from default NexT `_config.yml` must be copied into `next.yml`. Use if you know what you are doing.</span></span><br><span class="line"><span class="comment"># Useful if you want to comment some options from NexT `_config.yml` by `next.yml` without editing default config.</span></span><br><span class="line"><span class="attr">override:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Console reminder if new version released.</span></span><br><span class="line"><span class="attr">reminder:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow to cache content generation. Introduced in NexT v6.0.0.</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove unnecessary files after hexo generate.</span></span><br><span class="line"><span class="attr">minify:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/getting-started/</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#图标设置</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2020</span> <span class="comment">#建站日期</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 年份和版权之间的图标</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">plane</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#808080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#版权</span></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">Junzkn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span> <span class="string">京ICP备</span> <span class="number">1234567890</span><span class="string">号-1</span></span><br><span class="line">    <span class="comment"># The digit in the num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_id:</span> <span class="number">1234567890</span></span><br><span class="line">    <span class="comment"># The full num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_num:</span> <span class="string">京公网安备</span> <span class="number">1234567890</span><span class="string">号</span></span><br><span class="line">    <span class="comment"># The icon for gongan beian. See: http://www.beian.gov.cn/portal/download</span></span><br><span class="line">    <span class="attr">gongan_icon_url:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">language:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. yoursite.com/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="string">时间线:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/sidebar</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Manual define the sidebar width. If commented, will be default for:</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display (only for Muse | Mist), available values:</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically.</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar padding in pixels.</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Posts / Categories / Tags in sidebar.</span></span><br><span class="line"><span class="attr">site_state:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line">  <span class="comment">#RSS: /atom.xml || rss</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_settings:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">link</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Links</span></span><br><span class="line">  <span class="comment"># Available values: block | inline</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">block</span></span><br><span class="line"></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="comment">#Title: http://yoursite.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport wrap expand_all).</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A button to open designated chat widget in sidebar.</span></span><br><span class="line"><span class="comment"># Firstly, you need enable the chat service you want to activate its sidebar button.</span></span><br><span class="line"><span class="attr">chat:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#service: chatra</span></span><br><span class="line">  <span class="comment">#service: tidio</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">comment</span> <span class="comment"># Icon name in Font Awesome, set false to disable icon.</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">Chat</span> <span class="comment"># Button text, change it as you wish.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/posts</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button will be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use icon instead of the symbol # to indicate the tag at the bottom of the post</span></span><br><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#comment: Donate comment here.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="comment">#wechatpay: /images/wechatpay.png</span></span><br><span class="line">  <span class="comment">#alipay: /images/alipay.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Related popular posts</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/tea3/hexo-related-popular-posts</span></span><br><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">相关阅读</span> <span class="comment"># Custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="comment">#isExcerpt: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post edit</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/hexojs/hexo-deployer-git</span></span><br><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/junzkn/junzkn.github.io/master</span> <span class="comment"># Link for view source</span></span><br><span class="line">  <span class="comment">#url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name # Link for fork &amp; edit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show previous post and next post in post footer if exists</span></span><br><span class="line"><span class="comment"># Available values: left | right | false</span></span><br><span class="line"><span class="attr">post_navigation:</span> <span class="string">right</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Custom Page Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/custom-pages</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TagCloud settings for tags page.</span></span><br><span class="line"><span class="attr">tagcloud:</span></span><br><span class="line">  <span class="comment"># All values below are same as default, change them by yourself.</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">12</span> <span class="comment"># Minimun font size in px</span></span><br><span class="line">  <span class="attr">max:</span> <span class="number">30</span> <span class="comment"># Maxium font size in px</span></span><br><span class="line">  <span class="attr">start:</span> <span class="string">"#ccc"</span> <span class="comment"># Start color (hex, rgba, hsla or color keywords)</span></span><br><span class="line">  <span class="attr">end:</span> <span class="string">"#111"</span> <span class="comment"># End color (hex, rgba, hsla or color keywords)</span></span><br><span class="line">  <span class="attr">amount:</span> <span class="number">200</span> <span class="comment"># Amount of tags, change it if you have more than 200 tags</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Calendar</span></span><br><span class="line"><span class="comment"># Share your recent schedule to others via calendar page.</span></span><br><span class="line"><span class="attr">calendar:</span></span><br><span class="line">  <span class="attr">calendar_id:</span> <span class="string">&lt;required&gt;</span> <span class="comment"># Your Google account E-Mail</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line">  <span class="attr">orderBy:</span> <span class="string">startTime</span></span><br><span class="line">  <span class="attr">offsetMax:</span> <span class="number">24</span> <span class="comment"># Time Range</span></span><br><span class="line">  <span class="attr">offsetMin:</span> <span class="number">4</span> <span class="comment"># Time Range</span></span><br><span class="line">  <span class="attr">showDeleted:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">singleEvents:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">maxResults:</span> <span class="number">250</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the text alignment in posts / pages.</span></span><br><span class="line"><span class="attr">text_align:</span></span><br><span class="line">  <span class="comment"># Available values: start | end | left | right | center | justify | justify-all | match-parent</span></span><br><span class="line">  <span class="attr">desktop:</span> <span class="string">justify</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="string">justify</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce padding / margin indents on devices with narrow width.</span></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Chrome header panel color ($brand-bg / $headband-bg =&gt; $black-deep).</span></span><br><span class="line"><span class="attr">android_chrome_color:</span> <span class="string">"#222"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hide sticky headers and color the menu bar on Safari (iOS / macOS).</span></span><br><span class="line"><span class="attr">safari_rainbow:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo (Do not support scheme Mist)</span></span><br><span class="line"><span class="attr">custom_logo:</span> <span class="comment">#/uploads/custom-logo.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">galactic</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"#37c6c0"</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bookmark Support</span></span><br><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"#222"</span></span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/yourname</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/#Fonts-Customization</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#   light | light italic | normal | normal italic | bold | bold italic</span></span><br><span class="line"><span class="comment"># Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in scheme Pisces / Gemini, Web Safe fonts are recommended for `global` (and `title`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. //fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable Baidu transformation on mobile devices.</span></span><br><span class="line"><span class="attr">disable_baidu_transformation:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a canonical link tag for your Hexo site.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Remember to set up your URL in Hexo `_config.yml` (e.g. url: http://yoursite.com)</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post / page titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, site-subtitle will be added to index page.</span></span><br><span class="line"><span class="comment"># Remember to set up your site-subtitle in Hexo `_config.yml` (e.g. subtitle: Subtitle)</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically add external URL with Base64 encrypt &amp; decrypt.</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters</span></span><br><span class="line"><span class="attr">google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster</span></span><br><span class="line"><span class="attr">bing_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru</span></span><br><span class="line"><span class="attr">yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://ziyuan.baidu.com/site</span></span><br><span class="line"><span class="attr">baidu_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="string">push</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Plugins &amp; Services Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/</span></span><br><span class="line"><span class="comment"># You may need to install dependencies or set CDN URLs in `vendors`</span></span><br><span class="line"><span class="comment"># There are two different CDN providers by default:</span></span><br><span class="line"><span class="comment">#   - jsDelivr (cdn.jsdelivr.net), works everywhere even in China</span></span><br><span class="line"><span class="comment">#   - CDNJS (cdnjs.cloudflare.com), provided by cloudflare</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A JavaScript library for zooming images like Medium.</span></span><br><span class="line"><span class="comment"># Do not enable both `fancybox` and `mediumzoom`.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/francoischalifour/medium-zoom</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/ApoorvSaxena/lozad.js</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pangu Support</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="attr">pangu:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Quicklink Support</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/GoogleChromeLabs/quicklink</span></span><br><span class="line"><span class="comment"># Front-matter (unsupport home archive).</span></span><br><span class="line"><span class="attr">quicklink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Home page and archive page can be controlled through home and archive options below.</span></span><br><span class="line">  <span class="comment"># This configuration item is independent of `enable`.</span></span><br><span class="line">  <span class="attr">home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">archive:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will initialize quicklink after the load event fires.</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Custom a time in milliseconds by which the browser must execute prefetching.</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="comment"># Default (true) will enable fetch() or falls back to XHR.</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># For more flexibility you can add some patterns (RegExp, Function, or Array) to ignores.</span></span><br><span class="line">  <span class="comment"># See: https://github.com/GoogleChromeLabs/quicklink#custom-ignore-patterns</span></span><br><span class="line">  <span class="attr">ignores:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Comments Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/comments</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiple Comment System Support</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Available values: tabs | buttons</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">tabs</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class="line">  <span class="attr">active:</span></span><br><span class="line">  <span class="comment"># Setting `true` means remembering the comment system selected by the visitor.</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Lazyload all comment systems.</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Modify texts or order for any navs, here are some examples.</span></span><br><span class="line">  <span class="attr">nav:</span></span><br><span class="line">    <span class="comment">#disqus:</span></span><br><span class="line">    <span class="comment">#  text: Load Disqus</span></span><br><span class="line">    <span class="comment">#  order: -1</span></span><br><span class="line">    <span class="comment">#gitalk:</span></span><br><span class="line">    <span class="comment">#  order: -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">shortname:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DisqusJS</span></span><br><span class="line"><span class="comment"># Alternative Disqus - Render comment component using Disqus API.</span></span><br><span class="line"><span class="comment"># Demo: https://suka.js.org/DisqusJS/</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/SukkaW/DisqusJS</span></span><br><span class="line"><span class="attr">disqusjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># API Endpoint of Disqus API (https://disqus.com/api/).</span></span><br><span class="line">  <span class="comment"># Leave api empty if you are able to connect to Disqus API. Otherwise you need a reverse proxy for it.</span></span><br><span class="line">  <span class="comment"># For example:</span></span><br><span class="line">  <span class="comment"># api: https://disqus.skk.moe/disqus/</span></span><br><span class="line">  <span class="attr">api:</span></span><br><span class="line">  <span class="attr">apikey:</span> <span class="comment"># Register new application from https://disqus.com/api/applications/</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="comment"># See: https://disqus.com/admin/settings/general/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span></span><br><span class="line">  <span class="attr">appkey:</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LiveRe comments system</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="comment"># &lt;your_uid&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk's display language depends on user's browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Widgets &amp; Content Sharing Services</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/post-widgets</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">id:</span>     <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span>  <span class="string">fc6423</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AddThis Share. See: https://www.addthis.com</span></span><br><span class="line"><span class="comment"># Go to https://www.addthis.com/dashboard to customize your tools.</span></span><br><span class="line"><span class="attr">add_this_id:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Statistics and Analytics</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/statistics-and-analytics</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span> <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line">  <span class="comment"># By default, NexT will load an external gtag.js script on your site.</span></span><br><span class="line">  <span class="comment"># If you only need the pageview feature, set the following option to true to get a better performance.</span></span><br><span class="line">  <span class="attr">only_pageview:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Growingio Analytics</span></span><br><span class="line"><span class="attr">growingio_analytics:</span> <span class="comment"># &lt;project_id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CNZZ count</span></span><br><span class="line"><span class="attr">cnzz_siteid:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors of each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn to get AppID and AppKey.</span></span><br><span class="line"><span class="comment"># AppID and AppKey are recommended to be the same as valine's for counter compatibility.</span></span><br><span class="line"><span class="comment"># Do not enable both `valine.visitor` and `leancloud_visitors`.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="comment"># &lt;app_key&gt;</span></span><br><span class="line">  <span class="comment"># Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span></span><br><span class="line">  <span class="comment"># If you don't care about security in leancloud counter and just want to use it directly</span></span><br><span class="line">  <span class="comment"># (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span></span><br><span class="line">  <span class="attr">security:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">betterPerformance:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another tool to show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># Visit https://console.firebase.google.com/u/0/ to get apiKey and projectId.</span></span><br><span class="line"><span class="comment"># Visit https://firebase.google.com/docs/firestore/ to get more information about firestore.</span></span><br><span class="line"><span class="attr">firestore:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">collection:</span> <span class="string">articles</span> <span class="comment"># Required, a string collection name to access firestore database</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="comment"># Required</span></span><br><span class="line">  <span class="attr">projectId:</span> <span class="comment"># Required</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Search Services</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/search-services</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="comment"># For more information: https://www.algolia.com</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiftype Search API Key</span></span><br><span class="line"><span class="attr">swiftype_key:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Chat Services</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/third-party-services/chat-services</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Chatra Support</span></span><br><span class="line"><span class="comment"># See: https://chatra.io</span></span><br><span class="line"><span class="comment"># Dashboard: https://app.chatra.io/settings/general</span></span><br><span class="line"><span class="attr">chatra:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="comment"># Visit Dashboard to get your ChatraID</span></span><br><span class="line">  <span class="comment">#embed: # Unfinished experimental feature for developers. See: https://chatra.io/help/api/#injectto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tidio Support</span></span><br><span class="line"><span class="comment"># See: https://www.tidiochat.com</span></span><br><span class="line"><span class="comment"># Dashboard: https://www.tidiochat.com/panel/dashboard</span></span><br><span class="line"><span class="attr">tidio:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">key:</span> <span class="comment"># Public Key, get it from dashboard. See: https://www.tidiochat.com/panel/settings/developer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tags Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/tag-plugins/</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note tag (bs-callout)</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tabs tag</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PDF tag, requires two plugins: pdfObject and pdf.js</span></span><br><span class="line"><span class="comment"># pdfObject will try to load pdf files natively, if failed, pdf.js will be used.</span></span><br><span class="line"><span class="comment"># The following `cdn` setting is only for pdfObject, because cdn for pdf.js might be blocked by CORS policy.</span></span><br><span class="line"><span class="comment"># So, you must install the dependency of pdf.js if you want to use pdf tag and make it available to all browsers.</span></span><br><span class="line"><span class="comment"># See: https://github.com/theme-next/theme-next-pdf</span></span><br><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">500px</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Animation Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use velocity to animate everything.</span></span><br><span class="line"><span class="comment"># For more information: http://velocityjs.org</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | flipXIn | flipYIn | flipBounceXIn | flipBounceYIn</span></span><br><span class="line">    <span class="comment"># swoopIn | whirlIn | shrinkIn | expandIn</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceUpIn | bounceDownIn | bounceLeftIn | bounceRightIn</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideDownIn | slideLeftIn | slideRightIn</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideDownBigIn | slideLeftBigIn | slideRightBigIn</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveDownIn | perspectiveLeftIn | perspectiveRightIn</span></span><br><span class="line">    <span class="attr">post_block:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="attr">post_header:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">post_body:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">coll_header:</span> <span class="string">slideLeftIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="string">slideUpIn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pace</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/HubSpot/pace</span></span><br><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"0,0,255"</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># The number of lines</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/zproo/canvas-ribbon</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span> <span class="comment"># The width of the ribbon</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span> <span class="comment"># The transparency of the ribbon</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># The display level of the ribbon</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! See: https://theme-next.org/docs/advanced-settings</span></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Script Vendors. Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># Be aware that you would better use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Remember to use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="comment"># Internal path prefix.</span></span><br><span class="line">  <span class="attr">_internal:</span> <span class="string">lib</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 3.1.0</span></span><br><span class="line">  <span class="comment"># anime: //cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js</span></span><br><span class="line">  <span class="attr">anime:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 4.7.0</span></span><br><span class="line">  <span class="comment"># fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css</span></span><br><span class="line">  <span class="comment"># fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css</span></span><br><span class="line">  <span class="attr">fontawesome:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># MathJax</span></span><br><span class="line">  <span class="comment"># mathjax: //cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line">  <span class="comment"># mathjax: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML</span></span><br><span class="line">  <span class="comment"># mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3</span></span><br><span class="line">  <span class="comment"># mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">mhchem:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># KaTeX</span></span><br><span class="line">  <span class="comment"># katex: //cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css</span></span><br><span class="line">  <span class="comment"># katex: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css</span></span><br><span class="line">  <span class="comment"># copy_tex_js: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js</span></span><br><span class="line">  <span class="comment"># copy_tex_css: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">  <span class="attr">copy_tex_js:</span></span><br><span class="line">  <span class="attr">copy_tex_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 0.2.8</span></span><br><span class="line">  <span class="comment"># pjax: //cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js</span></span><br><span class="line">  <span class="attr">pjax:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># FancyBox</span></span><br><span class="line">  <span class="comment"># jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js</span></span><br><span class="line">  <span class="comment"># fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js</span></span><br><span class="line">  <span class="comment"># fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br><span class="line">  <span class="attr">jquery:</span></span><br><span class="line">  <span class="attr">fancybox:</span></span><br><span class="line">  <span class="attr">fancybox_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Medium-zoom</span></span><br><span class="line">  <span class="comment"># mediumzoom: //cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js</span></span><br><span class="line">  <span class="attr">mediumzoom:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Lazyload</span></span><br><span class="line">  <span class="comment"># lazyload: //cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js</span></span><br><span class="line">  <span class="comment"># lazyload: //cdnjs.cloudflare.com/ajax/libs/lozad.js/1.9.0/lozad.min.js</span></span><br><span class="line">  <span class="attr">lazyload:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pangu</span></span><br><span class="line">  <span class="comment"># pangu: //cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js</span></span><br><span class="line">  <span class="comment"># pangu: //cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js</span></span><br><span class="line">  <span class="attr">pangu:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Quicklink</span></span><br><span class="line">  <span class="comment"># quicklink: //cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js</span></span><br><span class="line">  <span class="attr">quicklink:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DisqusJS</span></span><br><span class="line">  <span class="comment"># disqusjs_js: //cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js</span></span><br><span class="line">  <span class="comment"># disqusjs_css: //cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css</span></span><br><span class="line">  <span class="attr">disqusjs_js:</span></span><br><span class="line">  <span class="attr">disqusjs_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Valine</span></span><br><span class="line">  <span class="comment"># valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span></span><br><span class="line">  <span class="comment"># valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js</span></span><br><span class="line">  <span class="attr">valine:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Gitalk</span></span><br><span class="line">  <span class="comment"># gitalk_js: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js</span></span><br><span class="line">  <span class="comment"># gitalk_css: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css</span></span><br><span class="line">  <span class="attr">gitalk_js:</span></span><br><span class="line">  <span class="attr">gitalk_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Algolia Search</span></span><br><span class="line">  <span class="comment"># algolia_instant_js: //cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js</span></span><br><span class="line">  <span class="comment"># algolia_instant_css: //cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css</span></span><br><span class="line">  <span class="attr">algolia_instant_js:</span></span><br><span class="line">  <span class="attr">algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># PDF</span></span><br><span class="line">  <span class="comment"># pdfobject: //cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js</span></span><br><span class="line">  <span class="comment"># pdfobject: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js</span></span><br><span class="line">  <span class="attr">pdfobject:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Mermaid</span></span><br><span class="line">  <span class="comment"># mermaid: //cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js</span></span><br><span class="line">  <span class="comment"># mermaid: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.0/mermaid.min.js</span></span><br><span class="line">  <span class="attr">mermaid:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># velocity: //cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js</span></span><br><span class="line">  <span class="comment"># velocity: //cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js</span></span><br><span class="line">  <span class="comment"># velocity_ui: //cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js</span></span><br><span class="line">  <span class="comment"># velocity_ui: //cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js</span></span><br><span class="line">  <span class="attr">velocity:</span></span><br><span class="line">  <span class="attr">velocity_ui:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.2</span></span><br><span class="line">  <span class="comment"># pace: //cdn.jsdelivr.net/npm/pace-js@1/pace.min.js</span></span><br><span class="line">  <span class="comment"># pace: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js</span></span><br><span class="line">  <span class="comment"># pace_css: //cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css</span></span><br><span class="line">  <span class="comment"># pace_css: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css</span></span><br><span class="line">  <span class="attr">pace:</span></span><br><span class="line">  <span class="attr">pace_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># three: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js</span></span><br><span class="line">  <span class="comment"># three_waves: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js</span></span><br><span class="line">  <span class="comment"># canvas_lines: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js</span></span><br><span class="line">  <span class="comment"># canvas_sphere: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js</span></span><br><span class="line">  <span class="attr">three:</span></span><br><span class="line">  <span class="attr">three_waves:</span></span><br><span class="line">  <span class="attr">canvas_lines:</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js</span></span><br><span class="line">  <span class="comment"># canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js</span></span><br><span class="line">  <span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">canvas_nest_nomobile:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js</span></span><br><span class="line">  <span class="attr">canvas_ribbon:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题美化</title>
    <url>/Blog-Theme/</url>
    <content><![CDATA[<p><img src="/Blog-Theme/Next主题.PNG" alt="Hexo"></p>
<a id="more"></a>

<p>功能齐全之后，就是要美化我们的网页了。我使用的是Next主题，它可以自定义CSS样式和自定义JS来进行网页美化，绝大多数都是修改一些CSS和布局Lay</p>
<p>out文件。</p>
<h2 id="图标的修改"><a href="#图标的修改" class="headerlink" title="图标的修改"></a>图标的修改</h2><p>Next使用的图标库是<a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">fontawesome4.7图标库</a>，可以直接在网站上找到你想要的图标的名称更改。</p>
<p>比如我想修改文章最后的那个#标签的图标，可以修改模板 <code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h2 id="自定义CSS"><a href="#自定义CSS" class="headerlink" title="自定义CSS"></a>自定义CSS</h2><p>在<code>D:\Blog\themes\next\source\css\_custom\custom.styl</code>中定义自己的CSS代码，那些元素是哪个类，直接在浏览器F12查看便可。下面是我的CSS代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="自适应背景"><a href="#自适应背景" class="headerlink" title="自适应背景"></a>自适应背景</h2><p>使用<code>jquery-backstretch</code>库，找到<code>/next/layout/_layout.swig</code>文件，在最后的body前添加如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"body"</span>).backstretch(<span class="string">"https://背景图.jpg"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle入门</title>
    <url>/Gradle-Getting_start/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Gradle是一个项目<strong>自动化构建</strong>工具，与Apache的Ant和Maven一样。但是Gradle使用的不是传统的xml文件配置，它的构建脚本是使用Groovy或Kotlin的DSL编写。它拥有高度可定制、快速、功能强大等功能。</p>
<h2 id="Gradle版的Hello-World"><a href="#Gradle版的Hello-World" class="headerlink" title="Gradle版的Hello World"></a>Gradle版的Hello World</h2><p>新建<code>builde.gradle</code>文件，这个是项目的构建脚本文件，编辑如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">	doLast&#123;</span><br><span class="line">		println<span class="string">'hello world'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开终端输入<code>gradle -q hello</code>便可以输出hello world。hello是一个task，而-q是日志级别（下面会详说），这条命令就是执行builde.gradle脚本中名为hello的task。</p>
<h2 id="Gradle-Wrapper"><a href="#Gradle-Wrapper" class="headerlink" title="Gradle Wrapper"></a>Gradle Wrapper</h2><p>Wrapper是对Gradle的一层封装，便于统一Gradle版本。执行wrapper命令时，会根据对应的配置下载好对应的gradle版本，然后进行构建项目。</p>
<p>Gradle内置一个wrapper的task帮助我们自动生成wrapper所需要的目录文件，在终端输入<code>gradle wrapper</code>便可生成。生成的目录文件如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">|--gradle</span><br><span class="line">|  --wrapper</span><br><span class="line">|    --gradle-wrapper.jar</span><br><span class="line">|    --gradle-wrapper.properties</span><br><span class="line">|--gradlew</span><br><span class="line">|--gradlew.bat</span><br></pre></td></tr></table></figure>

<p><code>gradlew</code>和<code>gradlew.bat</code>是Linux和Window下的可执行脚本。<code>gradle-wrapper.jar</code>是具体业务逻辑实现。<code>gradle-wrapper.properties</code>是配置文件。配置文件内容、的字段和说明如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-5.0-bin.zip</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">distributionBase</td>
<td align="center">下载的Gradle压缩包解压后存储的主目录</td>
</tr>
<tr>
<td align="center">distributionPath</td>
<td align="center">对应distributionBase的解压后的Gradle压缩包的路径</td>
</tr>
<tr>
<td align="center">distributionUrl</td>
<td align="center">Gradle发行版压缩包的下载地址</td>
</tr>
<tr>
<td align="center">zipStoreBase</td>
<td align="center">同distributionBase，不过是存放zip压缩包的</td>
</tr>
<tr>
<td align="center">zipStorePath</td>
<td align="center">同distributionPath，不过是存放zip压缩包的</td>
</tr>
</tbody></table>
<h2 id="Gradle日志"><a href="#Gradle日志" class="headerlink" title="Gradle日志"></a>Gradle日志</h2><p>Gradle也是可以打印日志的，gradle的日志可以分为如下6个级别：</p>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ERROR</td>
<td align="center">错误消息</td>
</tr>
<tr>
<td align="center">QUIET</td>
<td align="center">重要消息</td>
</tr>
<tr>
<td align="center">WARNING</td>
<td align="center">警告消息</td>
</tr>
<tr>
<td align="center">LIFECYCLE</td>
<td align="center">进度消息</td>
</tr>
<tr>
<td align="center">INFO</td>
<td align="center">信息消息</td>
</tr>
<tr>
<td align="center">DEBUG</td>
<td align="center">调式消息</td>
</tr>
</tbody></table>
<p>之前的println是属于QUIET级别的，使用<code>gradle -q tasks</code>命令可以显示QUIET及其以上级别的消息。</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle的构建脚本</title>
    <url>/Gradle-Script/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般在一个项目中，会有5个gradle相关的文件：<code>gradlew</code>和<code>gradlew.bat</code>这两个文件是执行命令；<code>.gradle</code>文件件是gradle生成的；<code>gradle</code>文件件是gradle wrapper生成的；<code>gradle.properties</code>和<code>local.properties</code>是全局gradle配置文件和全局本地配置文件；<code>build.gradle</code>和<code>settings.gradle</code>是项目配置文件。</p>
<h2 id="settings-gradle文件"><a href="#settings-gradle文件" class="headerlink" title="settings.gradle文件"></a>settings.gradle文件</h2><p>这个文件用于初始化以及工程数的配置。在Android中大多数是用来配置子工程，也就是配置Module的。一个子工程只有在<code>settings.gradle</code>文件中配置了才会识别。下面是一个示例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">rootProject.name = <span class="string">'Hello'</span></span><br><span class="line">include <span class="string">':test1_1'</span></span><br><span class="line">project(<span class="string">':test1_1'</span>).projectDir = <span class="keyword">new</span> File(rootDir,<span class="string">'t1/test1'</span>)</span><br><span class="line">include <span class="string">':test1_2'</span></span><br><span class="line">project(<span class="string">':test1_2'</span>).projectDir = <span class="keyword">new</span> File(rootDir,<span class="string">'t1/test2'</span>)</span><br><span class="line">include <span class="string">':test2_1'</span></span><br><span class="line">project(<span class="string">':test2_1'</span>).projectDir = <span class="keyword">new</span> File(rootDir,<span class="string">'t2/test1'</span>)</span><br></pre></td></tr></table></figure>

<p>上面的示例便是配置了3个子项目并且指定了每个子项目的目录。</p>
<h2 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h2><p>每一个项目都会有自己的build.gradle文件，当然也包括子项目。 </p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福黄金学习法则</title>
    <url>/LearingRule/</url>
    <content><![CDATA[<p><img src="/LearingRule/黄金学习法则.png" alt="黄金学习法则"></p>
]]></content>
  </entry>
  <entry>
    <title>Kotlin基础</title>
    <url>/Kotlin-Basic/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量定义格式：<strong>［关键字］var|val 变量名 ［：类型］［＝初始值］</strong></p>
<p><code>var</code>：表示变量的值定义后可以再次被改变。<code>val</code>：表示变量的值在定义后不能再被改变。</p>
<p>变量只有在函数中定义时可以不显式初始化。在其他顶层地方定义时需要像如下显式初始化，不然会报错：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var可变变量</span></span><br><span class="line"><span class="keyword">var</span> a:<span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> c:<span class="built_in">Int</span>  <span class="comment">//报错、必须赋值</span></span><br><span class="line"><span class="comment">//val不可变变量</span></span><br><span class="line"><span class="keyword">val</span> d:<span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> e = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> f:<span class="built_in">Int</span>   <span class="comment">//报错、必须赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="变量的延时初始化"><a href="#变量的延时初始化" class="headerlink" title="变量的延时初始化"></a>变量的延时初始化</h3><p>刚才说了定义变量后需要初始化，但也可以使用关键字<code>lateinit</code>或者<code>by lazy{}</code>高阶函数延时初始化。</p>
<p>lateinit:</p>
<ul>
<li>只能修饰var</li>
<li>不能声明可null变量</li>
<li>不能声明基本数据类型Int 、Double等，但String可以。</li>
<li>声明后，在使用前必须赋值，不然会抛出UninitializedPropertyAccessException异常。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明组件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mTabLayout : TabLayout</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : <span class="built_in">Int</span> <span class="comment">// 会报错。因为不能用于基本数据类型</span></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">mTabLayout = find(R.id.home_tab_layout)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">mTabLayout.setupWithViewPager(mViewPager)</span><br></pre></td></tr></table></figure>

<p>by lazy{} :</p>
<ul>
<li>只能修饰val</li>
<li>当程序在第一次使用到这个变量的时候使用lazy{}里代码初始化。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个延迟初始化的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mStr : String <span class="keyword">by</span> lazy&#123;</span><br><span class="line">    <span class="string">"我是延迟初始化字符串变量"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量的表示"><a href="#常量的表示" class="headerlink" title="常量的表示"></a>常量的表示</h3><p>使用val相当于Java中的final，可以使用<code>const</code>关键字表示Java中的static final。<code>const</code>关键字只能修饰val变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> i:<span class="built_in">Int</span> = <span class="number">10</span> <span class="comment">//相当于Java中 static final int i=10 ;</span></span><br></pre></td></tr></table></figure>



<h2 id="数据类型和表示"><a href="#数据类型和表示" class="headerlink" title="数据类型和表示"></a>数据类型和表示</h2><p>在Kotlin中，一切皆对象，基本类型都是封装的：</p>
<ul>
<li>整型：Byte、Short、Long、Int。都是继承Number</li>
<li>浮点型：Float、Double</li>
<li>字符型：Char</li>
<li>布尔型：Boolean</li>
</ul>
<p>整型数值有三种表示方式（没有八进制）：</p>
<ul>
<li><p>十进制：一般表示方式</p>
</li>
<li><p>二进制：0b或者0B开头</p>
</li>
<li><p>十六进制：0x或者0X开头</p>
</li>
</ul>
<p>整型数值有三种表示方式：</p>
<ul>
<li>十进制：一般表示方式 1.23f</li>
<li>科学计数法：1.23E2</li>
</ul>
<p>在浮点和整型数值表示时，可以加入下划线，便于阅读方便： var i:Int= 1_000_000</p>
<h3 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h3><p>Kotlin是空安全语言，一般的变量不允许为空。当你需要使变量为空时，可以在类型后面加上？表示变量可以为null，例如Int?、Short?、Long?。类型带不带？还有另一个区别：Int会映射成Java的基本类型int，而Int?会映射成Java的包装类型Integer。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i:<span class="built_in">Int</span>?</span><br><span class="line">i = <span class="literal">null</span> <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h3 id="空安全调用"><a href="#空安全调用" class="headerlink" title="空安全调用"></a>空安全调用</h3><p>当不知道是否为空时，可以使用?.进行空安全调用，当为空时会显示null。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:String? = <span class="string">"jun"</span></span><br><span class="line">println(a.length)  <span class="comment">//输出3</span></span><br><span class="line">a = <span class="literal">null</span> </span><br><span class="line">println(a.length)  <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure>

<h3 id="强制调用"><a href="#强制调用" class="headerlink" title="强制调用"></a>强制调用</h3><p>可以使用!!.来进行强制调用，不管是否空。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b : String? = <span class="string">"jun"</span></span><br><span class="line">println (b!!.length) ／／输出<span class="number">3</span></span><br><span class="line">b = <span class="literal">null</span></span><br><span class="line">println b!!.length) ／／引发空指针异常（NPE)</span><br></pre></td></tr></table></figure>

<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>kotlin中可以使用typealias来给类型起另外的名字。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> MyNumber = <span class="built_in">Int</span>  <span class="comment">//MyNumber代表Int了</span></span><br><span class="line"><span class="keyword">var</span> s:MyNumber = <span class="string">"hello"</span> <span class="comment">//使用刚定义的MyNumber</span></span><br></pre></td></tr></table></figure>



<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>与Java类似，kotlin也有String类。在Kotlin中，可以直接通过下标访问字符</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s:String = <span class="string">"jun"</span></span><br><span class="line">println(s[<span class="number">1</span>])   <span class="comment">//输出u</span></span><br></pre></td></tr></table></figure>

<p>String有两种表示方式：</p>
<ul>
<li>包含转义字符的字符串。转义包括（\t、\n等）,不包含转义字符串的也同属此类型。</li>
<li>包含任意字符的字符串。由三重引号（””” …. “””）表示。</li>
</ul>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>在字符串中，在$符号后面加上变量名或大括号中的表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="string">"jun"</span></span><br><span class="line"><span class="keyword">var</span> tt = <span class="string">"<span class="variable">$t</span>的长度为<span class="subst">$&#123;t.length&#125;</span>"</span></span><br><span class="line">println(tt)  <span class="comment">//输出==&gt; jun的长度为3</span></span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在Kotlin中，数组由<code>Array&lt;T&gt;</code>表示。创建数组就两种方法：</p>
<ol>
<li>使用arrayOf()、arrayOfNull()、emptyArray()等函数。</li>
<li>使用 Array(size: Int, init: (Int) -&gt; T）构造器。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//等价于[1,2,3,4,5]</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arrayOfNulls&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>) <span class="comment">//如若不予数组赋值则arr3[0]、arr3[1]、arr3[2]皆为null</span></span><br><span class="line"><span class="comment">//使用构造器，第一个参数是数组长度，第二个参数是每个元素的生成函数</span></span><br><span class="line"><span class="keyword">var</span> arr3 = Array(<span class="number">5</span>,&#123;index -&gt; (index * <span class="number">2</span>).toString() &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="IF表达式"><a href="#IF表达式" class="headerlink" title="IF表达式"></a>IF表达式</h3><p>类似于Java的判断语句，不过这个IF可以有返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">//使用IF的返回值可以替代Java中的三目运算符</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">if</span> (a&gt;b) &#123;</span><br><span class="line">    println(<span class="string">"hello"</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"world"</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WHEN表达式"><a href="#WHEN表达式" class="headerlink" title="WHEN表达式"></a>WHEN表达式</h3><p>kotlin的When替代了Java中的switch，并且提供了非常强大的功能。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x:<span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//这里使用方法类似switch</span></span><br><span class="line"><span class="comment">//会从上到下每一个分支都会检查</span></span><br><span class="line"><span class="comment">//else类似于default</span></span><br><span class="line"><span class="keyword">when</span>(x)&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span> -&gt; print(<span class="string">"x is 1 or 2"</span>)</span><br><span class="line">    <span class="number">3</span> -&gt; print(<span class="string">"x is 3"</span>)</span><br><span class="line">    <span class="keyword">in</span> <span class="number">4</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; print(<span class="string">"x is Int"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">4</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When也有返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"h"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果When中不提供参数，就可以转化为if-elseIf语句：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span>&#123;</span><br><span class="line">    <span class="number">1</span>&gt;<span class="number">2</span> -&gt; println(<span class="string">"jun"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">"zkn"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FOR语句"><a href="#FOR语句" class="headerlink" title="FOR语句"></a>FOR语句</h3><p>不像Java中的，kotlin的For语句只能用于迭代器对象的循环。它的格式如下：<code>for (item in collection) print(item)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对数组遍历，下面两种效果一样</span></span><br><span class="line"><span class="keyword">for</span>(i:<span class="built_in">Int</span> <span class="keyword">in</span> <span class="number">0</span> until s.length)&#123;</span><br><span class="line">    print(s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i:<span class="built_in">Int</span> <span class="keyword">in</span> <span class="number">0</span>..s.length-<span class="number">1</span>)&#123;</span><br><span class="line">    print([i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WHILE语句"><a href="#WHILE语句" class="headerlink" title="WHILE语句"></a>WHILE语句</h3><p>这个While语句和Java的一样：格式如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">  <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure>

<h3 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h3><p>Kotlin 有三种结构化跳转表达式：</p>
<ul>
<li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li>
<li><em>break</em>。终止最直接包围它的循环。</li>
<li><em>continue</em>。继续下一次最直接包围它的循环。</li>
</ul>
<p>当然，我们可以控制Break和Continue在哪个循环中，这就是Break和Continue标签。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用@标记位置</span></span><br><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span>  <span class="comment">//直接跳出外循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用@标志位置</span></span><br><span class="line">    ints.forEach <span class="symbol">lit@</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@lit</span> <span class="comment">//return不直接结束整个函数</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin类</title>
    <url>/Kotlin-Class/</url>
    <content><![CDATA[<h1 id="Kotlin中的类"><a href="#Kotlin中的类" class="headerlink" title="Kotlin中的类"></a>Kotlin中的类</h1><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性...</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空类的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br></pre></td></tr></table></figure>



<h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>类的修饰符包括“类属性修饰符”和“访问权限修饰符”：</p>
<p>类属性修饰符，标示类本身特性：</p>
<ul>
<li>abstract    // 抽象类 </li>
<li>final       // 类不可继承，默认属性</li>
<li>enum        // 枚举类</li>
<li>open        // 类可继承，类默认是final的</li>
<li>annotation  // 注解类</li>
</ul>
<p>访问权限修饰符：</p>
<ul>
<li>private    // 仅在同一个文件中可见</li>
<li>protected  // 同一个文件中或子类可见</li>
<li>public     // 所有调用的地方都可见</li>
<li>internal   // 同一个模块中可见</li>
</ul>
<h2 id="类的构造器"><a href="#类的构造器" class="headerlink" title="类的构造器"></a>类的构造器</h2><p>Kotlin中允许类有一个主构造器和多个次构造器，主构造器是类头的一部分，它的初始化可以在初始化代码块中执行。次构造器则在类体中。</p>
<p>主构造器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主构造函数使用constructor关键字，后面跟着参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">constructor</span></span>(i:String)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">101</span></span><br><span class="line">    <span class="comment">//初始化块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>次构造器，如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="comment">// 次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span> (name: String, i: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$i</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (name: String, i: <span class="built_in">Int</span>, j:<span class="built_in">Int</span>) : <span class="keyword">this</span>(name,i) &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$j</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><p>类中属性声明的完整语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var|val &lt;propertyName&gt;[: &lt;PropertyType&gt;] [&#x3D; &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure>

<p>在类中，属性可以是var或者是val，var默认有setter和getter方法，val默认只有getter方法。外部调用直接使用<code>.</code>调用</p>
<p>在声明变量时，可以自己定义setter和getter方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName: String = <span class="string">"jun"</span></span><br><span class="line">    <span class="keyword">get</span>() = field.toUpperCase()   <span class="comment">// 将变量赋值后转换为大写</span></span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">            field = value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            field = -<span class="number">1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后段变量：用于将真正的值赋值给属性，而不会导致循环调用。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>与Java中的类似：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TTT</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> : <span class="type">TTT</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"TT"</span>  <span class="comment">// 自身的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;   <span class="comment">// 自身的函数</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span>      <span class="comment">//继承父类方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">var</span> name : String        <span class="comment">// 抽象属性</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">tt</span><span class="params">()</span></span>                 <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> : <span class="type">TT</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">tt</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: String = <span class="string">"jun"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="嵌套类和内部类"><a href="#嵌套类和内部类" class="headerlink" title="嵌套类和内部类"></a>嵌套类和内部类</h2><p>嵌套类就是类中的类，但是诶呦外部类的引用对象，不能方法外部变量。</p>
<p>内部类是使用inner的嵌套类，会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;                  <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;             <span class="comment">// 嵌套类</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar <span class="comment">//错误</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;        <span class="comment">// 内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> demo= Outter.Nested()<span class="comment">// 嵌套类，Outter后边没有括号</span></span><br><span class="line"><span class="keyword">var</span> demo = Outter().Inner();<span class="comment">// 内部类，Outter后边有括号</span></span><br></pre></td></tr></table></figure>



<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>与Java类似：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setInterFace</span><span class="params">(test: <span class="type">TestInterFace</span>)</span></span> &#123;</span><br><span class="line">        test.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestInterFace</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> test = Test()</span><br><span class="line">    <span class="comment">// 采用对象表达式来创建接口对象，即匿名内部类的实例。</span></span><br><span class="line">    <span class="comment">//object是kotlin的关键字</span></span><br><span class="line">    test.setInterFace(<span class="keyword">object</span> : TestInterFace &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"对象表达式创建匿名内部类的实例"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类。</p>
<p>Any类似于Java中的Object，他提供了三个默认函数equals()、hashCode()、toString()。</p>
<h3 id="继承时的构造器"><a href="#继承时的构造器" class="headerlink" title="继承时的构造器"></a>继承时的构造器</h3><ul>
<li>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</li>
<li>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name : String, <span class="keyword">var</span> age : <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name : String, age : <span class="built_in">Int</span>, no : String) : Person(name, age) &#123;</span><br><span class="line">    <span class="comment">//子类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,no:String,score:<span class="built_in">Int</span>):<span class="keyword">super</span>(name,age)&#123;</span><br><span class="line">        <span class="comment">//次构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在父类中需要重写的方法和属性使用open关键字修饰，在子类中使用override关键字重写。</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在枚举类中，每一个枚举常量都是一个对象，并且他们之间用逗号分隔。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    OK,</span><br><span class="line">    SERVER_ERROR,</span><br><span class="line">    NO_FINE,</span><br><span class="line">    OTHER,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个枚举对象中，有两个默认属性，<code>name</code>和<code>ordinal</code>，分别代表名字和位置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">"<span class="subst">$&#123;State.OK.name&#125;</span>、<span class="subst">$&#123;State.OK.ordinal&#125;</span>"</span>)</span><br><span class="line"><span class="comment">//==&gt; 输出为：OK、0</span></span><br></pre></td></tr></table></figure>

<p>我们也可以为枚举对象添加自己的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">var</span> state:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    OK(<span class="number">200</span>),</span><br><span class="line">    SERVER_ERROR(<span class="number">500</span>),</span><br><span class="line">    NO_FINE(<span class="number">404</span>),</span><br><span class="line">    OTHER(<span class="number">100</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">println(State.OK.state)</span><br></pre></td></tr></table></figure>



<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p>接口类的定义与实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口定义</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DemeInterfaceOne</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是DemoInterfaceOne中的fun1()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用“：”完成实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>: <span class="type">DemoInterfaceOne&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Demo4InterfaceOne&gt;.fun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性的重写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DemoInterfaceOne</span></span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> i :<span class="built_in">Int</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种方式，在类体中重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>: <span class="type">DemoInterfaceOne&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> i: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种方式，在构造器中重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> i: <span class="built_in">Int</span>) : DemoInterfaceOne&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的重写和多接口实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DemoInterfaceOne</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是Demo4InterfaceOne中的fun1()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是Demo4InterfaceOne中的fun2()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DemoInterfaceTwo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是Demo4InterfaceTwo中的fun1()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"我是Demo4InterfaceTwo中的fun2()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用“，”隔开接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> : <span class="type">DemoInterfaceOne</span>,<span class="type">DemoInterfaceTwo&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//使用super指定实现那个接口的方法</span></span><br><span class="line">        <span class="keyword">super</span>&lt;DemoInterfaceOne&gt;.fun1()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;DemoInterfaceTwo&gt;.fun2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>在Kotlin中，对于Bean这种数据类有一种特别的封装， 在class前加上data关键字可以表示。下面比较Kotlin的数据类和Java的Bean类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin版</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name : String, <span class="keyword">val</span> pwd : String)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java版</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">            <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">", pwd='"</span> + pwd + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Kotlin的数据类中：</p>
<ul>
<li>自动生成<code>equals()</code>和<code>hasCode()</code>函数。</li>
<li>自动生成<code>toString()</code>函数，由<code>类名（参数1 = 值1，参数2 = 值2，....）</code>构成</li>
<li>由所定义的属性自动生成<code>component1()、component2()、...、componentN()</code>函数，其对应于属性的声明顺序。</li>
<li>自动生成<code>copy()</code>函数。</li>
</ul>
<p>可以使用独有的<code>copy()</code>函数修改类的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mUser = User(<span class="string">"kotlin"</span>,<span class="string">"123456"</span>)</span><br><span class="line"><span class="keyword">val</span> mNewUser = mUser.copy(name = <span class="string">"new Kotlin"</span>)</span><br></pre></td></tr></table></figure>

<p>我们还可以对一个数据类解构：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mUser = User(<span class="string">"kotlin"</span>,<span class="string">"123456"</span>)</span><br><span class="line"><span class="keyword">val</span> (name,pwd) = mUser </span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>、<span class="variable">$pwd</span>"</span>)</span><br><span class="line"><span class="comment">//==&gt;输出  kotlin、123456</span></span><br></pre></td></tr></table></figure>



<h2 id="密封类-印章类"><a href="#密封类-印章类" class="headerlink" title="密封类(印章类)"></a>密封类(印章类)</h2><p>密封类是Kotlin独有的一种类，使用sealed修饰类。他的作用是表明继承它的类是有限的。密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。</p>
<p>密封类的出现主要是搭配When进行使用，他会遍历所有分支，从而不用else分支。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和枚举类很类似，枚举类在意的是数据，而密封类在意的是类型。</p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin函数</title>
    <url>/Kotlin-Function/</url>
    <content><![CDATA[<h2 id="函数编写规则"><a href="#函数编写规则" class="headerlink" title="函数编写规则"></a>函数编写规则</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> 函数名<span class="params">(参数名:参数类型)</span></span> : 返回值类型 &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单函数表达式函数：当函数只返回单个表达式时，大括号可以省略并在 = 后面定义函数体</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x*<span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="默认参数和居具名参数"><a href="#默认参数和居具名参数" class="headerlink" title="默认参数和居具名参数"></a>默认参数和居具名参数</h2><p>kotlin总的函数参数可以有默认值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span> <span class="params">(s:<span class="type">String</span> = <span class="string">"jun"</span>)</span></span>&#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具名参数，是指在调用函数时可以通过指定参数名传入参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span> <span class="params">(s:<span class="type">String</span> , x:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时，通过参数名传入</span></span><br><span class="line">test(x=<span class="number">10</span>,s=<span class="string">"jun"</span>)</span><br></pre></td></tr></table></figure>



<h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>使用vararg关键字，是函数传入参数数量可变</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> asList<span class="type">&lt;T&gt;</span><span class="params">(<span class="keyword">vararg</span> ts: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123; <span class="comment">//ts长度可变</span></span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> ts)</span><br><span class="line">        result.add(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>





<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>在kotlin中，类似C，函数可以作为一种变量进行传参，返回等。依噶函数的类型由其参数和返回值构成。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值为一个函数，类型是()-&gt;Unit，即诶呦参数，返回值为空</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span> <span class="params">()</span></span>:()-&gt;<span class="built_in">Unit</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span> <span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;</span><br><span class="line">        println(<span class="string">"jun"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = test()</span><br><span class="line">    a.invoke() <span class="comment">//调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>DSL(领域特定语言)，指在用更自然的语言替代繁杂的API。kotlin在DSL的表现有两个：</p>
<ul>
<li>扩张函数</li>
<li>中缀表达式</li>
</ul>
<p>扩张函数，给类中扩展一个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> //定义一个空类</span></span><br><span class="line"><span class="comment">//给类T添加扩张方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> T.<span class="title">test</span><span class="params">(s:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t = T()</span><br><span class="line">    t.test(<span class="string">"Jun"</span>)  <span class="comment">//使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中缀表达式，使扩张方法更加便于理解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="comment">//在函数前添加infix修饰符</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> T.<span class="title">test</span><span class="params">(s:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t = T()</span><br><span class="line">    t.test(<span class="string">"jun"</span>)</span><br><span class="line">    t test <span class="string">"Jun"</span> <span class="comment">//可以使用空格方式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="匿名函数和Lambda表达式"><a href="#匿名函数和Lambda表达式" class="headerlink" title="匿名函数和Lambda表达式"></a>匿名函数和Lambda表达式</h2><p>所谓匿名函数，就是没有名称的函数，只定义了参数列表、返回值类型和函数体。<br>把一个匿名函数赋给一个没有定义函数体的函数对象，就构成了一个完整的函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(参数列表)</span></span>: 返回值类型 &#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个匿名函数赋给a</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="title">fun</span> <span class="params">(s:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda表达式实质也是一个匿名函数，内部通过匿名函数完成实现。    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123; 参数列表 -&gt;</span><br><span class="line">   函数体 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; s:String -&gt; println(s) &#125;</span><br></pre></td></tr></table></figure>



<h2 id="尾递归函数"><a href="#尾递归函数" class="headerlink" title="尾递归函数"></a>尾递归函数</h2><p>Kotlin 支持函数式编程的尾递归。这个允许一些算法可以通过循环而不是递归解决问题，从而避免了栈溢出。当函数被标记为 tailrec 时，编译器会优化递归，并用高效迅速的循环代替它。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span> </span><br><span class="line">    = <span class="keyword">if</span> (x == Math.cos(x)) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br></pre></td></tr></table></figure>

<p>上面这段代码和下面是等效的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> y = Math.cos(x)</span><br><span class="line">        <span class="keyword">if</span> ( x == y ) <span class="keyword">return</span> y</span><br><span class="line">        x = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2>]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图</title>
    <url>/Tools-UML/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UML：统一建模语言，是用来支持模型化和软件开发的一种图形化语言。</p>
<p>UML类图：是UML中用于描述“对象模型”的。对象模型：描述对象的静态结构以及映射关系的一种模型。</p>
<h2 id="UML类图符号"><a href="#UML类图符号" class="headerlink" title="UML类图符号"></a>UML类图符号</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>最基本的图形，在类中，包含三个属性：类名、属性、方法。使用<strong>带分割线的矩形框</strong>表示。</p>
<p><img src="/Tools-UML/UML类图.png" alt="UML类图"></p>
<p>UML属性语法格式为：可见性 属性名 : 类型 = 初始值</p>
<p>UML方法语法格式为：可见性 属性名 : 返回类型</p>
<p>可见性分为三种：+表示公有、-表示私有、#表示保护</p>
<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><ul>
<li>泛化关系：表示是is-a的关系，就是<strong>继承</strong>关系，是对象之间耦合关系最大的一种关系。子类继承父类的所有细节。</li>
<li>图形表示：<strong>带三角箭头的实线</strong>，三角箭头指向父类</li>
<li>代码体现：类的继承</li>
</ul>
<h3 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h3><ul>
<li>实现关系：一种类与接口的关系，就是<strong>实现</strong>关系，表示类是接口所有特征和行为的实现。</li>
<li>图形表示：<strong>带三角箭头的虚线</strong>，三角箭头指向接口</li>
<li>代码体现：接口的实现</li>
</ul>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ul>
<li>聚合关系：表示has-a的关系，一种不稳定的包含关系。是一种整体与部分的关系，没有了整体，局部也可以单独存在。</li>
<li>图形表示：<strong>带空心菱形和箭头的实线</strong>，菱形指向整体，箭头指向部分</li>
<li>代码体现：成员变量</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li>组合关系：表示contains-a的关系，一种强烈的包含关系。是一种整体与部分的关系，但是部分不能离开整体而单独存在。</li>
<li>图形表示：<strong>带实心菱形和箭头的实线</strong>，菱形指向整体，箭头指向部分</li>
<li>代码体现：成员变量</li>
</ul>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><ul>
<li>关联关系：表示两个类之间存在某种语义上的联系。关联可以是双向的，也可以是单向的。</li>
<li>图形表示：<strong>带箭头的实心线</strong>，箭头指向被关联者</li>
<li>代码体现：成员变量</li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul>
<li>依赖关系：一个类依赖于另一个独立的类，当独立的类改变时，会导致依赖它的类也会改变。</li>
<li>图形表示：<strong>带箭头的虚线</strong>，箭头指向被依赖者</li>
<li>代码体现：局部变量、方法的参数或者对静态方法的调用</li>
</ul>
<p><img src="/Tools-UML/关系.png" alt="关系"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/Tools-UML/示例.png" alt="示例"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Android技能树</title>
    <url>/SkillTree/</url>
    <content><![CDATA[<p><img src="/SkillTree/Android技能树.png" alt="Android技能树"></p>
]]></content>
  </entry>
  <entry>
    <title>Activity的横竖屏切换</title>
    <url>/Android-Activity_change/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们使用Activity中，会有许多时候会遇到屏幕的切换，即横竖屏的切换，特别是视频播放的时候。下面我们看一下关于Activity横竖屏切换的时候一些问题。</p>
<h2 id="生命周期的变换"><a href="#生命周期的变换" class="headerlink" title="生命周期的变换"></a>生命周期的变换</h2><p>Activity的全部生命周期如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityA</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_layout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们正常启动Activity时，会使用的方法是：onCreate() 、onStart()、onResume()。</p>
<p>当我们进行横竖屏切换时：onPause()、onStop()、onDestroy()、onCreate()、onStart()、onResume()。Activity会先销毁，然后再创建。</p>
<h2 id="销毁后的数据保存"><a href="#销毁后的数据保存" class="headerlink" title="销毁后的数据保存"></a>销毁后的数据保存</h2><p>上面知道横竖屏切换时会进行销毁再创建，我们可以对一些数据进行保存。这时候便需要我们重写下面两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存取数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在切换横竖屏时，销毁Activity会调用onSaveInstanceState保存数据，再创建时会使用onRestoreInstanceState取出数据。</p>
<p>需要注意的是，这两个方法是在Activity异常终止时会调用，如横竖屏切换、内存不足杀掉Activity等。</p>
<h2 id="防止切换时重建Activity"><a href="#防止切换时重建Activity" class="headerlink" title="防止切换时重建Activity"></a>防止切换时重建Activity</h2><p>如果不希望Activity在切换时重建，可以在配置Activity时添加configChange参数，将它设置成： android:configChanges=”orientation|screenSize”便可以。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">".jun.ActivityA"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:configChanges</span>=<span class="string">"orientation|screenSize"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>configChange需要同时设置为orientation和screenSize才可以。当设置之后，切换横竖屏时不再是重建Activity，而是调用onConfigurationChanged方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="其他一些configChange属性"><a href="#其他一些configChange属性" class="headerlink" title="其他一些configChange属性"></a>其他一些configChange属性</h2><p>在Activity配置时可以配置这个属性来捕获设备状态变化。不同值可以通过“|”来分隔开。下面是可以被识别的内容：</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">识别内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mmc</td>
<td align="center">当前SIM卡所属国家</td>
</tr>
<tr>
<td align="center">mnc</td>
<td align="center">当前SIM卡运营商</td>
</tr>
<tr>
<td align="center">locale</td>
<td align="center">地理位置</td>
</tr>
<tr>
<td align="center">keyboard</td>
<td align="center">键盘改变了，外接键盘</td>
</tr>
<tr>
<td align="center">keyboardHidden</td>
<td align="center">键盘可见性发生部分</td>
</tr>
<tr>
<td align="center">navigation</td>
<td align="center">导航发生了变化</td>
</tr>
<tr>
<td align="center">touchscreen</td>
<td align="center">触摸屏是改变了</td>
</tr>
<tr>
<td align="center">screenLayout</td>
<td align="center">屏幕的布局发生了变化</td>
</tr>
<tr>
<td align="center">fontScale</td>
<td align="center">系统字体大小改变</td>
</tr>
<tr>
<td align="center">orientation</td>
<td align="center">屏幕方向改变，横竖屏切换。</td>
</tr>
<tr>
<td align="center">screenSize</td>
<td align="center">设备的屏幕的尺寸信息发生了改变</td>
</tr>
<tr>
<td align="center">smallestScreenSize</td>
<td align="center">设备的物理屏幕发生改变，外接屏幕</td>
</tr>
<tr>
<td align="center">uiMode</td>
<td align="center">用户界面改变，夜间模式</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>View自定义流程</title>
    <url>/Android-Custom-view/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android官方中已经提供了许多得到View控件给我们使用，但是根据不同的场景和业务要求，普通的View并不能满足我们的需求，这时候便要我们自定义View了。</p>
<h2 id="自定义View的流程和步骤"><a href="#自定义View的流程和步骤" class="headerlink" title="自定义View的流程和步骤"></a>自定义View的流程和步骤</h2><p>根据Android Developers官网的介绍，自定义控件你需要以下的步骤（根据你的需要，某些步骤可以省略）。</p>
<ol>
<li><strong>创建VIew</strong></li>
<li><strong>处理View布局</strong></li>
<li><strong>绘制View</strong></li>
<li><strong>与用户进行交互</strong></li>
<li><strong>优化已定义的View</strong></li>
</ol>
<h2 id="创建View"><a href="#创建View" class="headerlink" title="创建View"></a>创建View</h2><p>首先，我们的自定义控件需要继承View。在继承View之后，我们必须重写它的两个构造方法。</p>
<p>通常我们会在一个参数构造函数里面调用两个参数的构造函数，然后在两个参数的构造函数里面调用三个参数的构造函数。然后就可以在三个参数的构造函数中获取自定义属性。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们在代码中使用new 对象的方式创建一个自定View的时候，只能使用一个参数的构造函数。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们在布局文件里面使用自定义View的时候，调用的是两个参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三个参数的构造函数是我们在主动调用的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="comment">//在这里做一些初始化操作和获取自定义属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>自定义属性通常写在在res/values/attrs.xml文件中 下面是自定义属性的标准写法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"TestView"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"showText"</span> <span class="attr">format</span>=<span class="string">"boolean"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"labelPosition"</span> <span class="attr">format</span>=<span class="string">"enum"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"left"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"right"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在布局文件中的使用如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>    </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:text</span>=<span class="string">"http://schemas.android.com/apk/res/com.example.customviews"</span>&gt;</span>   </span><br><span class="line">     <span class="comment">&lt;!--text为自定义命名空间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.TestView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">text:showText</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">text:labelPosition</span>=<span class="string">"left"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义属性的获取如下，在构造方法中。当我们在 xml中创建了一个view时，所有在xml中声明的属性都会被传入到view的构造方法中的AttributeSet类型的参数当中。 通过调用Context的<code>obtainStyledAttributes()</code>方法返回一个TypedArray对象。然后直接用TypedArray对象获取自定义属性的值。由于TypedArray对象是共享的资源，所以在获取完值之后必须要调用<code>recycle()</code>方法来回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里在第二个构造方法获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(context, attrs) ；</span><br><span class="line">    <span class="comment">//获取TypedArray</span></span><br><span class="line">    TypedArray a = context.getTheme().</span><br><span class="line">        obtainStyledAttributes( attrs, R.styleable.TestView, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">//根据TypedArray获取属性</span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        mShowText = a.getBoolean(R.styleable.showText, <span class="keyword">false</span>); </span><br><span class="line">        mTextPos = a.getInteger(R.styleable.labelPosition, <span class="number">0</span>); </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        a.recycle(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加设置属性事件"><a href="#添加设置属性事件" class="headerlink" title="添加设置属性事件"></a>添加设置属性事件</h3><p>在xml中指定的自定义属性只有在view被初始化的时候能够获取到，有时候我们可能在运行时做一些操作，这种情况就需要我们为自定义属性设置<code>getter</code>和<code>setter</code>方法,以下代码展示了自定义控件暴露的set和get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShowText</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> mShowText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShowText</span><span class="params">(<span class="keyword">boolean</span> showText)</span> </span>&#123; </span><br><span class="line">    mShowText = showText; </span><br><span class="line">    invalidate(); </span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看setShowText方法，在为mShowText赋值之后，调用了<code>invalidate()</code>和<code>requestLayout()</code>方法，我们自定义控件的属性发生改变之后，控件的样子也可能发生改变，在这种情况下就需要调用<code>invalidate()</code>方法让系统去调用view的<code>onDraw()</code>重新绘制。同样的，控件属性的改变可能导致控件所占的大小和形状发生改变，所以我们需要调用<code>requestLayout()</code>来请求测量获取一个新的布局位置。</p>
<h2 id="处理View布局"><a href="#处理View布局" class="headerlink" title="处理View布局"></a>处理View布局</h2><p>在布局的处理这一步中，如果只是View的话，只需处理<code>onMeasure()</code>方法。而如果是ViewGroup时，还要处理<code>onLayout()</code>方法。</p>
<p>在<code>onMeasure()</code>方法中，方法接收两个参数：widthMeasureSpec, heightMeasureSpec。这两个参数每个又包含了mode和size这两个信息。可以通过如下方法获得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line"><span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br></pre></td></tr></table></figure>

<p>mode表示测量模式，他有三个取值，代表的意思分别如下：</p>
<ol>
<li>EXACTLY：父控件告诉我们子控件了一个确定的大小，你就按这个大小来布局。比如我们指定了确定的dp值和macth_parent的情况。</li>
<li>AT_MOST：当前控件不能超过一个固定的最大值，一般是wrap_content的情况。</li>
<li>UNSPECIFIED:当前控件没有限制，要多大就有多大，这种情况很少出现。size其实就是父布局传递过来的一个大小，父布局希望当前布局的大小。</li>
</ol>
<h2 id="绘制View"><a href="#绘制View" class="headerlink" title="绘制View"></a>绘制View</h2><p>这一步的话，是对View进行绘制。使用方法是<code>onDraw()</code>方法。在<code>onDraw()</code>方法中，包含了一个Canvas叫做画布的参数。具体来说，就是使用Canvas和Paint来进行对View的绘制。</p>
<ol>
<li>Canvas决定要去画什么。</li>
<li>Paint决定怎么画。</li>
</ol>
<h2 id="与用户进行交互"><a href="#与用户进行交互" class="headerlink" title="与用户进行交互"></a>与用户进行交互</h2><p>与用户的交互，就是处理点击事件，解决滑动冲突等。需要处理的方法是<code>onTouchEvent()</code>方法、<code>onInterceptTouchEvent()</code>方法和<code>dispatchTouchEvent()</code>方法。</p>
<ol>
<li>onTouchEvent：实际点击事件的处理。</li>
<li>onInterceptTouchEvent：拦截点击事件的处理。</li>
<li>dispatchTouchEvent：分发事件的处理。</li>
</ol>
<h2 id="优化已定义的View"><a href="#优化已定义的View" class="headerlink" title="优化已定义的View"></a>优化已定义的View</h2><p>在上面的步骤结束之后，其实一个完善的自定义控件已经出来了。接下来你要做的只是确保自定义控件运行得流畅，官方的说法是：为了避免你的控件看得来迟缓，确保动画始终保持每秒60帧。优化的方式主要有如下：</p>
<ol>
<li>避免不必要的代码</li>
<li>在onDraw()方法中不应该有会导致垃圾回收的代码。</li>
<li>尽可能少让onDraw()方法调用，大多数onDraw()方法调用都是手动调用了invalidate()的结果，所以如果不是必须，不要调用invalidate()方法。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/Java-Class_load/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类加载：指将类的class文件读入内存中，并为之创建一个java.lang.Class对象。</p>
<p>当程序主动使用到某个类时，如果该类还没有加载到内存中，系统就会通过<strong>加载</strong>、<strong>链接</strong>、<strong>初始化</strong>这三个步骤来将该类加载到内存中，类的加载也是这三个步骤的统称。</p>
<p>一般来说，类加载是由类加载器来完成。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类的加载过程可以分为以下7个部分。其中加载、验证、准备、初始化的顺序是确定的。而解析的顺序是不确定的，有时可能会在初始化之后解析，这是为了支持Java语言的动态绑定。使用和卸载是在之前所有执行完之后才执行的。</p>
<p><img src="/Java-Class_load/类加载过程.png" alt="类加载过程"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>在上述的类加载的过程中，加载这个动作被放到JVM外部实现，以便让应用程序决定如何获取所需的类。</p>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>在JVM中，提供了3种类型的加载器。</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li>
<li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li>
<li>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM通过如下的双亲委派模型进行类的加载：</p>
<p><img src="/Java-Class_load/双亲委托模型.png" alt="双亲委托模型"></p>
<p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</p>
<p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换。</p>
<h3 id="类加载器的关系"><a href="#类加载器的关系" class="headerlink" title="类加载器的关系"></a>类加载器的关系</h3><p>我们进一步了解类加载器间的关系(并非指继承关系)，主要可以分为以下4点</p>
<ol>
<li>启动类加载器，由C++实现，没有父类。</li>
<li>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null</li>
<li>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader</li>
<li>自定义类加载器，父类加载器肯定为AppClassLoader。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ANR异常</title>
    <url>/Android-ANR/</url>
    <content><![CDATA[<h2 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR"></a>什么是ANR</h2><p>在Android当中，如果我们的应用程序有一段时间点击不够灵敏，即没有响应，Android就会显示一个对话框，这个对话框的内容就是ANR，即是Application Not Responding。弹出对话框让用户处理是否等待或关闭应用程序是非常不好的。</p>
<h2 id="造成ANR的原因"><a href="#造成ANR的原因" class="headerlink" title="造成ANR的原因"></a>造成ANR的原因</h2><p>应用程序的响应性是由Activity Manager和Window Manager系统服务监视的，当它们监视到主线程(UI线程)如果在规定时内没有处理完相应工作，便会弹出ANR。具体来说，ANR会在以下几种情况中出现：</p>
<ol>
<li>输入事件(按键和触摸事件)5s内没被处理: Input event dispatching timed out。</li>
<li>BroadcastReceiver的事件(onRecieve方法)在规定时间内没处理完(前台广播为10s，后台广播为60s)：Timeout of broadcast BroadcastRecord。</li>
<li>service 前台20s后台200s未完成启动 Timeout executing service。</li>
<li>ContentProvider的publish在10s内没进行完：timeout publishing content providers。</li>
</ol>
<p>这些情况都是在主线程发生的，所以分析ANR的大致原因可以分为以下：</p>
<ol>
<li>主线程在做一些耗时的工作。</li>
<li>主线程被其他线程锁。</li>
<li>cpu被其他进程占用，该进程没被分配到足够的cpu资源。</li>
</ol>
<h2 id="解决ANR的方法"><a href="#解决ANR的方法" class="headerlink" title="解决ANR的方法"></a>解决ANR的方法</h2><ol>
<li>不要在主线程读取数据：在Android中主线程去读取数据是非常不好的，Android是不允许主线程从网络读数据的，但系统允许主线程从数据库或者其他地方获取数据，但这种操作ANR风险很大，也会造成掉帧等，影响用户体验。</li>
<li>不要在broadcastReciever的onRecieve()方法中干活：这一点很容易被忽略，尤其应用在后台的时候。为避免这种情况，一种解决方案是直接开的异步线程执行，但此时应用可能在后台，系统优先级较低，进程很容易被系统杀死，所以可以选择开个IntentService去执行相应操作，即使是后台Service也会提高进程优先级，降低被杀可能性。</li>
<li>各个组件的生命周期函数都不应该有太耗时的操作：即使对于后台Service或者ContentProvider来讲，应用在后台运行时候其onCreate()时候不会有用户输入引起事件无响应ANR，但其执行时间过长也会引起Service的ANR和ContentProvider的ANR。</li>
<li>尽量避免主线程的被锁的情况：在一些同步的操作主线程有可能被锁，需要等待其他线程释放相应锁才能继续执行，这样会有一定的ANR风险，对于这种情况有时也可以用异步线程来执行相应的逻辑。另外， 我们要避免死锁的发生(主线程被死锁基本就等于要发生ANR了)。</li>
</ol>
<p>​    </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义圆形ImageView</title>
    <url>/Android-View-CircleImageView/</url>
    <content><![CDATA[<p>继承自ImageView的自定义圆形View，使用的方法是在onDraw中绘制圆形区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleImageView</span> <span class="keyword">extends</span> <span class="title">ImageView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> radius;</span><br><span class="line">    <span class="keyword">private</span> Paint paint;</span><br><span class="line">    <span class="keyword">private</span> Matrix matrix;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleImageView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleImageView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleImageView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        paint = <span class="keyword">new</span> Paint();</span><br><span class="line">        paint.setAntiAlias(<span class="keyword">true</span>);   <span class="comment">//设置抗锯齿</span></span><br><span class="line">        matrix = <span class="keyword">new</span> Matrix();      <span class="comment">//初始化缩放矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测量控件的宽高，并获取其内切圆的半径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        width = getMeasuredWidth();</span><br><span class="line">        height = getMeasuredHeight();</span><br><span class="line">        radius = Math.min(width, height) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getDrawable();</span><br><span class="line">        <span class="keyword">if</span> (drawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> BitmapDrawable) &#123;</span><br><span class="line">            paint.setShader(initBitmapShader((BitmapDrawable) drawable));<span class="comment">//将着色器设置给画笔</span></span><br><span class="line">            canvas.drawCircle(width / <span class="number">2</span>, height / <span class="number">2</span>, radius, paint);<span class="comment">//使用画笔在画布上画圆</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ImageView中资源图片的Bitmap，利用Bitmap初始化图片着色器,通过缩放矩阵将原资源图片缩放到铺满整个绘制区域，避免边界填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BitmapShader <span class="title">initBitmapShader</span><span class="params">(BitmapDrawable drawable)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = drawable.getBitmap();</span><br><span class="line">        BitmapShader bitmapShader = <span class="keyword">new</span> BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class="line">        <span class="keyword">float</span> scale = Math.max(width / bitmap.getWidth(), height / bitmap.getHeight());</span><br><span class="line">        matrix.setScale(scale, scale);<span class="comment">//将图片宽高等比例缩放，避免拉伸</span></span><br><span class="line">        bitmapShader.setLocalMatrix(matrix);</span><br><span class="line">        <span class="keyword">return</span> bitmapShader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/Design_patterns/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式：是对于某些问题的代码设计解决方案，使用设计模式能够更好的解决问题。设计模式的作用有如下几点：</p>
<ul>
<li>提高代码复用率，降低开发成本和周期。</li>
<li>提高代码可维护性、可拓展性。</li>
<li>使代码更加优雅。</li>
<li>让代码更容易被他人理解。</li>
</ul>
<h2 id="设计模式应遵循的原则"><a href="#设计模式应遵循的原则" class="headerlink" title="设计模式应遵循的原则"></a>设计模式应遵循的原则</h2><p>设计模式的设计不能随意，应该按照特定得到原则才能发挥其作用：</p>
<p><img src="/Design_patterns/设计模式原则.jpg" alt="设计模式原则"></p>
<h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1.单一责任原则"></a>1.单一责任原则</h3><p>一个类=只有一个引起它变化的原因。如果一个类承担的职责过多，即耦合性太高=一个职责的变化可能会影响到其他的职责。</p>
<h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2.开放封闭原则"></a>2.开放封闭原则</h3><p>一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</p>
<h3 id="3-里氏代替原则"><a href="#3-里氏代替原则" class="headerlink" title="3.里氏代替原则"></a>3.里氏代替原则</h3><p>子类必须替换掉它们的父类型。在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</p>
<h3 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4.依赖倒置原则"></a>4.依赖倒置原则</h3><p>细节应该依赖于抽象，而抽象不应该依赖于细节。所谓的的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</p>
<h3 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h3><p>使用多个专门功能的接口，而不是使用单一的总接口。不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。</p>
<h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h3><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。 新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。</p>
<h3 id="7-最少知识原则（迪米特法则）"><a href="#7-最少知识原则（迪米特法则）" class="headerlink" title="7.最少知识原则（迪米特法则）"></a>7.最少知识原则（迪米特法则）</h3><p>一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在Java开发中的23种常用设计模式可以分为3大类：</p>
<p><img src="/Design_patterns/设计模式分类.jpg" alt="设计模式分类"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制</title>
    <url>/Android-Handler/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Handler机制是Android SDK提供给开发者的一个进行异步消息处理的机制。Handler机制常用于异步进行UI界面的刷新。包括相关的类有Looper、Handler、Message、MessageQueue等。</p>
<h2 id="Looper类"><a href="#Looper类" class="headerlink" title="Looper类"></a>Looper类</h2><p>looper，循环器的意思。他便是消息机制的核心，处理消息的就是它。它在内部使用了ThreadLocal来使每一个线程获取的都是自己的looper，从而达到一个线程绑定一个looper的效果。主线程在创建时在内部已经创建了Looper了，ActivityThread的main方法中执行，调用了prepare()创建Looper并且调用loop()方法进行循环。我们在主线程中不需要自己创建，而在子线程如果需要使用Looper便要自己去调用prepare()和loop()。</p>
<p>下面是Looper类中主要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用ThreadLocal使Looper每个线程都是不同Looper</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="comment">//主线程的Looper</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"><span class="comment">//消息队列</span></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="comment">//当前线程</span></span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure>

<p>Looper的主要方法有如下：</p>
<p>1.prepare()方法，用于初始化Looper，一定要调用才能创建Looper。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//一个线程只允许一个Looper</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed)); <span class="comment">//创建Looper</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();<span class="comment">//当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.myLooper()方法，用于获取当前线程looper，一般会在子线程使用Looper时调用来创建Handler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();  <span class="comment">//获取Looper，需要在prepare()方法之后才能获取到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.loop()方法，消息循环机制的大前提, 使调用线程进入死循环处理消息。在loop里面进行消息的分发处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//取得messageQueue</span></span><br><span class="line">    ......<span class="comment">//省略代码</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">//取出下一个message</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......<span class="comment">//省略代码</span></span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">//这个就是使用message对应的handler的dispatchMessage方法，进行消息处理</span></span><br><span class="line">        ......<span class="comment">//省略代码</span></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="MessageQueue类"><a href="#MessageQueue类" class="headerlink" title="MessageQueue类"></a>MessageQueue类</h2><p>消息队列，用来存放Message，Handler的消息发送就是发送到这个消息队列。</p>
<p>MessageQueue的一些主要成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message mMessages; <span class="comment">//这个便是消息队列，mMessages是队列的头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"><span class="comment">//IdleHandler接口表示当MessageQueue发现当前没有更多消息可以处理的时候</span></span><br><span class="line"><span class="comment">//则会顺便干点别的事情的callback函数（即如果发现idle了，那就找点别的事干）</span></span><br></pre></td></tr></table></figure>

<p>MessageQueue的主要方法enqueueMessage()，Handler发送消息最终都会使用这个方法将消息插入队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对msg进行检查</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入同步块</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//如果此队列处于正在退出的状态则不能在往里入队了，不能插入元素了</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//进行插入</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;<span class="comment">//是第一个</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//不是第一个</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Message类"><a href="#Message类" class="headerlink" title="Message类"></a>Message类</h2><p>消息对象，就是MessageQueue里面存放的对象。下面是部分源码截取分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现了Parcelable接口，也就是说实现了序列化，这就说明Message可以在不同进程之间传递。  </span></span><br><span class="line">    <span class="comment">//下面是一些标志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="comment">/*package*/</span> Handler target; <span class="comment">//包含一个名为target的Handler对象</span></span><br><span class="line">    <span class="comment">/*package*/</span> Runnable callback; <span class="comment">//2. 包含一个名为callback的Runnable对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用obtain方法可以从消息池中获取Message的实例，也是推荐大家使用的方法，而不是直接调用构造方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h2><p>Handler的主要作用有两点：（1）发送消息到队列中；（2）实现具体处理消息方法。</p>
<p>Handler的主要方法如下：</p>
<p>dispatchMessage()方法，消息处理的方法，在looper中循环出来message，然后调用这个方法，再里面是使用了handleMessage()方法，这个需要我么自己重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理消息方法，looper中循环出来message，然后调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果Message中的callback(即runnable)存在，则直接运行runnable</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果实现了接口mCallback，则运行mCallback.handleMessage()</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有的话再运行handleMessage()</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123; <span class="comment">//Handler中的一个接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;<span class="comment">//需要重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空方法，需要重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enqueueMessage()方法，在Handler中放消息最后都会调用这个方法，最后再调用queue.enqueueMessage。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;<span class="comment">//将message绑定当前handler</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后再调用queue.enqueueMessage</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Handler机制的原理"><a href="#Handler机制的原理" class="headerlink" title="Handler机制的原理"></a>Handler机制的原理</h2><p>分析完各个主要的类之后，我们便可以知道大致原理。</p>
<ol>
<li>系统会在主线程一开始会创建好Looper和MessageQueue。</li>
<li>我们需要在主线程中创建Handler。</li>
<li>在子线程创建Message，使用主线程的Handler将此Message发送到主线程的MessageQueue中。</li>
<li>主线程的Looper会一直循环MessageQueue，若有可以处理的Message，调用该Message对应Handler的处理消息方法。</li>
<li>Handler在主线程中处理Message。</li>
</ol>
<p><img src="/Android-Handler/handler.png" alt></p>
<h2 id="Handler带来的内存泄露"><a href="#Handler带来的内存泄露" class="headerlink" title="Handler带来的内存泄露"></a>Handler带来的内存泄露</h2><h3 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h3><p>因为handleMessage()为空方法，我们有时需要在收到Message时根据不同Message做出不同处理。所以一般我们会在Activity类里面创一个Handler的内部类，重写handleMessage()方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(),<span class="string">"handler"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是一段简单的Handler的使用。当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="通过程序逻辑来进行保护"><a href="#通过程序逻辑来进行保护" class="headerlink" title="通过程序逻辑来进行保护"></a>通过程序逻辑来进行保护</h4><ol>
<li>在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。</li>
<li>如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。</li>
</ol>
<h4 id="使用弱引用"><a href="#使用弱引用" class="headerlink" title="使用弱引用"></a>使用弱引用</h4><p>将Handler声明为静态类，对Activity改为弱引用，在最后取消掉该Handler对象的Message和Runnable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    WeakReference&lt;MyActivity&gt; mActivityReference;    <span class="comment">//弱引用对象</span></span><br><span class="line">    MyHandler(MyActivity activity) &#123;</span><br><span class="line">        mActivityReference= <span class="keyword">new</span> WeakReference&lt;MyActivity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyActivityactivity = mActivityReference.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.tv_hello.setText(<span class="string">""</span>);   <span class="comment">//获取activity中的方法或对象进行操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Handler handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);   <span class="comment">//使用时传入this</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;     <span class="comment">//最后需要取消掉该Handler对象的Message和Runnable。</span></span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    handler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不创建内部类"><a href="#不创建内部类" class="headerlink" title="不创建内部类"></a>不创建内部类</h4><p>使用回调函数Handler.Cellback()。不在Activity中创建内部类，创建Handler时传入一个cellback参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相关操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/Internet-HTTP/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTTP(Hyper Text Transfer Protocol)即超文本传输协议，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。它基于TCP/IP通信协议来进行数据传递，数据可以是超文本、图片、文件、结果等。</p>
<p>HTTP工作于客户端-服务器架构上。浏览器作为客户端，通过URL向服务端发送请求(Request)。服务端接收到请求后，向客户端发送响应(Response)。</p>
<p><img src="/Internet-HTTP/Http请求响应模型.jpg" alt="Http请求响应模型"></p>
<h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><ol>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
<li>支持B/S和C/S模式。</li>
</ol>
<h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><p>URL(uniform resource identifier)，统一资源标识符。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都可以使用URI来进行定位。URI一般有以下3部分组成：</p>
<ol>
<li>访问资源的命名机制。</li>
<li>存放资源的主机名。</li>
<li>资源自身的名称，由路径表示，着重强调于资源。</li>
</ol>
<p>URL(uniform resource locator)，统一资源定位符。它是一个具体的URI，不仅识别还可以具体定位。一般由以下三个部分组成：</p>
<ol>
<li>协议</li>
<li>存有该资源的主机IP地址(有时也包括端口号)。</li>
<li>主机资源的具体地址。如目录和文件名等。</li>
</ol>
<p><img src="/Internet-HTTP/URL.png" alt="URL"></p>
<h2 id="HTTP请求-Request"><a href="#HTTP请求-Request" class="headerlink" title="HTTP请求(Request)"></a>HTTP请求(Request)</h2><p>http的请求由4部分组成：请求行、请求头、请求空行和请求体。</p>
<p><img src="/Internet-HTTP/请求.png" alt></p>
<p>请求方法有如下8中，较为常用的有post和get：</p>
<ul>
<li>GET：请求指定的页面信息，并返回实体主体。</li>
<li>HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE：请求服务器删除指定的页面。</li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS：允许客户端查看服务器的性能。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<p>常见请求头有如下几个：</p>
<ul>
<li>Accept：可以接受的东西。</li>
<li>Accept-Encoding：编码格式。</li>
<li>Accept-Language：语言。</li>
<li>Host：端口号。</li>
<li>User-Agent：客户端的操作系统和浏览器名称版本。</li>
<li>Referer：从哪个页面连接过来的。</li>
<li>If-None-Match：一个Etag值，服务器端收到同一个Etag值会返回304，告诉浏览器从本地获取</li>
<li>If-Modified-Since：把浏览器最后缓存时间发给服务器端，如果一致返回304</li>
</ul>
<p>Post和Get的一些主要区别</p>
<ul>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx？name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ul>
<h2 id="HTTP响应-Response"><a href="#HTTP响应-Response" class="headerlink" title="HTTP响应(Response)"></a>HTTP响应(Response)</h2><p>http的响应也是由由4部分组成：响应行、响应头、响应空行和响应体。</p>
<p><img src="/Internet-HTTP/响应.png" alt></p>
<p>响应状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>常见的状态码有如下几个：</p>
<ul>
<li>200 OK                        //客户端请求成功</li>
<li>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li>
<li>403 Forbidden                 //服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found                 //请求资源不存在，eg：输入了错误的URL</li>
<li>500 Internal Server Error     //服务器发生不可预期的错误</li>
<li>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS：是以安全为目标的HTTP通道，简单讲就是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如下图所示：</p>
<p><img src="/Internet-HTTP/工作原理.gif" alt></p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li>
<li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li>
<li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li>
<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信。</li>
</ol>
<h3 id="HTTSP的优缺点"><a href="#HTTSP的优缺点" class="headerlink" title="HTTSP的优缺点"></a>HTTSP的优缺点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<ol>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ol>
<p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p>
<ol>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络体系结构</title>
    <url>/Internet-Network-architecture/</url>
    <content><![CDATA[<h2 id="计算机网络的分层"><a href="#计算机网络的分层" class="headerlink" title="计算机网络的分层"></a>计算机网络的分层</h2><p>两个系统中的实体通信是一个非常复杂的过程，对其使用分层的方式进行建模，可以更加有效的对系统进行实现和维护。计算机网络中，也是用了分层的概念，将整个计算机网络的通信进行层次划分。计算机网络的体系结构就是就层次、各层的协议以及层间接口的集合。模型进行分层的基本原则是：</p>
<ol>
<li><p>每一居都实现一种相对独立的功能 ，降低大系统的复杂度 。</p>
</li>
<li><p>各层之间界面自然清晰 ，易于理解，相互交流尽可能少 。</p>
</li>
<li><p>各层功能的精确定义独立于具体的实现方法 ，可以采用最合适的技术来实现 。</p>
</li>
<li><p>保持下层对上层的独立性 ，上层单向使用下层提供的服务 。</p>
</li>
<li><p>整个分层结构应能促进标准化工作 。</p>
</li>
</ol>
<h2 id="协议与服务"><a href="#协议与服务" class="headerlink" title="协议与服务"></a>协议与服务</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议：就是约定规则的组合。它是一种<strong>水平</strong>方向的，即两边的同一层才会有相同协议的约定。协议由语法、语义和同步三部分组成。语法规定了传输数据的格式；语义规定了所要完成的功能，即需要发出何种控制信息 、完成何种动作以及做出何种应答；同步规定了执行各种操作的条件、时序关系等 ，即事件实现顺序的详细说明 。一个完整的协议通常应具有线路管理（建立、 释放连接）、差错控制 、数据转换等功能 。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务：指下层为紧相邻的上层提供的功能调用，也就是<strong>垂直</strong>的。</p>
<p>协议与服务的关系如下：</p>
<p><img src="/Internet-Network-architecture/协议与服务.png" alt="服务于协议"></p>
<h2 id="计算机网络结构模型"><a href="#计算机网络结构模型" class="headerlink" title="计算机网络结构模型"></a>计算机网络结构模型</h2><ul>
<li>OSI七层模型：开放系统互连参考模型（OSI/RM），一共有七层。自下而上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。</li>
<li>TCP/IP四层模型：对于OSI的一种简化，一共有四层。分别为网络接口层、网络层、运输层、应用层。</li>
<li>五层模型：一种对于OSI和TCP/IP的折中，一共有5层。分别为物理层、数据链路层、网络层、运输层、应用层。</li>
</ul>
<p><img src="/Internet-Network-architecture/计算机网络体系结构.png" alt></p>
<p>下面是五层模型中每层的简要概述：</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul>
<li>作用：他规定了通信端点之间的一些特性，如机械、电气、功能特性。为上层协议提供了一个传输数据的物理媒体。</li>
<li>数据单元为：比特（bit）。</li>
<li>在物理层的互联设备包括：集线器（Hub）、中继器（Repeater）等。</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul>
<li>作用：控制网络层与物理层之间的通信，其主要功能是在不可靠的物理介质上提供可靠的传输。功能包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</li>
<li>数据单元：帧（frame）。</li>
<li>在数据链路层的互联设备包括：网桥（Bridge）、交换机（Switch）等。</li>
<li>在数据链路层的协议有：CSMA/CD等</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>作用：对网络地址和物理地址进行相互翻译，并确定数据如何重发送方发送到接收方。功能包括：对子网间的数据包进行路由选择，实现拥塞控制、网际互连等。</li>
<li>数据单元：数据包（packet）。</li>
<li>在网络层的互联设备包括：路由器（Router）等。</li>
<li>在网络层的协议有：IP、ICMP、ARP、RIP、OSPF等。</li>
</ul>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><ul>
<li>模型中最重要的一层，是第一个端到端，即主机到主机的层次。</li>
<li>作用：负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</li>
<li>协议数据单元：数据段（segment）。</li>
<li>传输层协议的代表包括：TCP、UDP、SPX等。</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>作用：为操作系统或网络应用程序提供访问网络服务的接口。</li>
<li>协议数据单元：报文（message）。</li>
<li>在应用层的互联设备包括：网关（Gateway）等。</li>
<li>传输层协议的代表包括：HTTP、FTP、DNS、SMTP等。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和UDP的区别</title>
    <url>/Internet-TCP&amp;UDP/</url>
    <content><![CDATA[<h2 id="TCP和UDP概述"><a href="#TCP和UDP概述" class="headerlink" title="TCP和UDP概述"></a>TCP和UDP概述</h2><p>在网络框架结构体系中，最主要的便是传输层，它是一个承上启下的环节，主要工作是负责端到端之间的通信。在这一层中有两个重要的协议：1.用户数据报协议UDP(User Datagram Protocol)；传输控制协议TCP(Transmission Control Protocol)。</p>
<p><img src="/Internet-TCP&UDP/TCP和UDP.png" alt></p>
<h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p>TCP，提供<strong>面向连接的服务</strong>，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认连接，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<h2 id="传输层常用端口号"><a href="#传输层常用端口号" class="headerlink" title="传输层常用端口号"></a>传输层常用端口号</h2><p>端口是传输层服务访问点(TSAP)，端口的作用是让应用层的各种应用进程都能将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的进程。下面是常用端口。</p>
<table>
<thead>
<tr>
<th align="center">应用程序</th>
<th align="center">FTP</th>
<th align="center">TELNET</th>
<th align="center">SMTP</th>
<th align="center">HTTP</th>
<th align="center">HTTPS</th>
<th align="center">DNS</th>
<th align="center">TFTP</th>
<th align="center">SNMP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">熟知端口</td>
<td align="center">21</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">80</td>
<td align="center">443</td>
<td align="center">53</td>
<td align="center">69</td>
<td align="center">161</td>
</tr>
<tr>
<td align="center">传输层协议</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">UDP</td>
<td align="center">UDP</td>
<td align="center">UDP</td>
</tr>
</tbody></table>
<h2 id="TCP和UDP首部"><a href="#TCP和UDP首部" class="headerlink" title="TCP和UDP首部"></a>TCP和UDP首部</h2><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p><img src="/Internet-TCP&UDP/TCP首部.jpg" alt="TCP首部"></p>
<ol>
<li><p>第一个4字节：</p>
<ul>
<li>源端口，16位；发送数据的源进程端口。</li>
<li>目的端口，16位；接收数据的进程端口。</li>
</ul>
</li>
<li><p>第二个4字节与第三个4字节</p>
<ul>
<li>序号，32位；代表当前TCP数据段第一个字节占整个字节流的相对位置。</li>
<li>确认号，32位；代表接收端希望接收的数据序号，为上次接收到数据报的序号+1，当ACK标志位为1时才生效。</li>
</ul>
</li>
<li><p>第四个4字节</p>
<ul>
<li><p>数据偏移，4位；实际代表TCP首部长度，最大为60字节。</p>
</li>
<li><p>6个标志位，每个标志位1位。</p>
<p>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p>
<p>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</p>
<p>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p>
<p>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p>
<p>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</p>
<p>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。</p>
</li>
<li><p>窗口值，16位；指的是通知接收方，发送本报文你需要有多大的空间来接受。</p>
</li>
</ul>
</li>
<li><p>第五个4字节</p>
<ul>
<li>校验和，16位；用于检验首部和数据的完整性。</li>
<li>紧急指针，16位；只有当URG标识位为1时，紧急指针才有效。紧急指针的值与序号的相加值为紧急数据的最后一个字节位置。用于发送紧急数据。</li>
</ul>
</li>
</ol>
<h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p><img src="/Internet-TCP&UDP/UDP首部.png" alt="UDP首部"></p>
<ol>
<li><p>后8个字节</p>
<ul>
<li>源端口，16位；发送数据的源进程端口。</li>
<li>目的端口，16位；接收数据的进程端口。</li>
<li>长度，16位；UDP数据长度。</li>
<li>检验和，16位；检测UDP在传输中是否有错，有错早就丢弃。</li>
</ul>
</li>
<li><p>前12个字节</p>
<p>伪首部：不是真正的UDP首部，只是在计算校验和时，临时添加在UDP前，得到一个临时的UDP。校验和就是更根据这个临时的UDP来计算的。伪首部既不向下传递也不向上递交，而是仅仅为了计算校验和。</p>
</li>
</ol>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol>
<li>TCP基于连接；UDP基于无连接。</li>
<li>TCP要求系统资源较多；UDP较少。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。</li>
<li>TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法</title>
    <url>/Algorithm_design-LRU/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
      <categories>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Algorithm_design-Sorting_Algorithm/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h3><p>排序算法中，大类型可以分为两类：非线性时间比较类排序和线性时间非比较类排序。</p>
<ol>
<li><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li>
<li><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li>
</ol>
<p><img src="/Algorithm_design-Sorting_Algorithm/排序算法分类.png" alt="排序算法分类"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>稳定性：相同元素在排序之后前后顺序位置没有交换。</p>
<p>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p>
<p>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p>
<h3 id="各算法复杂度和稳定性比较"><a href="#各算法复杂度和稳定性比较" class="headerlink" title="各算法复杂度和稳定性比较"></a>各算法复杂度和稳定性比较</h3><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n·\log_2 n)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>插入排序是一种直观排序方法。工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>第一个元素开始，该元素认为已经排好序。</li>
<li>取下一个元素k，在已经排好序的元素序列中从后往前扫。</li>
<li>如果扫到的元素j比k大，把j往后移动一位。</li>
<li>重复3步骤，直到扫到元素j比k小。</li>
<li>将k插入到扫描到的位置中。</li>
<li>重复2~5步骤。</li>
</ol>
<h3 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/插入排序动态图.gif" alt="插入排序动态图"></p>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;array.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = array[i] ;</span><br><span class="line">        <span class="keyword">int</span> j=i-<span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//从后往前遍历，插入到前面的有序序列中</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; k&lt;array[j])&#123;</span><br><span class="line">            array[j+<span class="number">1</span>] = array[j] ;</span><br><span class="line">            j-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j+<span class="number">1</span>] = k ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性"><a href="#时间复杂度和稳定性" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>直接插入排序中。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需$(n-1)$次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有$n(n-1)/2$次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说直接插入排序的时间复杂度为$O(n^2)$。</p>
<p>应为采用的比较方式不是&lt;=而是&lt;，所以直接插入排序是稳定的排序算。</p>
<h2 id="2-二分插入排序"><a href="#2-二分插入排序" class="headerlink" title="2.二分插入排序"></a>2.二分插入排序</h2><p>与直接插入排序类似，只不过是通过二分查找来先找到需要插入的位置。</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置。</li>
<li>将新元素插入到该位置。</li>
<li>重复2~3步骤。</li>
</ol>
<h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bin_insert_sort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = a[i] ;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span> , right=i-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//采用二分法找第一个比k大的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(a[middle]&gt;k)</span><br><span class="line">                right = middle-<span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = middle+<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span> ; j&gt;=left ; j--)&#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = k ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-1"><a href="#时间复杂度和稳定性-1" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>当n较大时，总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。最佳情况$O(n*\log n)$，最差和平均情况$O(n^2)$。</p>
<p>二分查找中寻找的是第一个比他大，不存在&gt;=情况。所以二分插入排序是稳定的排序算法。</p>
<h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h2><p>希尔排序，也称递减增量排序算法，因DL．Shell于1959年提出而得名，是插入排序的一种高速而稳定的改进版本。采用分组插入的方式进行排序。</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。</li>
<li>所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。</li>
<li>取第二个增量d2&lt;d1重复上述的分组和排序，</li>
<li>直至所取的增量dt=1(dt&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</li>
</ol>
<h3 id="演示图-1"><a href="#演示图-1" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/希尔排序动态图.gif" alt="希尔排序演示图"></p>
<h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里增量取数组长度一半(希尔增量)</span></span><br><span class="line">    <span class="keyword">int</span> gap = a.length/<span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">while</span>(gap&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;gap ; i++)&#123;</span><br><span class="line">            <span class="comment">//内部进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i ; j&lt;a.length ; j+=gap)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j] ;</span><br><span class="line">                <span class="keyword">int</span> k = j-gap ;</span><br><span class="line">                <span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; temp&lt;a[k])&#123;</span><br><span class="line">                    a[k+gap] = a[k] ;</span><br><span class="line">                    k-=gap ;</span><br><span class="line">                &#125;</span><br><span class="line">                a[k+gap] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-2"><a href="#时间复杂度和稳定性-2" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为$O(n^2)$。而Hibbard增量的希尔排序的时间复杂度为$O(n^{5/4})$，但是现今仍然没有人能找出希尔排序的精确下界。平均时间复杂度为$O(n^{1.3})$。</p>
<p>希尔排序是不稳定的。因为在不同增量小组中可能有相同元素，但是会根据不同小组进行排序，导致可能出现换位。</p>
<h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.选择排序"></a>4.选择排序</h2><p>选择排序也是一种比较直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>一开始数组分为有序序列(空)和无序序列([0…n])。</li>
<li>在无序序列中选择一个最小的数，放到有序序列最后面。</li>
<li>重复步骤2，一直直到无序序列为空。</li>
</ol>
<h3 id="演示图-2"><a href="#演示图-2" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/选择排序动态图.gif" alt="直接选择排序动态图"></p>
<h3 id="Java代码-3"><a href="#Java代码-3" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i ;</span><br><span class="line">        <span class="comment">//选取最大的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i ; j&lt;a.length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[k])&#123;</span><br><span class="line">                k = j ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">        a[i] = a[k] ;</span><br><span class="line">        a[k] = temp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-3"><a href="#时间复杂度和稳定性-3" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>选择排序的比较次数为$n(n-1)/2$,交换次数最好情况为$0$，最坏情况为$n-1$。平均时间复杂度为$O(n^2)$。</p>
<p>因为是选择最小的交换到前面，不能保证前面的数交换到的位置。所以是不稳定的排序算法。</p>
<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h2><p>利用堆这种数据结构，实现的排序算法。这里的堆是一个完全二叉树，并满足堆性质：子节点的值或索引小于父结点。</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将序列构建成大顶堆。</li>
<li>将第一个元素与最后一个元素进行交换，并把交换完的最后一个元素移出堆中。</li>
<li>对交换完的第一个元素进行堆调整(把它插入到适合位置，使堆变回大顶堆)。</li>
<li>重复2~3步骤，直到堆中没有元素。</li>
</ol>
<h3 id="演示图-3"><a href="#演示图-3" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/堆排序动态图.gif" alt="堆排序动态图"></p>
<h3 id="Java代码-4"><a href="#Java代码-4" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        HeapAdjust(a,i,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换最前和最后，然后进行堆调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>] ;</span><br><span class="line">        a[<span class="number">0</span>] = a[i] ;</span><br><span class="line">        a[i] = temp ;</span><br><span class="line">        HeapAdjust(a,<span class="number">0</span>,i-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> t, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t&lt;l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t*<span class="number">2</span>+<span class="number">2</span>&lt;=l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[t*<span class="number">2</span>+<span class="number">2</span>]&gt;a[t] &amp;&amp; a[t*<span class="number">2</span>+<span class="number">2</span>]&gt;=a[t*<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[t] ;</span><br><span class="line">                a[t] = a[t*<span class="number">2</span>+<span class="number">2</span>] ;</span><br><span class="line">                a[t*<span class="number">2</span>+<span class="number">2</span>] = temp ;</span><br><span class="line">                t = t*<span class="number">2</span>+<span class="number">2</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[t*<span class="number">2</span>+<span class="number">1</span>]&gt;a[t] &amp;&amp; a[t*<span class="number">2</span>+<span class="number">1</span>]&gt;=a[t*<span class="number">2</span>+<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[t] ;</span><br><span class="line">                a[t] = a[t*<span class="number">2</span>+<span class="number">1</span>] ;</span><br><span class="line">                a[t*<span class="number">2</span>+<span class="number">1</span>] = temp ;</span><br><span class="line">                t = t*<span class="number">2</span>+<span class="number">1</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t*<span class="number">2</span>+<span class="number">1</span>&gt;l)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[t*<span class="number">2</span>+<span class="number">1</span>]&gt;a[t])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[t] ;</span><br><span class="line">                a[t] = a[t*<span class="number">2</span>+<span class="number">1</span>] ;</span><br><span class="line">                a[t*<span class="number">2</span>+<span class="number">1</span>] = temp ;</span><br><span class="line">                t = t*<span class="number">2</span>+<span class="number">1</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-4"><a href="#时间复杂度和稳定性-4" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>因为使用了二叉树结构，数的高度为$\log n$，所以说一次堆调整平均为$\log n$。而堆排序需要对n个数进行堆调整，所以堆排序平均时间复杂度为$O(n*\log n)$。</p>
<p>堆排序是不稳定的。因为在比较节点大小时，只会将最大的放到父结点，对于相同的没有做其他处理。</p>
<h2 id="6-冒泡排序"><a href="#6-冒泡排序" class="headerlink" title="6.冒泡排序"></a>6.冒泡排序</h2><p>使用多次比较的方法，让大的元素“浮”到尾部的排序方法。</p>
<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>比较相邻的两个元素，将较大的元素放到后面。</li>
<li>对序列中每一对元素进行上述操作。</li>
<li>将最大的元素“浮”到最后之后，对剩余的元素进行1~2步骤。</li>
<li>知直到没有剩余元素。</li>
</ol>
<h3 id="演示图-4"><a href="#演示图-4" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/冒泡排序动态图.gif" alt="冒泡排序动态图"></p>
<h3 id="Java代码-5"><a href="#Java代码-5" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;i-<span class="number">1</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j] ;</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>] ;</span><br><span class="line">                a[j+<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-5"><a href="#时间复杂度和稳定性-5" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>需要对n个元素进行n次比较，平均时间复杂度为$O(n^2)$。</p>
<p>比较的时候使用&gt;而不是&gt;=，所以是稳定的算法。</p>
<h2 id="7-鸡尾酒排序"><a href="#7-鸡尾酒排序" class="headerlink" title="7.鸡尾酒排序"></a>7.鸡尾酒排序</h2><p>鸡尾酒排序,也叫双向冒泡排序。是对冒泡排序的一种轻微变形。不同的地方是冒泡排序每次都是从低到高，而鸡尾酒排序则是从低到高然后从高到底这样循环。</p>
<h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>依次比较相邻的数，将小的元素放在前面，将大的元素放到后面。</li>
<li>先从先往后，将最大的放到最后一位。</li>
<li>然后从后往前，将最小的放到第一位。</li>
<li>重复2~3步骤，知道完成排序。</li>
</ol>
<h3 id="演示图-5"><a href="#演示图-5" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/鸡尾酒排序动态图.gif" alt="鸡尾酒排序演示"></p>
<h3 id="Java代码-6"><a href="#Java代码-6" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cocktail_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span> , tail=a.length-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">        <span class="comment">//从前往后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head ; i&lt;tail ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">                a[i] = a[i+<span class="number">1</span>] ;</span><br><span class="line">                a[i+<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-- ;</span><br><span class="line">        <span class="comment">//从后往前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tail ; i&gt;head ; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">                a[i] = a[i-<span class="number">1</span>] ;</span><br><span class="line">                a[i-<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-6"><a href="#时间复杂度和稳定性-6" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>和冒泡排序一样，需要进行n个元素的n次比较。平均时间复杂度为$O(n^2)$。</p>
<p>由于没有使用=，所以算法是稳定的。</p>
<h2 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a>8.快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。其基本思想是基本思想是，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从序列中选取一个元素，称为“基准”。</li>
<li>分别从前后两边扫描，把小于基准的元素放到左边，大一基准的放到右边，此时基准边处于中间位置。</li>
<li>分别对基准左右两边的序列进行上述1~2步骤的递归。</li>
</ol>
<h3 id="演示图-6"><a href="#演示图-6" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/快速排序动态图.gif" alt="快排演示"></p>
<h3 id="Java代码-7"><a href="#Java代码-7" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i=low , j=high ;</span><br><span class="line">    <span class="keyword">int</span> key = a[low] ; <span class="comment">//选取第一个数为基准</span></span><br><span class="line">    <span class="comment">//进行分类，小的分左边，大的分右边</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[j]&gt;key) j-- ;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=key) i++ ;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i] ;</span><br><span class="line">            a[i] = a[j] ;</span><br><span class="line">            a[j] = temp ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = a[i] ;</span><br><span class="line">    a[i] = key ;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quick_sort(a,low,i-<span class="number">1</span>);</span><br><span class="line">    quick_sort(a,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于快排的优化：</p>
<ol>
<li>选取随机标准值</li>
<li>在规模小时(&lt;8)使用直接插入排序</li>
<li>重复的数据多时，是用三路快排</li>
</ol>
</blockquote>
<h3 id="时间复杂度和稳定性-7"><a href="#时间复杂度和稳定性-7" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>它的平均时间复杂度是$O(n·\log_2 n)$。在平均状况下，排序n个项目要$Ο(n·\log_2 n)$次比较。在最坏状况下则需要$Ο(n^2)$次比较，但这种状况并不常见。事实上，快速排序通常明显比其他$Ο(n·\log_2 n)$算法更快，因为它的内部循环递归（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>它是不稳定的算法，因为在和比较基准，没有和其他的相同的数比较排放。</p>
<h2 id="9-归并排序"><a href="#9-归并排序" class="headerlink" title="9.归并排序"></a>9.归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。它使用额外的空间来进行分治。</p>
<h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将长度为n的序列分为两个长度为n/2的子序列。</li>
<li>对这两个子序列分别采用归并排序。</li>
<li>将两个子序列合并成有序序列。</li>
</ol>
<h3 id="演示图-7"><a href="#演示图-7" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/归并排序动态图.gif" alt="归并排序演示"></p>
<h3 id="Java代码-8"><a href="#Java代码-8" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger_sort</span><span class="params">(<span class="keyword">int</span>[] a , <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span> ;</span><br><span class="line">    merger_sort(a,low,middle);</span><br><span class="line">    merger_sort(a,middle+<span class="number">1</span>,high);</span><br><span class="line">    <span class="comment">//合并两个有序序列</span></span><br><span class="line">    merger(a,low,middle,high) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[high+<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span> center = middle+<span class="number">1</span> , start = low ;</span><br><span class="line">    <span class="keyword">int</span> i = low ;</span><br><span class="line">    <span class="comment">//比较后放到新数组中</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=middle &amp;&amp; center&lt;=high)</span><br><span class="line">        newArray[i++] = a[start]&gt;a[center] ? a[center++] : a[start++] ;</span><br><span class="line">    <span class="comment">//剩余的放到数组后面</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=middle)</span><br><span class="line">        newArray[i++] = a[start++] ;</span><br><span class="line">    <span class="keyword">while</span>(center&lt;=high)</span><br><span class="line">        newArray[i++] = a[center++] ;</span><br><span class="line">    <span class="comment">//复制数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=low ; j&lt;=high ; j++)&#123;</span><br><span class="line">        a[j] =newArray[j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-8"><a href="#时间复杂度和稳定性-8" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为$O(n)$，故一共为$O(n<em>\log n)$。所有平均复杂度为$O(n</em>\log n)$。</p>
<p>归并排序是稳定的算法。因为采取的是按前往的顺序的递归归并。不会出现后面跳到前面来。</p>
<h2 id="10-计数排序"><a href="#10-计数排序" class="headerlink" title="10.计数排序"></a>10.计数排序</h2><p>计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。所以它也只能对整数进行排序。</p>
<h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项。</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）。</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
<h3 id="演示图-8"><a href="#演示图-8" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/计数排序动态图.gif" alt="计数排序动态图"></p>
<h3 id="Java代码-9"><a href="#Java代码-9" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="keyword">int</span>[] a , <span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//k为数组中最大的数</span></span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length] ;</span><br><span class="line">    <span class="comment">//构建C数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        c[a[i]]+=<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对C数组进行调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;k+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">        c[i] += c[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放到新数组B中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        b[c[a[i]]-<span class="number">1</span>] = a[i] ;</span><br><span class="line">        c[a[i]]-=<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;a.length ; i++)&#123;</span><br><span class="line">        a[i] = b[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-9"><a href="#时间复杂度和稳定性-9" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>当输入的元素是n个0到k之间的整数时，它的运行时间是$O(n+k)$。所以平均时间复杂度为$O(n)$计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>计数排序是稳定的。因为插入到B数组时，采用的是倒序遍历A数组，插入的位置也是先后再前。</p>
<h2 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11.基数排序"></a>11.基数排序</h2><p>基数排序，桶排序的一种。是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从低位到高位开始，依次进行一次排序。</li>
</ol>
<h3 id="演示图-9"><a href="#演示图-9" class="headerlink" title="演示图"></a>演示图</h3><p><img src="/Algorithm_design-Sorting_Algorithm/基数排序动态图.gif" alt="基数排序动态图"></p>
<h3 id="Java代码-10"><a href="#Java代码-10" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找出最大的数的位数times</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE , times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">        times++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//radixArray用于摆放，radixBit用于辅助计数</span></span><br><span class="line">    <span class="keyword">int</span>[][] radixArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length];</span><br><span class="line">    <span class="keyword">int</span>[] radixBit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(times--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//将元素分类放进桶中，这就是排序了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (a[i] / radix) % <span class="number">10</span>;</span><br><span class="line">            radixArray[bit][radixBit[bit]] = a[i];</span><br><span class="line">            radixBit[bit] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按照桶的顺序放回A数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; radixBit.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; radixBit[i]; j++) &#123;</span><br><span class="line">                a[index ++] = radixArray[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            radixBit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度和稳定性-10"><a href="#时间复杂度和稳定性-10" class="headerlink" title="时间复杂度和稳定性"></a>时间复杂度和稳定性</h3><p>基数排序的时间复杂度是$O(k*n)$，其中n是排序元素个数，k是数字位数。但是不一定优于$O(n·\log n)$，因为k的大小一般会受到n的影响。需要使用的额外空间为$O(k+n)$。</p>
<p>它是稳定的排序算法，因为排序过程中没有元素的调换。</p>
]]></content>
      <categories>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/Android-Activity_Lunch_model/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在应用程序中，Activity是使用栈形式管理的，多个Activity一般会按照先进后出的方式存放到Task栈中。Activity间的跳转就是Task栈中各Activity切换，位于栈顶的Activity就是我们可见可交互的Activity。启动模式，可以控制Activity的启动方式，是在Task栈中创建新的Activity还是复用以前的Activity。</p>
<h2 id="启动模式的设置"><a href="#启动模式的设置" class="headerlink" title="启动模式的设置"></a>启动模式的设置</h2><p>在AndroidManifest文件中的Activity配置中设置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MainnActivity"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span>/&gt;</span> <span class="comment">&lt;!--这里设置模式--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Standard模式"><a href="#Standard模式" class="headerlink" title="Standard模式"></a>Standard模式</h2><p>标准模式也是默认模式。Activity在这种模式下，每一个intent发送去启动Activity时，都会创建一个新的Activity并放到Task栈顶中。</p>
<h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>启动Activity时(其他应用的Activity也是)，会创建新的Activity并放到本应用Task栈顶。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式1.jpg" alt></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>没有特殊要求时，一般的Activity都会使用该模式。</p>
<h2 id="SingleTop模式"><a href="#SingleTop模式" class="headerlink" title="SingleTop模式"></a>SingleTop模式</h2><p>Activity在SingleTop模式下，如果Task栈顶已经存在一个该Activity，就不会再创建新的Activity，取而代之的是通过onNewIntent()方法将Intent发送至这个存在的Activity，也就是复用该ctivity。如果Task栈顶不存在相同类型的Activity，就会创建新的Activity并放到Task栈顶。</p>
<h3 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h3><p>如果栈顶不存在该Activity，和standard模式一样。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式2.jpg" alt></p>
<p>如果存在则复用。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式3.jpg" alt></p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>搜索功能界面的Activity。点击搜索之后都是跳回本Activity，不去创建新的Activity。</p>
<h2 id="SingleTask模式"><a href="#SingleTask模式" class="headerlink" title="SingleTask模式"></a>SingleTask模式</h2><p>一个Activity使用了SingleTask的话，如果该Task栈中存在该Activity，启动时就会把该Activity之上所有的Activity移出栈(按适当的生命周期销毁)，使该Activity变成栈顶Activity，并通过onNewIntent()方法复用该Activity。如果Task栈中没有改Activity，便创建新的Activity放到Task栈顶。</p>
<h3 id="表现-2"><a href="#表现-2" class="headerlink" title="表现"></a>表现</h3><p>栈中没有该Activity时，创建Activity并放到栈顶。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式4.jpg" alt></p>
<p>如果存在则是先把上面的Activities移出栈，使用onNewIntent()复用该Activity。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式5.jpg" alt></p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>入口处Activity，例如邮件客户端的收件箱页面或者社交应用的时间轴页面。可以使用该模式。</p>
<h2 id="SingleInstance模式"><a href="#SingleInstance模式" class="headerlink" title="SingleInstance模式"></a>SingleInstance模式</h2><p>这种模式下的Activity，只能一个Activity存在于一个栈中。当启动Activity时，若不存在该Activity，创建一个新的Task栈并创建Activity放到新Task栈顶；如果存在其他Task栈有该Activity，便把该Task栈调至前台。</p>
<h3 id="表现-3"><a href="#表现-3" class="headerlink" title="表现"></a>表现</h3><p>永远都是一个Task栈存放该Activity。</p>
<p><img src="/Android-Activity_Lunch_model/activity启动模式6.jpg" alt></p>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种模式很少被使用到。一些真实的使用场景是一个用于Launcher的Activity或者是那种你100%确保只有一个 Activity的应用程序。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity生命周期</title>
    <url>/Android-Activity_life_recycle/</url>
    <content><![CDATA[<h2 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h2><ol>
<li>运行状态running：Activity位于栈顶。</li>
<li>暂停状态pause：Activity失去了焦点不能交互，但仍然对用户可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕）。</li>
<li>停止状态stop：Activity被其他Activity完全遮挡，此时此Activity对用户不可见。</li>
<li>销毁状态kill：Activity由于人为或系统原因（如低内存等）被销毁。</li>
</ol>
<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p><img src="/Android-Activity_life_recycle/activity生命周期.png" alt="Activity生命周期图"></p>
<ol>
<li>onCreate()：此时Activity创建，进行初始化工作。</li>
<li>onStart()：此时的Activity变成可见了，但是还不可以交互。</li>
<li>onRestart()：此时Activity从不可见变成可见，还不可以交互。</li>
<li>onResume()：此时Activity在前台了，可见可交互。</li>
<li>onPause()：此时Activity不可以交互了，但是可以看见。</li>
<li>onStop()：此时Activity不可见。</li>
<li>onDestroy()：此时Activity被销毁。</li>
</ol>
<p>生命周期调用的例子：</p>
<ol>
<li>A启动：onCreateV()–&gt;onStart()–&gt;onResume()</li>
<li>点击home键退出A：onPause()–&gt;onStop()</li>
<li>再次回到A：onRestarrt()–&gt;onStart()–&gt;onResume()</li>
<li>对出A：onPause()–&gt;onStop()–&gt;onDestroy()</li>
<li>A跳转到B：A:onPause()–&gt;B:onCreate()–&gt;B:onStart()–&gt;B:OnResume()–&gt;A:OnStop()</li>
<li>B返回A：B:onPause()–&gt;A:onRestart()–&gt;A:onStart()–&gt;A:onResume()–&gt;B:onStop()–&gt;B:onDestroy()</li>
<li>A横竖屏切换：        onPause()–&gt;onStop()–&gt;onDestroy()–&gt;onCreate()–&gt;onStart()–&gt;onResume()</li>
</ol>
<blockquote>
<p>A切换到B时A的onStop方法在B启动后执行的原因：</p>
<ol>
<li><p>一个Activity或多或少会占有系统资源，而在官方的建议中，onPause方法将会释放掉很多系统资源，为切换Activity提供流畅性的保障，而不需要再等多两个阶段，这样做切换更快。</p>
</li>
<li><p>按照生命周期图的表示，如果用户在切换Activity的过程中再次切回原Activity，是在onPause方法后直接调用onResume方法的，这样比onPause→onStop→onRestart→onStart→onResume要快得多。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变。</p>
<p>当横竖屏切换时Activity会销毁然后重新创建。</p>
</blockquote>
<h2 id="onSaveInstanceState和onRestoreInstanceState"><a href="#onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState"></a>onSaveInstanceState和onRestoreInstanceState</h2><p>这两个方法不是生命周期中的方法，但是也和生命周期密切相关。当SDK小于3时onSaveInstanceState是在onPause方法中调用的，而大于3时是在onStop方法中调用的。<br>而onRestoreInstanceState是在onStart之后、onResume之前调用的。</p>
<p>onSaveInstanceState是用来保存状态数据，onRestoreInstanceState是用来恢复状态数据。这连个方法的调用时机是：1.系统处于内存不足的原因摧毁activity；2.一些系统设置的改变(屏幕方向，语言设置，键盘弹出等)。因为这两个方法不一定会被调用，因此不适合在该方法中保存持久化数据。</p>
<p>Activity横竖屏切换：onPause()–&gt;onSaveInstanceState()–&gt;onStop()–&gt;onDestory()–&gt;onCreate()–&gt;onStart()–&gt;onRestoreInstanceState()–&gt;onResume()。</p>
<h2 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent()"></a>onNewIntent()</h2><p>当Activity的LaunchMode为SingleTop时且Activity在栈顶，或者当Activity的LaunchMode为SingleInstance,SingleTask且Activity已经在堆栈中。那么启动该Activity时不再是使用onStart(),而是使用onNewIntent()。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android容器</title>
    <url>/Android-Collection/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Android系统中，内存对于应用的影响非常大。所以Android官方推荐在一些情况下使用优化的SparseArray、ArrayMap来替代Java的HashMap。</p>
<h3 id="1-SparseArray"><a href="#1-SparseArray" class="headerlink" title="1.SparseArray"></a>1.SparseArray</h3><p>在Android中，当数据长度小于千时，建议使用SparseArray替换HashMap。</p>
<p>SparseArray采用时间换取空间的方式，能够回收空间压缩数组，使用更少的内存来提高手机APP的运行效率，这也是其与HashMap的区别。</p>
<p>SparseArray大部分操作需要使用二分查找方法，不是直接哈希，所以效率会较慢。</p>
<p>在SparseArray内部，维护两个数组int[] mKeys和Object[] mValues。分别用于存放键和值，键只能是int类型。</p>
<p><img src="/Android-Collection/SparseArray结构.png" alt="SparseArray结构"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*put源码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找,key在mKeys列表中对应的index</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    <span class="comment">// 如果找到，说明之前put过相同的key，则直接赋值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 找不到</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// binarySearch方法中，找不到时，i取了其非，这里再次取非</span></span><br><span class="line">        i = ~i;</span><br><span class="line">        <span class="comment">// 如果有数据删除且整好是该位置，赋值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有数据被删除但不是该位置，使用gc函数回收空间，压缩压缩数组</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line">            <span class="comment">//再找一次，因为下标可能会变</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 插入数据，根据情况增长mKeys与mValues列表</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*二分查找方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*gc函数，压缩数组</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="2-ArrayMap"><a href="#2-ArrayMap" class="headerlink" title="2.ArrayMap"></a>2.ArrayMap</h3><p>与SparesArray大致相同，会进行数组压缩，在内部使用二分查找方法，用时间换取空间。</p>
<p>ArrayMap内部维护两个数组：int[] mHashes和Object[] mArray。mHashes用来存放key的哈希值，mArray用来存放键和值下标为单数用于存放key，下标为双数用于存放Value。</p>
<p><img src="/Android-Collection/ArrayMap结构.png" alt="ArrayMap结构"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*put源码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> osize = mSize;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = <span class="number">0</span>;</span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();</span><br><span class="line">        <span class="comment">// 通过二分查找寻找下标</span></span><br><span class="line">        index = indexOf(key, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index大于0表示之前put过相同的key，进行赋值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> V old = (V)mArray[index];</span><br><span class="line">        mArray[index] = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    index = ~index;</span><br><span class="line">    <span class="comment">//需要扩容的情况</span></span><br><span class="line">    <span class="keyword">if</span> (osize &gt;= mHashes.length) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = osize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (osize+(osize&gt;&gt;<span class="number">1</span>))</span><br><span class="line">            : (osize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: grow from "</span> + mHashes.length + <span class="string">" to "</span> + n);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">        <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">        allocArrays(n);  <span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">if</span> (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容后，需要把原来的数据拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: copy 0-"</span> + osize + <span class="string">" to 0"</span>);</span><br><span class="line">            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看被废弃的数组是否还有利用价值</span></span><br><span class="line">        freeArrays(ohashes, oarray, osize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这次put的key对应的hashcode排序没有排在最后（index没有指示到数组结尾），因此需要移动index后面的数据</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; osize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: move "</span> + index + <span class="string">"-"</span> + (osize-index)</span><br><span class="line">                         + <span class="string">" to "</span> + (index+<span class="number">1</span>));</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, osize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CONCURRENT_MODIFICATION_EXCEPTIONS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (osize != mSize || index &gt;= mHashes.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行存放</span></span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">    mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br><span class="line">    mSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* remove源码，对数组进行压缩在这里。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object old = mArray[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//如果数据量小于等于1，说明删除该元素后，没有数组为空，清空两个数组。</span></span><br><span class="line">    <span class="keyword">if</span> (mSize &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Now empty.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: shrink from "</span> + mHashes.length + <span class="string">" to 0"</span>);</span><br><span class="line">        <span class="comment">//put中已有说明</span></span><br><span class="line">        freeArrays(mHashes, mArray, mSize);</span><br><span class="line">        mHashes = EmptyArray.INT;</span><br><span class="line">        mArray = EmptyArray.OBJECT;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果当初申请的数组最大容纳数据个数大于BASE_SIZE的2倍（8），并且现在存储的数据量只用了申请数量的1/3，</span></span><br><span class="line">        <span class="comment">//则需要重新分配空间，已减少对内存的占用</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; (BASE_SIZE*<span class="number">2</span>) &amp;&amp; mSize &lt; mHashes.length/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// Shrunk enough to reduce size of arrays.  We don't allow it to</span></span><br><span class="line">            <span class="comment">// shrink smaller than (BASE_SIZE*2) to avoid flapping between</span></span><br><span class="line">            <span class="comment">// that and BASE_SIZE.</span></span><br><span class="line">            <span class="comment">//新数组的大小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt; (BASE_SIZE*<span class="number">2</span>) ? (mSize + (mSize&gt;&gt;<span class="number">1</span>)) : (BASE_SIZE*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: shrink from "</span> + mHashes.length + <span class="string">" to "</span> + n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">            <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">            allocArrays(n);</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="comment">//index之前的数据拷贝到新数组中</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from 0-"</span> + index + <span class="string">" to 0"</span>);</span><br><span class="line">                System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将index之后的数据拷贝到新数组中，和（index&gt;0）的分支结合，就将index位置的数据删除了</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                                 + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(ohashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(oarray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                                 (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="comment">//将index后的数据向前移位</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: move "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                                 + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(mHashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                                 (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移位后最后一个数据清空</span></span><br><span class="line">            mArray[mSize &lt;&lt; <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            mArray[(mSize &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (V)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构的存储表示</title>
    <url>/Data_structure-Basic_structure/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据结构是用来形容数据之间联系是怎么样的。常见的结构有四种：</p>
<ul>
<li>集合：结构中的数据元素除了“同属于一个集合”的关系外，别无其他关系。</li>
<li>线性：结构中的数据元素存在一个对一个的关系。</li>
<li>树：结构中的数据元素存在一个对多个的关系。</li>
<li>图：结构中的数据元素存在多个对多个的关系。</li>
</ul>
<p><img src="/Data_structure-Basic_structure/数据结构.png" alt></p>
<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性结构是包含n个相同性质的数据元素的有限序列。它的基本特征是：在数据元素的非空优先集中，（1）存在唯一的“第一个元素”；（2）存在唯一的“租后一个元素”；（3）除最后一个元素之外，均有且只有一个“后继”；（4）除第一个元素之外。均有且只有一个“前驱”。</p>
<h3 id="典型的线性结构"><a href="#典型的线性结构" class="headerlink" title="典型的线性结构"></a>典型的线性结构</h3><ul>
<li><strong>栈Stack</strong>，只允许在序列末端进行操作。在栈结构中，遵循<strong>先进后出</strong>的原则。最后一个元素称为栈顶，第一个元素称为栈底，新元素进入栈称为入栈或压栈，元素的删除称为出栈或弹栈。</li>
<li><strong>队列Queue</strong>，只允许在序列两端进行操作。在队列结构中，遵循<strong>先进先出</strong>的原则。</li>
<li><strong>线性表List</strong>，允许在序列任何位置进行操作。</li>
</ul>
<h3 id="线性结构的存储表示"><a href="#线性结构的存储表示" class="headerlink" title="线性结构的存储表示"></a>线性结构的存储表示</h3><p>线性结构的存储表示主要有两种：（1）顺序存储；（2）链式存储。</p>
<p><img src="/Data_structure-Basic_structure/线性结构存储表示.png" alt></p>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>树是含有n(n&gt;=0)个节点的有限集合。在任意一颗非空树中：（1）有且只有一个特定的节点称为<strong>根</strong>root节点；（2）当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集$T_1,T_2,T_3,…,T_m$,其中每一个集合本身就是一棵树，而且称为根的<strong>子树</strong>。</p>
<h3 id="典型的树结构"><a href="#典型的树结构" class="headerlink" title="典型的树结构"></a>典型的树结构</h3><ul>
<li>二叉树：在树的定义(2)上，取m=2，便是二叉树的定义。</li>
</ul>
<h3 id="树型结构的存储表示"><a href="#树型结构的存储表示" class="headerlink" title="树型结构的存储表示"></a>树型结构的存储表示</h3><ul>
<li>二叉树中的表示方式：（1）链式表示；（2）数组表示，一般用于完全二叉树。</li>
</ul>
<p><img src="/Data_structure-Basic_structure/二叉树的链式存储表示.png" alt></p>
<p><img src="/Data_structure-Basic_structure/完全二叉树的顺序存储表示.png" alt></p>
<ul>
<li>普通树中的表示方式：（1）双亲表示法，数组表示；（2）双亲孩子表示法，数组加链表；（3）孩子兄弟表示法，链表。</li>
</ul>
<p><img src="/Data_structure-Basic_structure/树的双亲表示法.png" alt></p>
<p><img src="/Data_structure-Basic_structure/树的双亲孩子表示法.png" alt></p>
<p><img src="/Data_structure-Basic_structure/树的孩子兄弟表示法.png" alt></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>图结构中，允许任何元素都可以有联系，存在多对多的关系。</p>
<h3 id="图结构的存储表示"><a href="#图结构的存储表示" class="headerlink" title="图结构的存储表示"></a>图结构的存储表示</h3><p>图的主要存储表示有两种：（1）邻接矩阵，数组加二维数组；（2）邻接表，数组加链表。</p>
<p><img src="/Data_structure-Basic_structure/图的邻接矩阵和邻接链表存储表示.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/Design_patterns-Singleton_mode/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>作用：保证一个类仅有一个实例，并提供一个访问他的全局访问点。</li>
<li>主要解决：一个全局使用的类频繁创建与销毁。</li>
<li>关键代码：1.构造函数私有化。2.多线程访问时线程安全。</li>
</ul>
<p>单例模式由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。此外，还可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式。</p>
<h2 id="单例模式写法"><a href="#单例模式写法" class="headerlink" title="单例模式写法"></a>单例模式写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>利用了JVM类加载机制，保证单例只会被创建1次，即线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态常量方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载该类时，单例就会自动被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test(); <span class="comment">//静态常量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码块方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Test test ；</span><br><span class="line">    <span class="comment">//加载该类时，单例就会自动被创建</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	test = <span class="keyword">new</span> Test(); <span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：写法简单、线程安全。</p>
<p>缺点：在类加载的时候就完成实例化，没有达到延时加载效果。如果至始至终没有使用过这个实例，则会造成内存浪费。</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>对饿汉模式进行延时加载，当要使用时才会去创建类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程不安全方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程安全方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="comment">//使用synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：做到了延时加载。</p>
<p>缺点：线程安全的时候效率太低。每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p>
<h3 id="双重检查模式"><a href="#双重检查模式" class="headerlink" title="双重检查模式"></a>双重检查模式</h3><p>对懒汉模式的进一步改进，线程安全同时避免过多的同步开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DCL模式(双重检查模式)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用volatile禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="comment">//双重判定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全、延时加载、效率较高。</p>
<p>缺点：代码不简洁。</p>
<h3 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TestHolder.test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用过程说明：</span></span><br><span class="line">      <span class="comment">// 1. 外部调用类的getInstance() </span></span><br><span class="line">      <span class="comment">// 2. 自动调用TestHolder.test</span></span><br><span class="line">       <span class="comment">// 2.1 此时单例类TestHolder得到初始化</span></span><br><span class="line">       <span class="comment">// 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例；</span></span><br><span class="line">       <span class="comment">// 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性</span></span><br><span class="line">      <span class="comment">// 3. 最终只创建1个单例</span></span><br></pre></td></tr></table></figure>

<p>优点：线程安全、延时加载、效率高，代码简洁。</p>
<h3 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h3><p>利用了枚举类的特点实现单例：</p>
<ol>
<li>枚举类型–&gt;不可被继承的类(final)</li>
<li>每个枚举元素–&gt;类静态常量</li>
<li>构造方法私有</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Test&#123;</span><br><span class="line">    <span class="comment">//定义一个枚举元素，是单例的一个实例</span></span><br><span class="line">    INSTANCE ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例的方式：</span></span><br><span class="line">Test test = Test.INSTANCE;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全、线程安全，代码非常简洁。</p>
<p>缺点：没有延时加载。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/Design_patterns-Strategy_mode/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<p>上面这句话是策略模式的官方定义。策略模式的作用就是将策略(算法)和具体类解耦，让具体类更换不同策略算法时能够更加便捷。UML图如下：</p>
<p><img src="/Design_patterns-Strategy_mode/策略模式UML.png" alt="策略模式UML"></p>
<p>图中，Context表示具体类，他有不同策略接口的引用，内部调用的是策略实现类的方法。当我们实现不同策略后，将侧策略添加到具体类中，具体类便会有不同的反应。</p>
<ul>
<li><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
</li>
<li><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Context类，具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="comment">//持有策略引用</span></span><br><span class="line">    <span class="keyword">private</span> StrategyA strategyA;</span><br><span class="line">    <span class="keyword">private</span> StrategyB strategyB;</span><br><span class="line">    <span class="comment">//设置策略的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetStrategyA</span><span class="params">(StrategyA strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategyA=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetStrategyB</span><span class="params">(StrategyB strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategyB=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用策略中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategyA.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategyB.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> class StrategyB </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承策略接口，实现具体策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">StrategyA</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">StrategyB</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <url>/Internet-TCP_handshake/</url>
    <content><![CDATA[<h3 id="三次握手和四次挥手过程"><a href="#三次握手和四次挥手过程" class="headerlink" title="三次握手和四次挥手过程"></a>三次握手和四次挥手过程</h3><p><img src="/Internet-TCP_handshake/TCP三次握手和四次挥手.png" alt="TCP三次我输和四次挥手"></p>
<ul>
<li>三次握手<ol>
<li>客户端发送连接请求，即SYN seq=x。</li>
<li>服务端接收客户端的连接请求，并且同样发送连接请求(SYN seq=y)和返回客户端请求的同意连接(ask=x+1)。</li>
<li>客户端接收服务端的连接请求，并且返回服务端请求的同意连接(ask=y+1)。</li>
</ol>
</li>
</ul>
<blockquote>
<p>只要弄懂了三次握手，四次挥手很简单，因为四次就是将三次握手的第2步拆分了而已。为什么会拆分呢？是因未连接时必须同时进行连接，但是断开时，不一定同时断开，可能一方断开，另一方继续传输数据。</p>
</blockquote>
<ul>
<li>四次挥手<ol>
<li>客户端发送断开请求，即FIN seq=x。</li>
<li>服务端接收客户端的断开请求，返回客户端请求的同意断开(ask=x+1)。</li>
<li>服务端发送断开请求，即FIN seq=y。</li>
<li>客户端接收服务端的断开请求，返回服务端请求的同意断开(ask=y+1)。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的四种访问修饰符</title>
    <url>/Java-Access_modifier/</url>
    <content><![CDATA[<h3 id="Java中的访问修饰符"><a href="#Java中的访问修饰符" class="headerlink" title="Java中的访问修饰符"></a>Java中的访问修饰符</h3><p>Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为以下四种级别。</p>
<ul>
<li><strong>public</strong>：用public修饰的类、类属变量及方法。包内及包外的任何类都可以访问。</li>
<li><strong>protected</strong>：用protected修饰的类、类属变量及方法。包内的任何类以及包外继承了该类的子类能够访问。protected突出继承。</li>
<li><strong>default</strong>：没有任何修饰符的类、类属变量和方法。包内的任何类都可以访问，包外任何类都不能访问。default突出包</li>
<li><strong>privat</strong>：用protected修饰的类、类属变量及方法。只有本类可以访问，其他包内和包外任何类都不能访问。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">不同包的非子类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td>default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>*PS：其中private和protected不能修饰顶层的类，可以修饰内部类。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器</title>
    <url>/Java-Collection/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>下图为Java编程思想中的容器类库图(不包含Queue的实现)：</p>
<p><img src="/Java-Collection/Java容器关系图.gif" alt="Java容器关系图"></p>
<p>Java SE5添加了：</p>
<ul>
<li>Queue接口及其实现<code>PriorityQueue</code>和各种风格的<code>BlockingQueue</code>。</li>
<li><code>ConcurrentMap</code>接口以及其实现类<code>ConcurentHashMap</code>，同样用于多线程机制。</li>
<li><code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>，同样用于多线程机制。</li>
<li><code>EnumSet</code>和<code>EnumMap</code>，为enum设计的Set和Map特殊实现。</li>
<li>Collections中多个便利方法。</li>
</ul>
<blockquote>
<p>由上图可知，Java集合框架主要分为两种类型的容器，一种是集合Collection，存储一个元素的集合；另一种是图Map，存储键值对。</p>
<p>对于Collection接口，又有三种子类型接口：List、Set、Queue。</p>
<p>List、Set、Queue、Map这些接口下面便是抽象类，再到具体的实现类。</p>
</blockquote>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection接口是对象集合的根接口，里面定义了很多对元素的操作方法，下图是Collection中的全部方法。</p>
<p><img src="/Java-Collection/Collection接口中的方法.png" alt="Collection接口中的方法"></p>
<p>其中有几个较为常用的方法，例如add()添加元素，contains()检查是否包含元素等。主要的子接口是List、Set和Queue。</p>
<h3 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h3><p>List接口扩展自Collection，它可以定义一个<strong><em>允许重复的有序集合</em></strong>，从List接口中的方法来看，List接口主要是增加了<strong><em>面向位置的操作</em></strong>，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要是提供对链表的支持。List有常用的两个实现类<code>ArrayList</code>和<code>LinkedList</code>。</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>通过阅读<code>ArrayList</code>的源码，我们可以很清楚地看到里面的逻辑，它是用<strong><em>数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组</em></strong>，并将当前数组中的所有元素都复制到新数组中。</p>
<p>假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、方法add(E e)向集合中添加指定元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、此方法主要是确定将要创建的数组大小。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>通过观察<code>LinkedList</code>的源码，可以发现<code>LinkedList</code>是<strong><em>使用链表进行元素的存储</em></strong>。下面是LinkedList的链表节点结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点Node</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Set"><a href="#2-Set" class="headerlink" title="2.Set"></a>2.Set</h3><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例<strong><em>不包含重复的元素</em></strong>。在一个规则集内，一定不存在两个相等的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是HashSet、LinkedHashSet和TreeSet。Set的实现基本都是在<strong><em>内部使用Map</em></strong>进行存储。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code>底层使用<code>HashMap</code>来保存所有元素，因此<code>HashSet</code>的实现比较简单，相关<code>HashSet</code>的操作，基本上都是直接调用底层HashMap的相关方法来完成。键值对中键便是HashSet存的，值是固定的一个Object。</p>
<p>下面是HashSet的部分源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部有一个HasMap，值的类型是Object</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">//默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//初始化时创建HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add方法直接使用HashMap的put，值是默认值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在put方法(实际是HashMap的put方法)中保证元素不重复的过程</p>
<ol>
<li>如果hash码值不相同，说明是一个新元素，存；</li>
<li>如果hash码值相同，且equles判断相等，说明元素已经存在，不存；</li>
<li>如果hash码值相同，且equles判断不相等，说明元素不存在，存；</li>
</ol>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>低层使用<code>LinkedHashMap</code>保存元素，因为<code>LinkedHashMap</code>使用链表保存数据，所以是有对数据进行排序的。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>低层使用<code>TreeMap</code>保存元素，<code>TreeMap</code>使用树形结构保存数据，内部是有序序列，而且能够按照不同Comparator指定元素顺序。</p>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3.Queue"></a>3.Queue</h3><p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。</p>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">"aaaa"</span>);</span><br><span class="line">        queue.offer(<span class="string">"bbbb"</span>);</span><br><span class="line">        queue.offer(<span class="string">"cccc"</span>);</span><br><span class="line">        queue.offer(<span class="string">"dddd"</span>);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(queue.remove() + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code>类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在图中的是键值构成的条目。下面是接口Map的类结构。</p>
<p><img src="/Java-Collection/Map接口中的结构.png" alt="Map接口中的结构"></p>
<p>上图可以看到，<strong><em>Entry就是对键值对的封装</em></strong>。Map也提供了很多查询、更新和获取存储的键值对的方法，更新包括方法clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。Map接口常用的有三个具体实现类，分别是<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。<strong><em><code>HashMap</code>内部使用数组和链表结构实现</em></strong>。在<strong><em>JDK1.8中，<code>HashMap</code>采用数组+链表+红黑树实现</em></strong>，当链表长度超过阈值时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p><img src="/Java-Collection/1.7中HashMap结构.png" alt="1.7中HashMap结构"></p>
<p><img src="/Java-Collection/1.8中HashMap结构.png" alt="1.8中HashMap结构"></p>
<p><code>HashMap</code>采用类似链地址法的方法解决哈希冲突，相同哈希值以节点方式存到数组同位置的后继节点。Table数组是可以扩容的，当元素数量超过阈值时，进行扩容。当链表中的元素较多，即hash值相等的元素较多时，采用红黑树结构替换链表结构。</p>
<p>下面分析put和get的源码，jdk1.8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*put源码</span></span><br><span class="line"><span class="comment">*hash是对key进行哈希</span></span><br><span class="line"><span class="comment">*key和value是键值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//table的初始化</span></span><br><span class="line">        n = (tab = resize()).length; </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//i是数组下标</span></span><br><span class="line">        <span class="comment">//如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//第一个节点key相同处理</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树结构处理</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//链表结构处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//新增节点后如果节点个数到达阈值，则将链表转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新hash值和key值均相同的节点Value值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//如果size超过阈值，table数组扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*get源码</span></span><br><span class="line"><span class="comment">*hash是key的哈希值</span></span><br><span class="line"><span class="comment">*key是键</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//先找到数组对应位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//第一个就是的话就返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//红黑树处理</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//链表处理</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap的扩容机制：当元素数量size超过阈值threshold时，进行扩容。新建一个当前数组容量capacity两倍的新数组，将数组复制过去。</p>
<blockquote>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>
<p>loadFactor：负载因子，默认为 0.75。</p>
<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>
</blockquote>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>它继承自<code>HashMap</code>，实现了Map接口。其<strong>内部还维护了一个双向链表</strong>，在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。默认情况，遍历时的顺序是<strong>按照插入节点的顺序</strong>。这也是其与<code>HashMap</code>最大的区别。<br> 也可以在构造时传入accessOrder参数，使得其遍历顺序按照访问的顺序输出。</p>
<p><code>LinkedHashMap</code>在实现时，就是重写override了几个方法。以满足其输出序列有序的需求。因继承自<code>HashMap</code>,所以<code>HashMap</code>分析的特点，除了输出无序，其他<code>LinkedHashMap</code>都有，比如扩容的策略，哈希桶长度一定是2的N次方等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部的Entry增加了before，改成一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code>是Java内部实现比较复杂的集合类之一。与<code>HashMap</code>不一样，<code>TreeMap</code>的底层不是用哈希表实现的，而是用红黑树实现的。另外，<code>HashMap</code>存取元素的时间复杂度是O(1)的常量级，而<code>TreeMap</code>对元素的操作复杂度为O(log n)。虽然在操作性能方面，<code>TreeMap</code>不占优势，但是因为它使用红黑树（平衡二叉查找树）实现，所以它内部的元素都是排好序的。当需要查找的元素是排好序的，<code>TreeMap</code>的优势就体现出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部Entry结构，树节点形式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他集合实现类"><a href="#其他集合实现类" class="headerlink" title="其他集合实现类"></a>其他集合实现类</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>前面我们已经提到，Java设计者们在对之前的容器类进行重新设计时保留了一些数据结构，其中就有<code>Vector</code>。用法上，<code>Vector</code>与<code>ArrayList</code>基本一致，不同之处在于<code>Vector</code>使用了关键字<code>synchronized</code>将访问和修改向量的方法都变成同步的了，所以对于不需要同步的应用程序来说，类<code>ArrayList</code>比类<code>Vector</code>更高效。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><code>Stack</code>，栈类，是Java2之前引入的，继承自类<code>Vector</code>。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>HashTable</code>和前面介绍的<code>HashMap</code>很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，<code>HashTable</code>是继承自Dictionary的，<code>HashTable</code>中的函数都是同步的，这意味着它也是线程安全的，另外，<code>HashTable</code>中key和value都不可以为null。</p>
<blockquote>
<p>上面的三个集合类都是在Java2之前推出的容器类，可以看到，尽管在使用中效率比较低，但是它们都是线程安全的。而下面三个是java.util.concurrent包下增加的专门为并发而实现的容器。</p>
</blockquote>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Concurrent，并发，从名字就可以看出来<code>ConcurrentHashMap</code>是<code>HashMap</code>的线程安全版。同<code>HashMap</code>相比，<code>ConcurrentHashMap</code>不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高。</p>
<p>JDK1.7中，<code>ConcurrentHashMap</code><strong><em>采用Segment+HashEntry方式实现</em></strong>。也就是在1.7版本<code>HashMap</code>中加上Segment数组，简单理解就是，<code>ConcurrentHashMap</code>是一个 Segment 数组，Segment 通过继承 <code>ReentrantLock</code> 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="/Java-Collection/1.7中ConcurrentHashMap结构.png" alt="1.7中ConcurrentHashMap结构"></p>
<p>JDK1.8中放弃了Segment臃肿的设计，取而代之的是<strong><em>采用Node + CAS + Synchronized</em></strong>来保证并发安全进行实现。其中synchronized加锁的地方访问的节点。</p>
<p><img src="/Java-Collection/1.8中ConcurrentHashMap结构.png" alt="1.8中ConcurrentHashMap结构"></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>与<code>ConcurrentHashMap</code>一样在java.util.concurrent包下，是为了并发而设计的容器。顾名思义，Write的时候总是要Copy，也就是说对于<code>CopyOnWriteArrayList</code>，任何可变的操作都是伴随复制这个动作的。也正是因为每次改变代价都比较大，所以它适用于读操作远多于修改操作的并发场景中。</p>
<p><code>CopyOnWriteArrayList</code>内部是一个Object[] array。每次改变操作，先加锁，新建新数组，对新数组操作，复制到原来的Object[] array上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*add源码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用ReentrantLock加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">//新建一个容量大的数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements); <span class="comment">//复制数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyOnWriteArrayList</code>有两个重要的分布式理念，这也使得它多用于数据库操作中。</p>
<ol>
<li>读写分离：我们读取<code>CopyOnWriteArrayList</code>的时候读取的是<code>CopyOnWriteArrayList</code>中的Object[] array，但是修改的时候，操作的是一个新的Object[] array，读和写操作的不是同一个对象，这就是读写分离。这种技术数据库用的非常多，在高并发下为了缓解数据库的压力，即使做了缓存也要对数据库做读写分离，读的时候使用读库，写的时候使用写库，然后读库、写库之间进行一定的同步，这样就避免同一个库上读、写的IO操作太多。</li>
<li>最终一致：因为读写分离，读取的数据可能不是最新的数据。最终一致对于分布式系统也非常重要，它通过容忍一定时间的数据不一致，提升整个分布式系统的可用性与分区容错性。当然，最终一致并不是任何场景都适用的，像火车站售票这种系统用户对于数据的实时性要求非常非常高，就必须做成强一致性的。</li>
</ol>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>在内部是一个<code>CopyonWriteArrayList</code>，继承了Set，具有Set特点。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 垃圾回收机制和算法</title>
    <url>/Java-Garbage_recovery/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾回收是java一个特色，不用像C/C++一样需要频繁的free()和delete()来进行内存回收。垃圾回收机制作用于java堆(Heap)。在jvm运行时，对象创建越来越多，堆便不够存放，需要实行垃圾回收队没用的对象进行内存回收以节省空间。</p>
<h2 id="Java中的对象的四种引用"><a href="#Java中的对象的四种引用" class="headerlink" title="Java中的对象的四种引用"></a>Java中的对象的四种引用</h2><p>在Java中，对象的回收会根据这个对象的引用来判断，下面是Java中对对象的四种引用简介。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h3><p>强引用（Strong Reference）：如“Object obj = new Object()”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h3><p>软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。</p>
<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h3><p>弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</p>
<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h3><p>虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。</p>
<table>
<thead>
<tr>
<th align="center">引用类型</th>
<th align="center">回收时间</th>
<th align="center">用途</th>
<th align="center">生存时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">强引用</td>
<td align="center">从来不会</td>
<td align="center">对象一般状态</td>
<td align="center">JVM停止运行时终止</td>
</tr>
<tr>
<td align="center">软引用</td>
<td align="center">内存不足时</td>
<td align="center">对象缓存</td>
<td align="center">内存不足时终止</td>
</tr>
<tr>
<td align="center">弱引用</td>
<td align="center">垃圾回收时</td>
<td align="center">对象缓存</td>
<td align="center">GC运行后终止</td>
</tr>
<tr>
<td align="center">虚引用</td>
<td align="center">unknown</td>
<td align="center">unknown</td>
<td align="center">unknown</td>
</tr>
</tbody></table>
<h2 id="判断对象是否可回收算法"><a href="#判断对象是否可回收算法" class="headerlink" title="判断对象是否可回收算法"></a>判断对象是否可回收算法</h2><h3 id="1-引用计算法"><a href="#1-引用计算法" class="headerlink" title="1.引用计算法"></a>1.引用计算法</h3><p>堆中每个对象都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1。当引用失效时，计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<ul>
<li><p>优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。</p>
</li>
<li><p>缺点：难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。</p>
</li>
</ul>
<h3 id="2-根搜索算法"><a href="#2-根搜索算法" class="headerlink" title="2.根搜索算法"></a>2.根搜索算法</h3><p>先选取一些特别的对象标记为GC Roots，以图的形式根据可达性(以强应用判断是否可达)往下搜索所有的引用节点。搜索到的节点都是存活的，相反则是不存活的。Java和C#中都是采用根搜索算法来判定对象是否存活的。在堆中，可以作为GC Root的对象包括：（1）虚拟机栈中引用的对象。（2）方法区中的常量引用的对象。（3）方法区中的类静态属性引用的对象。（4）本地方法栈中JNI的引用对象。（5）活跃线程。</p>
<ul>
<li>优点：可以在搜索时进行标记解决循环问题。</li>
<li>缺点：使用此方法进行判断时，需要暂停线程，因为对象图一直在变换是无法真正遍历的。因此一旦对象非常多的话，这种方法就需要更多时间处理。</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除法"><a href="#1-标记-清除法" class="headerlink" title="1.标记-清除法"></a>1.标记-清除法</h3><p>顾名思义，标记-清除法分为两个阶段：标记、清除。标记表示上述的根搜索法进行对象的标记。清除就是将标记为无用对象进行内存回收。</p>
<p><img src="/Java-Garbage_recovery/标记清除法.png" alt></p>
<ul>
<li>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</li>
<li>缺点：（1）标记和清除过程的效率都不高。（2）标记清除后会产生大量不连续的内存碎片。</li>
</ul>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h3><p>复制算法把内存按容量分为两个相同的块。每次只使用其中的一块，当一块用完后，就将存活的对象复制到另一块，然后再清理已使用的空间。Java堆中新生代的回收中就是使用这种算法。</p>
<p><img src="/Java-Garbage_recovery/复制算法.png" alt></p>
<ul>
<li>优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现</li>
<li>缺点：（1）需要牺牲一半内存，开销较大。（2）当较多对象存活率高时，效率急速下降。</li>
</ul>
<blockquote>
<p>研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。这10%便是新生代的Survivor区域。</p>
</blockquote>
<h3 id="3-标记-整理法"><a href="#3-标记-整理法" class="headerlink" title="3.标记-整理法"></a>3.标记-整理法</h3><p>标记-整理算法的思想和标记-清除算法类似，分为两个步骤。标记步骤是一样的，但后续步骤不是清除可回收的对象，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。一般Java堆中老年代使用此方法。</p>
<p><img src="/Java-Garbage_recovery/标记整理法.png" alt></p>
<ul>
<li>优点：（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成，相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</li>
<li>缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</li>
</ul>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h3><p>当代商用的虚拟机都是使用的分代收集算法，这种算法没有什么新的思想，就是根据对象存活的情况不同，把内存分为新生代和年老代，新生代对象存活率低，就用复制算法，年老代存活率高，就用标记–清除算法或者标记–整理算法。</p>
<h2 id="HotSpot虚拟机提供的几种垃圾收集器"><a href="#HotSpot虚拟机提供的几种垃圾收集器" class="headerlink" title="HotSpot虚拟机提供的几种垃圾收集器"></a>HotSpot虚拟机提供的几种垃圾收集器</h2><ul>
<li>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</li>
<li>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</li>
</ul>
<p><img src="/Java-Garbage_recovery/HotSpot的圾收集器.png" alt></p>
<h3 id="1-Serial-Serial-Old"><a href="#1-Serial-Serial-Old" class="headerlink" title="1. Serial/Serial Old"></a>1. Serial/Serial Old</h3><p>最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。</p>
<h3 id="2-ParNew"><a href="#2-ParNew" class="headerlink" title="2. ParNew"></a>2. ParNew</h3><p>Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集，在多核CPU环境下有着比Serial更好的表现。</p>
<h3 id="3-Parallel-Scavenge"><a href="#3-Parallel-Scavenge" class="headerlink" title="3. Parallel Scavenge"></a>3. Parallel Scavenge</h3><p>新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，它主要是为了达到一个可控的吞吐量。追求高吞吐量，高效利用CPU。吞吐量一般为99%。    </p>
<h3 id="4-Parallel-Old"><a href="#4-Parallel-Old" class="headerlink" title="4. Parallel Old"></a>4. Parallel Old</h3><p>Parallel Scavenge的老年代版本，采用Mark-Compact算法和多线程，吞吐量优先。</p>
<h3 id="5-CMS"><a href="#5-CMS" class="headerlink" title="5. CMS"></a>5. CMS</h3><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。高并发、低停顿，追求最短GC回收停顿时间，CPU占用比较高。响应时间快，停顿时间短，多核CPU 追求高响应时间的选择。</p>
<h3 id="6-G1"><a href="#6-G1" class="headerlink" title="6. G1"></a>6. G1</h3><p>G1(Garbage First)收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p>
<p>G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM的内存划分</title>
    <url>/Java-JVM_memory_partition/</url>
    <content><![CDATA[<h2 id="JVM的内存划分情况"><a href="#JVM的内存划分情况" class="headerlink" title="JVM的内存划分情况"></a>JVM的内存划分情况</h2><p><img src="/Java-JVM_memory_partition/JVM内存分配情况.png" alt></p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>程序计数器（Program Counter Register)，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。</p>
<h3 id="2-Java栈"><a href="#2-Java栈" class="headerlink" title="2.Java栈"></a>2.Java栈</h3><p>Java虚拟机栈(Java Virtal Machine Stack)，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。</p>
<p>在栈内，一个方法就是一个栈帧。每个栈帧存储着局部变量表、操作数引用、动态链接、出口等信息。</p>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>本地方法栈（Native Method Stack）与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h3><p>堆（Heap）,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><p>方法区（Method Area)。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池也在方法区中。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。</p>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h3><p>运行时常量池（Run-Time Constant Pool)，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。</p>
<p>在Class文件中，有一项信息是常量池。该常量池主要存放两大类常量：</p>
<ul>
<li>字面量（Literal），如文本字符串、final常量值</li>
<li>符号引用，存放了与编译相关的一些常量，因为Java不像C++那样有连接的过程，因此字段方法这些符号引用在运行期就需要进行转换，以便得到真正的内存入口地址。</li>
</ul>
<p>Class文件中的常量池，也称为静态常量池，JVM虚拟机完成类装载操作后，会把静态常量池加载到内存中，存放在运行时常量池。</p>
<h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h3><p>直接内存（Direct Memory），直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。</p>
<h2 id="可能出现OOM的区域"><a href="#可能出现OOM的区域" class="headerlink" title="可能出现OOM的区域"></a>可能出现OOM的区域</h2><p>OOM是指JVM的内存不够用了，同时垃圾收集器也无法提供更多的内存。在JVM抛出OutOfMemoryError之前，垃圾收集器一般会先尝试回收内存。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆内存不足是最常见的发送OOM的原因之一，如果在堆中没有内存完成对象实例的分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”。当前主流的JVM可以通过-Xmx和-Xms来控制堆内存的大小，发生堆上OOM的可能是存在内存泄露，也可能是堆大小分配不合理。</p>
<h3 id="Java虚拟机栈和本地方法栈"><a href="#Java虚拟机栈和本地方法栈" class="headerlink" title="Java虚拟机栈和本地方法栈"></a>Java虚拟机栈和本地方法栈</h3><p>这两个区域的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在内存分配异常上是相同的。在JVM规范中，对Java虚拟机栈规定了两种异常：1.如果线程请求的栈大于所分配的栈大小，则抛出StackOverFlowError错误，比如进行了一个不会停止的递归调用；2. 如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出OutOfMemoryError错误。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存虽然不是虚拟机运行时数据区的一部分，但既然是内存，就会受到物理内存的限制。在JDK1.4中引入的NIO使用Native函数库在堆外内存上直接分配内存，但直接内存不足时，也会导致OOM。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>随着Metaspace元数据区的引入，方法区的OOM错误信息也变成了“java.lang.OutOfMemoryError:Metaspace”。对于旧版本的Oracle JDK，由于永久代的大小有限，而JVM对永久代的垃圾回收并不积极，如果往永久代不断写入数据，例如String.Intern()的调用，在永久代占用太多空间导致内存不足，也会出现OOM的问题，对应的错误信为“java.lang.OutOfMemoryError:PermGen space”</p>
<table>
<thead>
<tr>
<th align="center">内存区域</th>
<th align="center">是否线程私有</th>
<th align="center">是否可能发生OOM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">程序计数器</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">Java栈</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">本地方法栈</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">方法区</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">直接内存</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h2 id="堆中的内存划分情况"><a href="#堆中的内存划分情况" class="headerlink" title="堆中的内存划分情况"></a>堆中的内存划分情况</h2><p>堆是JVM所管理中最大的一块区域，主要用于存放各种实例对象。</p>
<p>堆被分为两个不同区域：新生代(Young)和老年代(Old)。其中新生代又分为三个区域：Eden和两个Survivor区域。新生带站整个堆内存的1/3，老年代占整个堆内存的2/3。新生代中，Eden占其8/10，两个Survivor分别占1/10。</p>
<p><img src="/Java-JVM_memory_partition/新生代和老年代.png" alt></p>
<h3 id="新生代的Eden区域"><a href="#新生代的Eden区域" class="headerlink" title="新生代的Eden区域"></a>新生代的Eden区域</h3><p>对象的分配会优先分配在该区域。同时JVM可以为每个线程分配一个私有的缓存区域，称为TLAB，避免多线程同时分配内存时需要使用加锁等机制而影响分配速度。TLAB在堆上分配，位于Eden中。</p>
<h3 id="新生代的Survivor区域"><a href="#新生代的Survivor区域" class="headerlink" title="新生代的Survivor区域"></a>新生代的Survivor区域</h3><p>当Eden区域内存不足时会触发Minor GC，也称为新生代GC，在Minor GC存活下来的对象，会被复制到Survivor区域中。我认为Survivor区的作用在于避免过早触发Full GC。如果没有Survivor，Eden区每进行一次Minor GC都把对象直接送到老年代，老年代很快便会内存不足引发Full GC。新生代中有两个Survivor区，我认为两个Survivor的作用在于提高性能，避免内存碎片的出现。在任何时候，总有一个Survivor是empty的，在发生Minor GC时，会将Eden及另一个的Survivor的存活对象拷贝到该empty Survivor中，从而避免内存碎片的产生。</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代放置长生命周期的对象，通常是从Survivor区域拷贝过来的对象，不过当对象过大的时候，无法在新生代中用连续内存的存放，那么这个大对象就会被直接分配在老年代上。一般来说，普通的对象都是分配在TLAB上，较大的对象，直接分配在Eden区上的其他内存区域，而过大的对象，直接分配在老年代上。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内部类</title>
    <url>/Java-Inner_class/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><h4 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h4><p>声明在类内体部，方法体外，没有用static修饰的类。</p>
<p>成员内部类中不能存在static关键字，即，不能声明静态属性、静态方法、静态代码块等。但是可以定义static final的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Out</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>  ;  <span class="comment">//编译正常</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//编译正常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> j=<span class="number">0</span> ;  <span class="comment">//编译出错</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="keyword">new</span> Integer(<span class="number">1</span>) ;  <span class="comment">//编译出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a>2.静态内部类</h4><p>声明在类内体部，方法体外，用static修饰的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Out</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>  ;  <span class="comment">//编译正常</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//编译正常</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> j=<span class="number">0</span> ;  <span class="comment">//编译正常</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="keyword">new</span> Integer(<span class="number">1</span>) ;  <span class="comment">//编译正常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3.局部内部类"></a>3.局部内部类</h4><p>声明在方法体中，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>  ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a>4.匿名内部类</h4><p>没有名字的局的内部类，一般隐式的继承某一个父类或者实现某一个接口。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pen</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Pencil</span> <span class="keyword">implements</span> <span class="title">Pen</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//铅笔 的工厂</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">user</span><span class="params">(Pen pen)</span> </span>&#123;</span><br><span class="line">		pen.write();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyInnerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Person guo = <span class="keyword">new</span> Person();</span><br><span class="line">		<span class="comment">//匿名内部类使用</span></span><br><span class="line">		guo.user(<span class="keyword">new</span> Pen() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"写字"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内部类的一些特殊地方"><a href="#内部类的一些特殊地方" class="headerlink" title="内部类的一些特殊地方"></a>内部类的一些特殊地方</h2><h4 id="1-为什么非静态内部类中不能有static属性的变量，却可以有static-final属性的变量？"><a href="#1-为什么非静态内部类中不能有static属性的变量，却可以有static-final属性的变量？" class="headerlink" title="1.为什么非静态内部类中不能有static属性的变量，却可以有static final属性的变量？"></a>1.为什么非静态内部类中不能有static属性的变量，却可以有static final属性的变量？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Out</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>  ;  <span class="comment">//编译正常</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//编译正常</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> j=<span class="number">0</span> ;  <span class="comment">//编译出错</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="keyword">new</span> Integer(<span class="number">1</span>) ;  <span class="comment">//编译出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，使用stati修饰的变量，是类变量，不是对象变量。如果非静态内部类中有static变量，会因为没有加载内部类而加载不到static变量，所以编译时会报错。但是使用final static修饰变量的话，他就是一个常量，出游常量池中，是不附属于类的，所以编译不出错。但是static final变量指向对象的话就不行，因为创建对象是运行时，这样就不能指定该变量在常量池中了。</p>
<h4 id="2-为什么局部内部类和匿名内部类只能访问局部final变量？"><a href="#2-为什么局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="2.为什么局部内部类和匿名内部类只能访问局部final变量？"></a>2.为什么局部内部类和匿名内部类只能访问局部final变量？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;  <span class="comment">//变量b需要是final</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span> ; <span class="comment">//变量a需要是final</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//只要把a和b任意的final去掉都编译出错</span></span><br><span class="line">                System.out.println(a) ;</span><br><span class="line">                System.out.println(b) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面这段代码，我们可以考虑到，当test方法执行完毕，变量a的的生命周期就结束了。那么Thread的run方法就不能访问a了。为了解决这个问题，Java采用的是复制手段，即内部类会复制一个a变量，操作是对复制的这个变量进行操作。但是操作后可能会改变这个复制变量的值，导致数据不一致。所以java就限定使用final，不允许对a进行更改。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ReentrantLock</title>
    <url>/Java-ReentrantLock/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ReentrantLock是一个用于多线程并发编程时保证线程安全的类。与synchronized类似，使用了“锁”这个概念去保证线程安全。ReentrantLock实现了Lock接口，内部使用AbstractQueuedSynchronizer(AQS)实现。</p>
<p><img src="/Java-ReentrantLock/ReentrantLock关系图.png" alt></p>
<p>ReentrantLock的聚合关系如下：</p>
<ul>
<li>ReentrantLock实现了Lock,Serializable接口。</li>
<li>ReentrantLock.Sync(内部类)继承了AQS。</li>
<li>ReentrantLock.NonfairSync和ReentrantLock.FairSync继承了ReentrantLock.Sync。</li>
<li>ReentrantLock持有ReentrantLock.Sync对象(实现锁功能)。</li>
</ul>
<h2 id="与synchronized的比较"><a href="#与synchronized的比较" class="headerlink" title="与synchronized的比较"></a>与synchronized的比较</h2><p>ReentrantLock和synchronized类似，他们都是用“锁”这个概念实现线程安全，下面是他们的一些区别。</p>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>从字面上理解，ReentrantLock就是可重入锁的意思，是可重入的。而synchronized也是可重入的，两者这个区别不大。都是同一个线程每进入一次，锁的计数器便加1，需要等到锁的计数器下降为0时才会释放锁。</p>
<h3 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h3><p>synchronized是依赖于JVM实现的，就是操作系统实现的。而ReentrantLock是JDK层面实现的，也就是通过代码控制的。</p>
<h3 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h3><p>没优化前，synchronized性能非常差。但是在JDK1.6之后，synchronized通过优化后，和ReentrantLock性能差不多。</p>
<h3 id="功能区别"><a href="#功能区别" class="headerlink" title="功能区别"></a>功能区别</h3><p>synchronized使用代码简洁，而ReentrantLock需要手工声明加锁和释放锁。但是ReentrantLock不仅有synchronized的全部功能，还有三个特有功能：</p>
<ol>
<li>可等待中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>可实现公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。ReentrantLock默认是使用非公平锁，synchronized只能是非公平锁。</li>
<li>锁可以绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可。</li>
</ol>
<h2 id="ReentrantLock的使用"><a href="#ReentrantLock的使用" class="headerlink" title="ReentrantLock的使用"></a>ReentrantLock的使用</h2><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>ReentrantLock是实现了Lock接口，Lock接口定义了锁的行为，下面是接口中的方法，ReentrantLock也对这些接口进行了实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">	<span class="comment">//上锁(不响应Thread.interrupt()直到获取锁)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//上锁(响应Thread.interrupt())</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">	<span class="comment">//尝试获取锁(以nonFair方式获取锁)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">//在指定时间内尝试获取锁(响应Thread.interrupt(),支持公平/二阶段非公平)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">	<span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//获取Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本的上锁与释放锁"><a href="#基本的上锁与释放锁" class="headerlink" title="基本的上锁与释放锁"></a>基本的上锁与释放锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock  = <span class="keyword">new</span> ReentrantLock() ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//操作放在try块中，配合finally使用</span></span><br><span class="line">            i++ ;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//需要在finally中释放锁，避免锁无法释放</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用lock()之后要在finally块中释放锁，避免出现死锁现象。</p>
<h3 id="Condition的使用"><a href="#Condition的使用" class="headerlink" title="Condition的使用"></a>Condition的使用</h3><p>Condition是被绑定到Lock上的一个用于线程通信的类，要创建一个Lock的Condition必须用Lock的newCondition()方法，一个Lock可以创建多个Condiction。</p>
<p>在使用synchronized进行同步时，可以使用Object的wait()、notify()和notifyAll()方法进行线程的通信。而使用ReentrantLock时，使用Condiction替代了Object监视器方法。其中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。</p>
<p>Condition它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition();<span class="comment">//写线程条件 </span></span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">//读线程条件 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//缓存队列</span></span><br><span class="line">    <span class="keyword">int</span> putptr<span class="comment">/*写索引*/</span>, takeptr<span class="comment">/*读索引*/</span>, count<span class="comment">/*队列中存在的数据个数*/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                <span class="comment">//如果队列满了，阻塞写线程</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();<span class="comment">//唤醒读线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果队列为空阻塞读线程</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();<span class="comment">//唤醒写线程</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他获取锁的方法"><a href="#其他获取锁的方法" class="headerlink" title="其他获取锁的方法"></a>其他获取锁的方法</h3><ul>
<li>lock()：阻塞式获取锁，只有在获取到锁后才处理interrupt消息。</li>
<li>lockInterruptibly()：阻塞式获取锁，如有interrupt消息立刻处理，并抛出异常。</li>
<li>tryLock()：尝试获取锁，不管成功失败，都立刻返回true或false。</li>
<li>tryLock(long timeout,TimeUnit unit)：尝试在timeout时间段内阻塞式获取锁，成功返回true，超时返回false。如有interrupt消息立刻处理，并抛出异常。</li>
</ul>
<h2 id="ReentrantLock内部"><a href="#ReentrantLock内部" class="headerlink" title="ReentrantLock内部"></a>ReentrantLock内部</h2><p>ReentrantLock的内部是通过AbstractQueuedSynchronizer（AQS）这个框架实现，其他的一些同步工具类的基础也是AQS。AQS的功能可以分为独占和共享两种，ReentrantLock实现了独占功能。</p>
<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS即是AbstractQueuedSynchronizer，JDK1.5提供的一个基于FIFO等待队列实现的一个用于实现同步器的基础框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</p>
<p>AQS没有锁之类的概念，它有个state变量，是个int类型，使用volatile修饰，在不同场合有着不同含义。而ReentrantLock就是把state当成锁来进行使用。可以说，AQS的核心思想是基于volatile int state这样的一个属性同时配合Unsafe工具对其原子性的操作(CAS)来实现对state的状态进行修改来达到独占和共享功能。</p>
<p>AQS中，有一个双向链表队列，节点是对Thread封装的Node：</p>
<p><img src="/Java-ReentrantLock/AQS的双向队列.png" alt></p>
<h3 id="Lock源码"><a href="#Lock源码" class="headerlink" title="Lock源码"></a>Lock源码</h3><h4 id="公平锁的Lock-方法"><a href="#公平锁的Lock-方法" class="headerlink" title="公平锁的Lock()方法"></a>公平锁的Lock()方法</h4><p>公平锁的lock直接调用AQS的acquire方法,具体由AQS的实现类完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用AQS的acquire方法</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire是尝试直接获取的方法，acquireQueued是加入同步队列的方法</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁的tryAcquire方法，尝试直接获取，需要判断队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//当前锁没被占用</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//1.判断同步队列中是否有节点在等待</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//2.如果上面!1成立,修改state值(表明当前锁已被占用)</span></span><br><span class="line">            setExclusiveOwnerThread(current);<span class="comment">//3.如果2成立,修改当前占用锁的线程为当前线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//占用锁线程==当前线程(重入)</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">//修改status</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//直接获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取不成功，加入同步队列里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//生成node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line"> 	<span class="comment">//将node加到队列尾部</span></span><br><span class="line"> 	   node.prev = pred;</span><br><span class="line"> 	   <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line"> 		   pred.next = node;</span><br><span class="line"> 		   <span class="keyword">return</span> node;</span><br><span class="line"> 	   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果加入失败(多线程竞争或者tail指针为null)</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤1.1  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//死循环加入节点(cas会失败)</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 	   Node t = tail;</span><br><span class="line"> 	   <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//tail为null,同步队列初始化</span></span><br><span class="line"> 		<span class="comment">//设置head指针</span></span><br><span class="line"> 		   <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))<span class="comment">//注意这里是个空节点!!</span></span><br><span class="line"> 			   tail = head;<span class="comment">//将tail也指向head</span></span><br><span class="line"> 	   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 		   node.prev = t;<span class="comment">//将当前node加到队尾</span></span><br><span class="line"> 		   <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"> 			   t.next = node;</span><br><span class="line"> 			   <span class="keyword">return</span> t;<span class="comment">//注意这里才返回</span></span><br><span class="line"> 		   &#125;</span><br><span class="line"> 	   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤2</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> 	<span class="comment">//表示是否被打断</span></span><br><span class="line"> 	   <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"> 	   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> 		<span class="comment">//获取node.pre节点</span></span><br><span class="line"> 		   <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"> 		   <span class="keyword">if</span> (p == head <span class="comment">//当前节点是否是同步队列中的第二个节点</span></span><br><span class="line"> 		   &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//获取锁,head指向当前节点</span></span><br><span class="line"> 			   setHead(node);<span class="comment">//head=head.next</span></span><br><span class="line"> 			   p.next = <span class="keyword">null</span>;<span class="comment">//置空 </span></span><br><span class="line"> 			   failed = <span class="keyword">false</span>;</span><br><span class="line"> 			   <span class="keyword">return</span> interrupted;</span><br><span class="line"> 		   &#125;</span><br><span class="line"></span><br><span class="line"> 		   <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">//是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)</span></span><br><span class="line"> 			   parkAndCheckInterrupt())<span class="comment">//利用unsafe.park()进行空转(阻塞)</span></span><br><span class="line"> 			   interrupted = <span class="keyword">true</span>;<span class="comment">//如果Thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)</span></span><br><span class="line"> 	   &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 	   <span class="keyword">if</span> (failed)<span class="comment">//tryAcquire()过程出现异常导致获取锁失败,则移除当前节点</span></span><br><span class="line"> 		   cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，获取不了锁，并且成功加入同步队里后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();<span class="comment">//执行线程的interrupt()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非公平锁的Lock-方法"><a href="#非公平锁的Lock-方法" class="headerlink" title="非公平锁的Lock()方法"></a>非公平锁的Lock()方法</h4><p>基本和公平锁过一样，有两个地方区别：lock和tryAcquire有区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在acquire()之前先尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;<span class="comment">//这个过程其实和FairSync.tryAcquire()基本一致</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//唯一区别: 这里不会去判断队列中是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>区别点</th>
<th>lock()过程（一阶段）</th>
<th>tryAcquire()过程（二阶段）</th>
</tr>
</thead>
<tbody><tr>
<td>FairSync公平锁</td>
<td>直接acquire()</td>
<td>当前若无线程持有锁,如果同步队列为空,获取锁</td>
</tr>
<tr>
<td>NonFairSync非公平锁</td>
<td>先尝试获取锁，再acquire()</td>
<td>当前若无线程持有锁,获取锁</td>
</tr>
</tbody></table>
<h3 id="unLock源码"><a href="#unLock源码" class="headerlink" title="unLock源码"></a>unLock源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//释放锁</span></span><br><span class="line">	Node h = head;</span><br><span class="line">	<span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp;<span class="comment">//head节点为空(非公平锁直接获取锁)</span></span><br><span class="line">	h.waitStatus != <span class="number">0</span>)</span><br><span class="line">		unparkSuccessor(h);<span class="comment">//唤醒同步队列中离head最近的一个waitStatus&lt;=0的节点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">	<span class="comment">//持有锁的线程==当前线程</span></span><br><span class="line">	<span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//重入锁全部释放</span></span><br><span class="line">		free = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//置空持有锁线程</span></span><br><span class="line">		setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//state==0(此时持有锁,不用cas)</span></span><br><span class="line">	setState(c);</span><br><span class="line">	<span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射</title>
    <url>/Java-Reflection/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
<p>反射最重要的用途就是开发各种通用框架。</p>
<p>反射机制的作用：</p>
<ol>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时任意调用一个对象的方法。</li>
<li>在运行时构造任意一个类的对象。</li>
</ol>
<p>反射机制提供的功能：</p>
<ol>
<li>在运行时能够判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任一对象的方法。</li>
<li>在运行时创建新类对象</li>
</ol>
<h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><h3 id="1-获取class对象"><a href="#1-获取class对象" class="headerlink" title="1. 获取class对象"></a>1. 获取class对象</h3><ol>
<li>使用Class类的 <code>forName()</code>静态方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"类名"</span>) ;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接获取某一个对象的class：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span> </span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用某个对象的<code>getClass()</code>方法 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; clazz = str.getClass();</span><br></pre></td></tr></table></figure>

<h3 id="2-判断是否为某个类的实例"><a href="#2-判断是否为某个类的实例" class="headerlink" title="2.判断是否为某个类的实例"></a>2.判断是否为某个类的实例</h3><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-创建实例"><a href="#3-创建实例" class="headerlink" title="3. 创建实例"></a>3. 创建实例</h3><ol>
<li>使用Class对象的<code>newInstance()</code>方法来创建Class对象对应类的实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的<code>newInstance()</code>方法来创建实例。这种方法可以用指定的构造器构造类的实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<h3 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4. 获取方法"></a>4. 获取方法</h3><ol>
<li><code>getDeclaredMethods</code> 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>getMethods</code> 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>getMethod</code> 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-获取成员变量"><a href="#5-获取成员变量" class="headerlink" title="5.获取成员变量"></a>5.获取成员变量</h3><ol>
<li><code>getFiled</code>：访问公有的成员变量</li>
<li><code>getDeclaredField</code>：所有已声明的成员变量，但不能得到其父类的成员变量</li>
</ol>
<h3 id="6-调用方法"><a href="#6-调用方法" class="headerlink" title="6.调用方法"></a>6.调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用 <code>invoke()</code> 方法来调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException,InstantiationException, </span></span><br><span class="line"><span class="function">    	NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//获取class对象</span></span><br><span class="line">        Class&lt;?&gt; klass = methodClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//创建methodClass的实例</span></span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-利用反射创建数组"><a href="#8-利用反射创建数组" class="headerlink" title="8.利用反射创建数组"></a>8.利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面是利用反射创建数组的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Object array = Array.newInstance(cls,<span class="number">25</span>);</span><br><span class="line">    <span class="comment">//往数组里添加内容</span></span><br><span class="line">    Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</span><br><span class="line">    Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</span><br><span class="line">    Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</span><br><span class="line">    Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</span><br><span class="line">    Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</span><br><span class="line">    <span class="comment">//获取某一项的内容</span></span><br><span class="line">    System.out.println(Array.get(array,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ThreadLocal类</title>
    <url>/Java-ThreadLocal/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ThreadLocal是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。说白了，ThreadLocal就是想在多线程环境下去保证成员变量的安全。ThreadLocal提供不同的方法对ThreadLocal变量进行操作。</p>
<p><img src="/Java-ThreadLocal/ThreadLocal类中的方法.png" alt></p>
<h2 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以在创建变量时是定默认值，需要重写initialValue()</span></span><br><span class="line">ThreadLocal&lt;String&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用get()和set()方法获取和改变值</span></span><br><span class="line">mStringThreadLocal.set(<span class="string">"jun"</span>);</span><br><span class="line">String s = mStringThreadLocal.get();</span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="1-set-源码"><a href="#1-set-源码" class="headerlink" title="1. set()源码"></a>1. set()源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t); <span class="comment">//根据当前线程获取该线程的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value); <span class="comment">//以ThreadLocal为key，存入值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ThreadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-get-源码"><a href="#2-get-源码" class="headerlink" title="2. get()源码"></a>2. get()源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">//获取当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">//根据当前线程获取该线程的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>); <span class="comment">//以ThreadLocal获得Entry，再获取值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(); <span class="comment">//如果为空则调用setInitialValue方法获取默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();  <span class="comment">//默认值</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//设置默认值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap是Thread类中的一个变量。每个线程去获取threadLocal的值时，其实就是获取自己线程中threadLocalMap中对应的threadLocal的值，ThreadLocalMap内部是一个Entry数组，每一个Entry就是存放键值对，键为不同的threadLocal。</p>
<h3 id="3-Entry类源码"><a href="#3-Entry类源码" class="headerlink" title="3. Entry类源码"></a>3. Entry类源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123; <span class="comment">//使用的是弱引用</span></span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-原理总结"><a href="#4-原理总结" class="headerlink" title="4. 原理总结"></a>4. 原理总结</h3><p>总的来说，ThreadLocal的实现是这样的：每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是 ThreadLocal实例本身，value是真正需要存储的Object。也就是说ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</p>
<p><img src="/Java-ThreadLocal/ThreadLocal内部原理.png" alt="ThreadLocal内部原理"></p>
<h2 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h2><h3 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h3><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：当前线程引用–&gt;当前线程–&gt;线程中的ThreaLocalMap–&gt;Entry–&gt;value永远无法回收，造成内存泄漏。</p>
<p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get()，set()，remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。</p>
<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>
<ul>
<li>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li>
<li>分配使用了ThreadLocal又不再调用get()，set()，remove()方法，那么就会导致内存泄漏。</li>
</ul>
<h3 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>
<ul>
<li><p><strong>key使用强引用</strong>：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
</li>
<li><p><strong>key使用弱引用</strong>：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</p>
</li>
</ul>
<p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<h3 id="ThreadLocal的最佳实践"><a href="#ThreadLocal的最佳实践" class="headerlink" title="ThreadLocal的最佳实践"></a>ThreadLocal的最佳实践</h3><p>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Final关键字</title>
    <url>/Java-final/</url>
    <content><![CDATA[<h3 id="final作用"><a href="#final作用" class="headerlink" title="final作用"></a>final作用</h3><h4 id="1-final修饰类"><a href="#1-final修饰类" class="headerlink" title="1.final修饰类"></a>1.final修饰类</h4><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<h4 id="2-final修饰方法"><a href="#2-final修饰方法" class="headerlink" title="2.final修饰方法"></a>2.final修饰方法</h4><p>final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。</p>
<h4 id="3-final修饰变量"><a href="#3-final修饰变量" class="headerlink" title="3.final修饰变量"></a>3.final修饰变量</h4><p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。</p>
<p>final修饰的变量，一旦初始化后边不能改变其值，不能改变指向的对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java static关键字</title>
    <url>/Java-static/</url>
    <content><![CDATA[<h3 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h3><p>static 关键字的作用：方便在没有创建对象的情况下进行调用方法和变量。</p>
<p>static 关键字修饰的方法或者变量不需要依赖对象进行访问，只要类被加载了，就可以通过类名去访问。</p>
<p>static可以用来修饰类的成员方法、类的成员变量，还可以编写static代码块。</p>
<h4 id="1-static方法"><a href="#1-static方法" class="headerlink" title="1.static方法"></a>1.static方法</h4><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p>
<p>*SP：构造方法是特殊的方法，没有是不是static一说。</p>
<h4 id="2-static变量"><a href="#2-static变量" class="headerlink" title="2.static变量"></a>2.static变量</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h4 id="3-static代码块"><a href="#3-static代码块" class="headerlink" title="3.static代码块"></a>3.static代码块</h4><p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。</p>
<h3 id="static要注意的地方"><a href="#static要注意的地方" class="headerlink" title="static要注意的地方"></a>static要注意的地方</h3><p>static不改变访问权限。</p>
<p>static不能用于局部变量，语法规定。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java synchronized关键字</title>
    <url>/Java-synchronized/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在多线程并发编程中，造成线程安全的因素由两点构成：（1）存在共享数据。（2）多个线程对共享数据进行操作。解决线程安全问题的方法比较多，synchronized便是其中一种。synchronized能够保证时同一时刻，只有一个线程执行某个方法或者代码块。除此之外，synchronized还可以保证可见性，即线程做出的变化可以被其他线程看到。</p>
<h2 id="synchronized的三种应用"><a href="#synchronized的三种应用" class="headerlink" title="synchronized的三种应用"></a>synchronized的三种应用</h2><p>synchronized主要的应用有如下三种：</p>
<ol>
<li>修饰实例方法，加锁对象是当前实例。</li>
<li>修饰静态方法，加锁的对象是当前类。</li>
<li>修饰代码块，可以自定义加锁对象。</li>
</ol>
<h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span> ; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，修饰实例方法的加锁的对象是当前实例。就是说不同的实例去对使用add()方法对类变量i进行操作时，不是互斥状态。</p>
<h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此加锁对象的当前类，对于不同实例来说，也会是互斥状态。</p>
<h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object() ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">            i++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰代码块时，加锁的对象可以自定义。但是这个对象对于不同线程来说需要是同一个。如果加锁的对象只是一个局部变量，这样的话不同线程是没有互斥状态的。</p>
<h2 id="synchronized的底层实现原理"><a href="#synchronized的底层实现原理" class="headerlink" title="synchronized的底层实现原理"></a>synchronized的底层实现原理</h2><p>synchronized是JVM层面实现的同步。而JVM中的同步是基于进入和退出管程(Monitor)对象实现。而Monitor对象，是在每一个Java对象的对象头中存放指向它的指针。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>Java对象在堆内存中结构如下：</p>
<p><img src="/Java-synchronized/堆中的Java实例对象.png" alt></p>
<ol>
<li>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li>
<li>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li>
<li>对象头：对象头存储一下对象的信息，一般为2个字节：<ul>
<li>Mark Word：存储对象的hashCode、锁信息或分代年龄或GC标志等信息。</li>
<li>Class Metadata Address：类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</li>
<li>Array Length：如果对象是数组则会分配多一个字节，多出来的这个字节记录的是数组长度。</li>
</ul>
</li>
</ol>
<p>其中，Mark Word的32bits会根据对象的锁的状态而存储不同信息。</p>
<p>![](Java-synchronized\Mark Word字节存储的信息.jpg)</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>重量级锁，也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是Monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。</p>
<p>在Java虚拟机HotSpot中，Monitor内部大致由两个队列 _Entry、_WaitSet和一个指针_Owner构成。_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入_EntryList集合，当线程获取到对象的monitor 后进入_Owner区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)</p>
<p><img src="/Java-synchronized/Monitor中的两个队列和一个区域.png" alt></p>
<p>由上述可知，moniter对象存在于每个Java对象的对象头中，synchronized便是通过这种方式获取锁的。这也就说明为什么Java中任意对象都可以作为锁，为什么notify/notifyAll/wait等方法在Object中。</p>
<h2 id="JVM对synchronized的优化"><a href="#JVM对synchronized的优化" class="headerlink" title="JVM对synchronized的优化"></a>JVM对synchronized的优化</h2><h3 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1.偏向锁"></a>1.偏向锁</h3><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<h3 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<h3 id="3-适应性自旋"><a href="#3-适应性自旋" class="headerlink" title="3.适应性自旋"></a>3.适应性自旋</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<h3 id="4-锁粗化"><a href="#4-锁粗化" class="headerlink" title="4.锁粗化"></a>4.锁粗化</h3><p>锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。</p>
<h3 id="5-锁消除"><a href="#5-锁消除" class="headerlink" title="5.锁消除"></a>5.锁消除</h3><p>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Volatile关键字</title>
    <url>/Java-volatile/</url>
    <content><![CDATA[<h3 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h3><p>一个变量声明volatile后，具有两个特性：<strong><em>内存可见性</em></strong> 和<strong><em>禁止指令重排序优化</em></strong>。</p>
<ul>
<li><p><strong>内存可见性</strong>：通俗来说就是，线程A对一个volatile变量的修改，对于其它线程来说是可见的，即线程每次获取volatile变量的值都是最新的。Volatile变量的普通变量的内存操作区别如下。</p>
<ol>
<li>对于普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主内存中拷贝一份数据到工作内存中；写操作只会修改工作内存的副本数据，修改之后何时写入回主存不知道。这种情况下，其它线程就无法读取变量的最新值。</li>
<li>对于volatile变量，读操作时JVM会把工作内存中对应的值设为无效，要求线程从主内存中读取数据；写操作时JVM会把工作内存中对应的数据刷新到主内存中，这种情况下，其它线程就可以读取变量的最新值。</li>
</ol>
</li>
<li><p><strong>禁止指令重排序优化</strong>：有volatile修饰的变量，赋值后多执行了一个“lock addl $0x0, (%esp)”操作，这个操作相当于一个<em>内存屏障</em>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。如果执行一下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span> ;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果a变量没有使用volatile关键字修饰的话，JVM在编译优化时可能先执行b=2的操作，然后再执行a=1的操作。</li>
<li>如果a变量使用volatile关键字修饰的话，就一定会先执行a=1操作。</li>
</ol>
</li>
</ul>
<h3 id="volatile的一些主要使用"><a href="#volatile的一些主要使用" class="headerlink" title="volatile的一些主要使用"></a>volatile的一些主要使用</h3><h4 id="1-状态标记量"><a href="#1-状态标记量" class="headerlink" title="1.状态标记量"></a>1.状态标记量</h4><p>在高并发的场景中，通过一个boolean类型的变量isopen，控制代码是否走促销逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isOpen ; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOpen)&#123;</span><br><span class="line">            <span class="comment">//促销逻辑代码</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//正常逻辑代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsOpen</span><span class="params">(<span class="keyword">boolean</span> isOpen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isOpen = isOpen ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景细节无需过分纠结，这里只是举个例子说明volatile的使用方法，用户的请求线程执行run方法，如果需要开启促销活动，可以通过后台设置，具体实现可以发送一个请求，调用setIsopen方法并设置isopen为true，由于isopen是volatile修饰的，所以一经修改，其他线程都可以拿到isopen的最新值，用户请求就可以执行促销逻辑了。</p>
<h4 id="2-单例的double-check模式"><a href="#2-单例的double-check模式" class="headerlink" title="2.单例的double check模式"></a>2.单例的double check模式</h4><p>单例模式的一种实现方式，但很多人会忽略volatile关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是100%，说不定在未来的某个时刻，隐藏的bug就出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用volatile禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="comment">//双重判定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//这里不使用volatile的话可能会指令从排序</span></span><br><span class="line">                <span class="comment">//一般是先创建对象new Test()，再将test指向这个对象</span></span><br><span class="line">                <span class="comment">//指令重排序后就是可能出现先将test指向一个东西，再创建这个对象</span></span><br><span class="line">                <span class="keyword">if</span>(test==<span class="keyword">null</span>) test = <span class="keyword">new</span> Test() ; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程</title>
    <url>/java-Thread/</url>
    <content><![CDATA[<h2 id="线程和进程概念"><a href="#线程和进程概念" class="headerlink" title="线程和进程概念"></a>线程和进程概念</h2><p>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</p>
<p>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） </p>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 </p>
<p>main()就是一个线程，其线程体就是main函数里面的代码块。</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>JAVA多线程实现方式主要有三种：继承<code>Thread</code>类、实现<code>Runnable</code>接口、使用<code>Callable</code>和<code>Future</code>实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。</p>
<p>继承<code>Thread</code>类的方法不能共享实例变量，后面两种是用传入target的形式，可以共享target的对象。</p>
<p>启动线程的唯一方法就是通过<code>Thread</code>类的start()实例方法。start()不能被重复调用，它是一个native方法，它将启动一个新线程，并执行其run()方法。要注意的时，start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p>
<h3 id="1-继承java-lang-Thread类实现多线程"><a href="#1-继承java-lang-Thread类实现多线程" class="headerlink" title="1.继承java.lang.Thread类实现多线程"></a>1.继承java.lang.Thread类实现多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello jun"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后在合适的地方启动线程：</span></span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread1.start();</span><br></pre></td></tr></table></figure>

<h3 id="2-实现java-lang-Runnable接口方式实现多线程"><a href="#2-实现java-lang-Runnable接口方式实现多线程" class="headerlink" title="2.实现java.lang.Runnable接口方式实现多线程"></a>2.实现java.lang.Runnable接口方式实现多线程</h3><p>如果自己的类已经extends另一个类，就无法直接extends Thread，此时，必须实现一个Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello jun"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后把Runnable作为target传给Thread构造一个新线程：</span></span><br><span class="line">MyRunnable myRunnable1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myRunnable1);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//实际上是当传入一个Runnable的target参数给Thread后，Thread的run()方法就会调用target.run()。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Callable和Future"><a href="#3-Callable和Future" class="headerlink" title="3.Callable和Future"></a>3.Callable和Future</h3><p><code>Callable</code>类似<code>Runnable</code>，都是一个Thread的target，Runnable的线程执行体的run()，而Callable的线程执行体的call()，但是call()可以有返回值，可以抛出异常。它的返回值可以被Future拿到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Callable实例</span></span><br><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// call()可以有返回值，可以抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">8023</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用Future来包装Callable</span></span><br><span class="line">FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</span><br><span class="line"><span class="comment">//FutureTask作为Thread的target</span></span><br><span class="line"><span class="keyword">new</span> Thread(future).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//用FutureTask的get()方法取得call()的返回值</span></span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口比继承Thread类所具有的优势：</p>
<ul>
<li><p>适合多个相同的程序代码的线程去处理同一个资源</p>
</li>
<li><p>可以避免java中的单继承的限制</p>
</li>
<li><p>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</p>
</li>
<li><p>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</p>
</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/java-Thread/线程生命周期1.png" alt="线程生命周期1"></p>
<p><img src="/java-Thread/线程生命周期2.png" alt="线程生命周期2"></p>
<p><img src="/java-Thread/线程生命周期3.png" alt="线程生命周期3"></p>
<ol>
<li>新建状态（New）：即用new刚刚新创建了一个线程对象。</li>
<li>就绪状态（Runnable）：即调用了的tart()方法后的状态，不能直接调用run来执行线程，必须调用start()。调用run()方法只是在当前线程执行run()里面的操作。</li>
<li>运行状态（Running）：线程进入CPU，执行程序代码。</li>
<li>阻塞状态（Blocked）：暂时停止运行。</li>
</ol>
<ul>
<li>通过调用sleep(millseconds)使任务进入休眠状态,在这种状态下,任务在指定的时间内不会运行</li>
<li>通过wait()使线程挂起.直到线程得到了notify()或notifyAll()消息,或是signal()和singalAll(),线程才会进入就绪状态</li>
<li>任务在等待某个输入/输出(I/O)完成</li>
<li>任务试图在某个对象上调用其同步控制方法,但是对象锁不可用,因为另一个任务已经获取了这个锁</li>
</ul>
<ol>
<li>死亡状态（Dead）：该线程结束生命周期，不能再用start()启动。</li>
</ol>
<h2 id="Java中Thread的常用方法"><a href="#Java中Thread的常用方法" class="headerlink" title="Java中Thread的常用方法"></a>Java中Thread的常用方法</h2><blockquote>
<p><strong>public void start()</strong></p>
</blockquote>
<p>使该线程开始执行。</p>
<blockquote>
<p><strong>public void run()</strong></p>
</blockquote>
<p>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</p>
<blockquote>
<p><strong>public final void setPriority(int priority)和public final int getPriority()</strong></p>
</blockquote>
<p>Java线程的优先级用整数1~10表示，Thread类有以下三个静态常量：</p>
<ul>
<li>static int MAX_PRIORITY  线程最高优先级，取值为10</li>
<li>static int MIN_PRIORITY 线程最低优先级，取值为1</li>
<li>static int NORM_PRIORITY 线程默认优先级，取值为5</li>
</ul>
<p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级 。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p>
<blockquote>
<p><strong>public final void setDaemon(boolean on)</strong></p>
</blockquote>
<p>将一个线程设置为后台进程，线程设为后台线程后，它会在所有前台线程死亡后自动死亡。</p>
<blockquote>
<p><strong>public final void join()</strong></p>
</blockquote>
<p>如果A线程中调用了B线程的join方法，那么A线程会阻塞，等待B线程执行完毕A才回到准备状态。</p>
<blockquote>
<p><strong>public void interrupt()</strong></p>
</blockquote>
<p>设置线程的中断标记。每个线程都有一个interrupt标志。当线程在阻塞状态时，如sleep、wait、await（park）、join，此时如果对该进程调用interrupt()方法，该线程会被唤醒、interrupt标志被修改，并抛出InterruptedException异常（一旦捕捉到异常，立刻重置interrupt标志），因此上述的那些方法被要求为必须捕捉异常；当线程在运行中并未进入任何阻塞状态时，则interrupt()操作不会打算线程执行，只会修改该线程interrupt标志，此时可以通过Interrupted()/isInterrupted()查看并作出处理(前者会重置该标志位)，通常使用while循环来检查。</p>
<p><strong><em>下面的方法是Thread类的静态方法。</em></strong></p>
<blockquote>
<p><strong>public static void yield()</strong></p>
</blockquote>
<p>它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行。</p>
<blockquote>
<p><strong>public static void sleep(long millisec)</strong></p>
</blockquote>
<p>使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h3 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1.同步方法"></a>1.同步方法</h3><p>即有<code>synchronized</code>关键字修饰的方法。</p>
<p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> money = <span class="number">8023</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> save)</span> </span>&#123;</span><br><span class="line">    	money += save ;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code>关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p>
<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2.同步代码块"></a>2.同步代码块</h3><p>即有<code>synchronized</code>关键字修饰的语句块。</p>
<p>被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object() ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> money = <span class="number">8023</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> save)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//synchronized(this)锁住整个类</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            money += save ;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save2</span><span class="params">(<span class="keyword">int</span> save)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//synchronized(obj)锁住obj这个对象</span></span><br><span class="line">        <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">            money += save ;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用特殊域变量volatile"><a href="#3-使用特殊域变量volatile" class="headerlink" title="3.使用特殊域变量volatile"></a>3.使用特殊域变量volatile</h3><ul>
<li><code>volatile</code>关键字为域变量的访问提供了一种免锁机制。</li>
<li><code>volatile</code>变量每次读取都是从主内存中读取最新的值，操作完后马上写入回主存。保证了变量可见性。</li>
<li><code>volatile</code>不会提供任何原子操作，它也不能用来修饰final类型的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> money = <span class="number">8023</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> save)</span> </span>&#123;</span><br><span class="line">        money += save ;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用<code>final</code>域，有锁保护的域和<code>volatile</code>域可以避免非同步的问题</p>
<h3 id="4-使用重入锁"><a href="#4-使用重入锁" class="headerlink" title="4.使用重入锁"></a>4.使用重入锁</h3><p><code>ReentrantLock</code>类是可重入、互斥、实现了Lock接口的锁，它与使用<code>synchronized</code>方法和快具有相同的基本行为和语义，并且扩展了其能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> money = <span class="number">8023</span>;</span><br><span class="line">    <span class="comment">//需要声明这个锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> save)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            money += save;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//需要在finally解锁，避免死锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 。</p>
<h3 id="5-使用ThreadLocal局部变量"><a href="#5-使用ThreadLocal局部变量" class="headerlink" title="5.使用ThreadLocal局部变量"></a>5.使用ThreadLocal局部变量</h3><p>如果使用<code>ThreadLocal</code>管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程安全产生影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用ThreadLocal类管理共享变量money</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; money = </span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">8023</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span> <span class="params">(<span class="keyword">int</span> save)</span></span>&#123;</span><br><span class="line">        money.set(money.get()+save);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这个方法能保证线程安全，但是是在每个线程创建副本，内存开销变大而且需要在之后进行变量同步。</p>
<h3 id="6-使用阻塞队列"><a href="#6-使用阻塞队列" class="headerlink" title="6.使用阻塞队列"></a>6.使用阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个容量为10的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedBlockingQueue&lt;Integer&gt; queue = </span><br><span class="line">        <span class="keyword">new</span>	LinkedBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMoney</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//添加一个元素，满了则阻塞</span></span><br><span class="line">            queue.put(m);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMoney</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//删除头元素，没有则阻塞</span></span><br><span class="line">            queue.take() ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-使用原子变量"><a href="#7-使用原子变量" class="headerlink" title="7.使用原子变量"></a>7.使用原子变量</h3><p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<p>其中<code>AtomicInteger</code>表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger money = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMoney</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//对AtomicInteger进行操作</span></span><br><span class="line">        <span class="keyword">int</span> i = money.addAndGet(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMoney</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//对AtomicInteger进行操作</span></span><br><span class="line">        <span class="keyword">int</span> i = money.addAndGet(-m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p>线程之间的执行可以是没有关联的，也是可以通过方法让他们进行各种通信操作，下面介绍一下线程之间的通信方式。</p>
<h3 id="1-利用共享变量实现"><a href="#1-利用共享变量实现" class="headerlink" title="1.利用共享变量实现"></a>1.利用共享变量实现</h3><p>利用共享的变量，达到线程的控制。具体方法有（1）利用最基本的synchronized、notify和wait；（2）利用Lock和Condition；（3）利用volatile变量；（4）利用原子变量AtomicInteger。</p>
<h3 id="2-利用CyclicBarrier这个API"><a href="#2-利用CyclicBarrier这个API" class="headerlink" title="2.利用CyclicBarrier这个API"></a>2.利用CyclicBarrier这个API</h3><p>CyclicBarrier可以实现让一组线程在全部到达Barrier时(执行await())，再一起同时执行，并且所有线程释放后，还能复用它,即为Cyclic。这个API其实还是利用lock和condition，无非是多个线程去争抢CyclicBarrier的instance的lock罢了，最终barrierAction执行时，是在抢到CyclicBarrierinstance的那个线程上执行的。</p>
<h3 id="3-利用管道方式"><a href="#3-利用管道方式" class="headerlink" title="3.利用管道方式"></a>3.利用管道方式</h3><p>使用类似PipedInputStream这样的API进行通信，不过速度会很慢。</p>
<h3 id="4-利用BlockingQueue阻塞队列"><a href="#4-利用BlockingQueue阻塞队列" class="headerlink" title="4.利用BlockingQueue阻塞队列"></a>4.利用BlockingQueue阻塞队列</h3><p>根据对BlockingQueue这行不同方法的结果进行通信控制。BlockingQueue包含的一些方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>不同返回值</th>
<th>阻塞线程</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>队尾插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>队头移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>获取，不删处</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<h2 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a>终止线程方式</h2><p>java中有3种方式可以终止正在运行的线程</p>
<ol>
<li>使用退出标志，正常退出，也就是run()方法完成后终止。</li>
<li>使用stop()方法强行停止，由于不安全，会造成数据不一致，不建议使用。</li>
<li>使用interrupt()方法中断线程。</li>
</ol>
<blockquote>
<p>第一种方法中，设置标记无法中断一个阻塞的线程。第二种方法不安全。第三种方法中interrupt()方法只是给线程设置状态为中断状态，具体由代码实现。并且当一个阻塞的线程使用interrupt()时，会抛出一个InterruptedException。</p>
</blockquote>
<p>下面是使用interrupt()方法正确终止线程的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread testThread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        testThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//主线程sleep</span></span><br><span class="line">        testThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"main end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果标记为中断则停止线程</span></span><br><span class="line">        <span class="keyword">while</span>(!isInterrupt())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"hello jun"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//如果线程正在阻塞，则会退出循环</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
</search>
